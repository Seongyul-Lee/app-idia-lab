# 마음날씨 (MaumNalssi) — PRD v1.2

> 작성일: 2026-01-31
> 수정일: 2026-02-02
> 상태: 채택
> 대상: 002-마음날씨

---

## 1. Executive Summary

마음날씨는 한국어 고유 감정 어휘(서운함, 답답함, 억울함, 뿌듯함 등 30~40종)로 매일 10초 만에 감정을 기록하고, 축적된 데이터에서 감정-활동-시간 패턴을 분석하여 개인화된 셀프케어 행동을 제안하는 감정 관리 앱이다. "기록하고 끝"인 기존 감정 기록 앱(하루콩, MOODA)과 "전문 상담 중심"인 심리상담 앱(마인드카페, 트로스트) 사이의 공백—**기록 → 분석 → 행동**의 완결 루프—을 월 3,900원의 프리미엄 구독으로 제공한다. 2026 필코노미(Feelconomy) 트렌드와 한국 기분 기록 앱 사용자 4배 성장(2023 50만→2025 200만, 와이즈앱)에 편승하여, MZ세대 감정 관리 중간층 300~500만 명을 타겟으로 한다.

---

## 2. Problem Statement

### 2-1. 핵심 Pain Point

| # | Pain Point | 근거 |
|---|-----------|------|
| P1 | **"기록하고 끝" 문제**: 감정 기록 앱(하루콩 1,000만 DL, MOODA)은 기록 이후 "그래서 어떻게 해야 하는가?"에 대한 답을 주지 않는다 | 경쟁분석 — 하루콩/MOODA 약점 분석 |
| P2 | **상담 진입 장벽**: 심리상담 앱(마인드카페 400만+, 트로스트 80만+)은 회당 3~10만 원의 비용과 심리적 부담이 높다 | 시장분석 §3-1 |
| P3 | **"기록과 상담 사이" 공백**: 전문 상담은 부담스럽지만 단순 기록보다 능동적인 관리가 필요한 대다수 사용자층(300~500만 명)이 방치되고 있다 | 시장분석 §1-2 |
| P4 | **한국어 감정 표현 미반영**: 기존 앱은 영어권 감정 분류 체계(Plutchik's Wheel)를 번역한 수준. '서운하다', '답답하다', '억울하다', '눈치 보인다' 같은 한국어 고유 감정을 구분하지 못한다 | 추가리서치 §2-4, 경쟁분석 §2-4 |
| P5 | **감정 패턴 인식 부재**: 어떤 상황에서 어떤 감정이 반복되는지 스스로 인식하기 어렵다. AI 기반 패턴 분석을 제공하는 앱이 시장에 부재한다 | 경쟁사 심층분석 §5-1 |

### 2-2. 시장 배경

- **필코노미(2026 트렌드코리아)**: 감정을 관리하는 것이 역량이자 소비 동기가 되는 시대. 감정 인식 → 패턴 발견 → 대응 행동의 완결된 루프 필요 (시장분석 §2-1)
- **메타센싱(Z세대)**: 감정도 MBTI처럼 객관적으로 분석하고 싶어하는 욕구. AI에게 심리 상담 경험 20대 24.5% (추가리서치 §4-2)
- **한국 기분 기록 앱 사용자**: 2023년 50만 → 2025년 상반기 200만 (4배 성장, 와이즈앱)
- **AI 심리상담 이용 의향 40%**, 그러나 효과 불신 55%, 전문성 의심 47% → "AI 상담"이 아닌 "데이터 기반 패턴 분석"으로 포지셔닝하여 우려 회피 (시장분석 §2-3)

---

## 3. Target Users & Personas

### 페르소나 1: 김지은 (28세, 스타트업 마케터)

| 항목 | 내용 |
|------|------|
| 배경 | 서울 거주, 스타트업 3년차. 업무 스트레스로 감정 기복이 심하지만 상담받을 시간·비용 여유 없음 |
| 현재 행동 | 하루콩으로 감정 기록 중이나 "기록만 쌓이고 뭘 해야 할지 모르겠다"는 불만 |
| Pain Point | 회의 후 답답함이 반복되는데 패턴을 인식하지 못함. 상담은 부담스럽고 혼자 감정을 관리하고 싶음 |
| 기대 가치 | "화요일 오후 회의 후 답답함이 반복됩니다. 5분 호흡법을 시도해보세요" 같은 구체적 행동 제안 |
| 지불 의향 | 월 3,900원 정도는 커피 한 잔 값으로 충분히 납득 |

### 페르소나 2: 박현우 (22세, 대학생)

| 항목 | 내용 |
|------|------|
| 배경 | 경기도 거주, 대학교 3학년. 취업 불안과 대인관계 스트레스. MBTI를 즐기듯 감정도 객관적으로 파악하고 싶음 |
| 현재 행동 | 루빗으로 루틴 관리 중이나 감정 기록은 부가기능 수준. 가끔 ChatGPT에 감정 상담 시도 |
| Pain Point | "억울하다"와 "서운하다"의 차이를 구분하고 싶지만 기존 앱은 영어 번역 수준의 감정 분류만 제공 |
| 기대 가치 | 한국어 감정 어휘로 미묘한 감정을 정확히 기록하고, 주간 감정 리포트를 SNS에 공유 |
| 지불 의향 | 무료로 시작, 상세 리포트에 가치를 느끼면 유료 전환 고려 |

### 페르소나 3: 이수진 (34세, 육아맘/프리랜서)

| 항목 | 내용 |
|------|------|
| 배경 | 인천 거주, 프리랜서 디자이너 + 3세 자녀 육아. 혼자 시간이 거의 없어 간편한 기록 필요 |
| 현재 행동 | 명상 앱(마보)을 시도했으나 시간 투자가 부담. 감정 기록은 해본 적 없음 |
| Pain Point | 육아 스트레스로 감정 소진이 반복되지만, 10분 명상조차 시간 여유가 없음. 10초 기록은 가능 |
| 기대 가치 | 10초 기록 후 "지금 당장 할 수 있는 3분 셀프케어" 제안. 월간 감정 변화 트렌드로 자기 관리 |
| 지불 의향 | 연간 구독(할인)으로 부담 없이 사용 |

---

## 4. User Stories

### Epic 1: 온보딩 & 인증

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-01 | As a 신규 사용자, I want 카카오/구글/애플 소셜 로그인으로 10초 내에 가입할 수 있기를, so that 별도 비밀번호 없이 바로 시작할 수 있다 | P0 |
| US-02 | As a 신규 사용자, I want 첫 실행 시 3단계 온보딩(앱 소개/감정 어휘 미리보기/알림 설정)을 경험하기를, so that 앱의 핵심 가치를 빠르게 이해한다 | P0 |
| US-03 | As a 기존 사용자, I want 앱 재설치 시 기존 데이터가 복원되기를, so that 기록이 유실되지 않는다 | P1 |

### Epic 2: 감정 기록

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-04 | As a 사용자, I want 한국어 감정 태그(서운함, 답답함, 뿌듯함 등) 1~3개를 터치로 선택하여 10초 내에 감정을 기록하기를, so that 매일 부담 없이 감정을 기록할 수 있다 | P0 |
| US-05 | As a 사용자, I want 감정 태그와 함께 활동 태그(출근, 회의, 운동, 식사, 대화 등)를 연결하기를, so that 어떤 활동이 어떤 감정을 유발하는지 추적할 수 있다 | P0 |
| US-06 | As a 사용자, I want 선택적으로 한줄 메모(최대 100자)를 추가하기를, so that 그날의 맥락을 기록으로 남길 수 있다 | P0 |
| US-07 | As a 사용자, I want 캘린더 뷰에서 과거 기록을 조회하기를, so that 지난 감정 흐름을 한눈에 볼 수 있다 | P0 |
| US-08 | As a 사용자, I want 하루에 여러 번 감정을 기록하기를, so that 시간대별 감정 변화를 추적할 수 있다 | P1 |
| US-09 | As a 사용자, I want 감정 기록 시 감정 강도(1~5)를 선택하기를, so that 감정의 세기를 구분하여 더 정밀한 분석이 가능하다 | P1 |

### Epic 3: AI 감정 패턴 분석 & 리포트

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-10 | As a 사용자, I want 주간 감정 요약 리포트를 받기를, so that 한 주 동안의 감정 패턴을 한눈에 파악할 수 있다 | P0 |
| US-11 | As a 유료 사용자, I want 월간 상세 패턴 분석 리포트(감정-활동-시간 상관관계)를 받기를, so that "화요일 오후에 답답함이 집중됩니다" 같은 인사이트를 얻을 수 있다 | P0 |
| US-12 | As a 유료 사용자, I want 감정-활동 상관관계 인사이트("운동한 날 긍정 감정 2배")를 보기를, so that 어떤 활동이 감정에 긍정적/부정적 영향을 주는지 알 수 있다 | P1 |
| US-13 | As a 유료 사용자, I want 분기별 감정 트렌드 리포트를 보기를, so that 장기적 감정 변화를 추적할 수 있다 | P2 |

### Epic 4: 셀프케어 행동 카드

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-14 | As a 사용자, I want 감정 기록 후 현재 감정에 맞는 셀프케어 행동 카드(예: "5분 호흡법", "따뜻한 차 한잔")를 추천받기를, so that 감정에 즉시 대응할 수 있다 | P0 |
| US-15 | As a 사용자, I want 셀프케어 카드에 "도움됨/아님" 피드백을 주기를, so that 추천 정확도가 점진적으로 개선된다 | P0 |
| US-16 | As a 유료 사용자, I want 하루 무제한으로 셀프케어 카드를 받기를, so that 필요할 때마다 행동 제안을 받을 수 있다 | P1 |
| US-17 | As a 유료 사용자, I want 과거에 "도움됨" 표시한 행동 카드 목록을 보기를, so that 효과적인 셀프케어를 반복할 수 있다 | P1 |

### Epic 5: 설정 & 프로필

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-18 | As a 사용자, I want 감정 기록 알림 시간을 설정하기를, so that 매일 일정한 시간에 기록 습관을 만들 수 있다 | P0 |
| US-19 | As a 사용자, I want 앱 테마(라이트/다크)를 설정하기를, so that 선호하는 화면 모드로 사용할 수 있다 | P1 |
| US-20 | As a 사용자, I want 개인정보처리방침 및 이용약관을 확인하기를, so that 데이터 처리 방식을 투명하게 확인할 수 있다 | P0 |
| US-21 | As a 사용자, I want 계정을 탈퇴하고 모든 데이터를 삭제하기를, so that 더 이상 사용하지 않을 때 개인정보를 완전히 제거할 수 있다 | P0 |

### Epic 6: 결제 & 구독

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-22 | As a 무료 사용자, I want 프리미엄 기능을 7일간 무료 체험하기를, so that 유료 가치를 직접 경험한 후 결제를 결정할 수 있다 | P0 |
| US-23 | As a 사용자, I want 월간(3,900원) 또는 연간(29,900원) 구독을 선택하기를, so that 예산에 맞는 플랜을 고를 수 있다 | P0 |
| US-24 | As a 유료 사용자, I want 구독 상태를 확인하고 해지하기를, so that 구독을 자유롭게 관리할 수 있다 | P0 |

### Epic 7: 공유 & 데이터

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-25 | As a 사용자, I want 주간 감정 리포트를 카카오톡/인스타그램에 이미지로 공유하기를, so that 친구들과 감정 패턴을 나눌 수 있다 | P1 |
| US-26 | As a 유료 사용자, I want 감정 데이터를 PDF로 내보내기를, so that 상담사에게 공유하거나 개인 기록으로 보관할 수 있다 | P2 |

---

## 5. Functional Requirements

### 5-1. 기능 명세 테이블

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-01 | 소셜 로그인 (카카오/구글/애플) | P0 | OAuth 토큰 | Supabase 세션 | 3개 소셜 필수 지원 | 무료 |
| FR-02 | 온보딩 플로우 | P0 | 사용자 선택 | 온보딩 완료 상태 | 3단계 이내 | 무료 |
| FR-03 | 감정 태그 선택 기록 | P0 | 감정 태그 1~3개 | emotion_log 레코드 | 태그 30~40종, 최소 1개 필수 | 무료 |
| FR-04 | 활동 태그 연결 | P0 | 활동 태그 0~5개 | emotion_log 업데이트 | 사전 정의 15~20종 + 커스텀 | 무료 |
| FR-05 | 한줄 메모 | P0 | 텍스트 (최대 100자) | emotion_log 업데이트 | 선택사항, 100자 제한 | 무료 |
| FR-06 | 감정 강도 선택 | P1 | 강도 1~5 | emotion_log 업데이트 | 기본값 3 | 무료 |
| FR-07 | 캘린더 뷰 조회 | P0 | 월/연도 | 날짜별 감정 요약 | 월 단위 페이지네이션 | 무료 |
| FR-08 | 기록 상세 조회/수정/삭제 | P0 | log_id | 기록 상세 | 본인 기록만 | 무료 |
| FR-09 | 주간 감정 요약 리포트 | P0 | 주간 데이터 | 요약 카드 (상위 감정 3개, 감정 분포 차트) | 최소 3일 기록 필요 | 무료 (기본) |
| FR-10 | 월간 상세 패턴 분석 리포트 | P0 | 월간 데이터 | 감정-활동-시간 상관관계, 인사이트 문구 | 최소 14일 기록 필요 | **유료** |
| FR-11 | 셀프케어 행동 카드 추천 | P0 | 현재 감정 태그 | 행동 카드 1~3장 | 무료: 3개/일, 유료: 무제한 | 무료/유료 차등 |
| FR-12 | 행동 카드 피드백 (도움됨/아님) | P0 | card_id + 피드백 | feedback 레코드 | 동일 카드 1회만 | 무료 |
| FR-13 | 감정-활동 상관관계 인사이트 | P1 | 전체 기록 | 상관관계 차트/문구 | 최소 30일 기록 필요 | **유료** |
| FR-14 | 기록 알림 설정 | P0 | 시간, 반복 요일 | 푸시 알림 스케줄 | 최대 3개 알림 | 무료 |
| FR-15 | 7일 무료 체험 | P0 | 구독 시작 | 체험 상태 | 계정당 1회 | 무료 |
| FR-16 | 월간/연간 구독 결제 | P0 | 결제 정보 | 구독 상태 | iOS/Android IAP | 유료 |
| FR-17 | 구독 상태 확인/해지 | P0 | - | 구독 정보 | 앱스토어 연동 | 유료 |
| FR-18 | 리포트 이미지 공유 | P1 | 리포트 데이터 | 공유용 이미지 | 카카오톡/인스타그램 | 무료 |
| FR-19 | 데이터 PDF 내보내기 | P2 | 기간 선택 | PDF 파일 | 최대 12개월 | **유료** |
| FR-20 | 개인정보처리방침/이용약관 확인 | P0 | 메뉴 탭 | WebView 표시 | 외부 호스팅 URL 필요 | 무료 |
| FR-21 | 계정 탈퇴/데이터 삭제 | P0 | 확인 입력 | 계정·데이터 완전 삭제 | 2단계 확인 | 무료 |
| FR-22 | 효과적 셀프케어 히스토리 | P1 | - | "도움됨" 표시 카드 목록 | 유료 사용자 전용 | **유료** |
| FR-23 | 분기별 감정 트렌드 | P2 | 분기 데이터 | 장기 트렌드 차트 | 최소 60일 기록 | **유료** |
| FR-24 | 테마 설정 (라이트/다크) | P1 | 테마 선택 | 앱 테마 변경 | 시스템 설정 연동 | 무료 |

### 5-2. P0 기능 수용 기준 (Acceptance Criteria)

#### FR-01: 소셜 로그인

| AC ID | 수용 기준 |
|-------|----------|
| AC-01-1 | 카카오 로그인 버튼 탭 시 카카오 OAuth 화면이 2초 이내에 표시된다 |
| AC-01-2 | 구글 로그인 버튼 탭 시 구글 OAuth 화면이 2초 이내에 표시된다 |
| AC-01-3 | 애플 로그인 버튼 탭 시 애플 Sign-in 시트가 표시된다 (iOS만) |
| AC-01-4 | OAuth 인증 성공 시 Supabase 세션이 생성되고 홈 화면으로 이동한다 |
| AC-01-5 | OAuth 인증 실패 시 에러 메시지("로그인에 실패했습니다. 다시 시도해주세요.")가 표시된다 |
| AC-01-6 | 최초 로그인 시 사용자 프로필 레코드가 자동 생성된다 |

#### FR-02: 온보딩 플로우

| AC ID | 수용 기준 |
|-------|----------|
| AC-02-1 | 최초 로그인 사용자에게만 온보딩 화면이 표시된다 |
| AC-02-2 | 온보딩은 3단계(앱 소개/감정 어휘 미리보기/알림 시간 설정)로 구성된다 |
| AC-02-3 | 각 단계에서 "건너뛰기" 버튼으로 전체 온보딩을 스킵할 수 있다 |
| AC-02-4 | 온보딩 완료(또는 스킵) 시 has_completed_onboarding 플래그가 true로 저장된다 |

#### FR-03: 감정 태그 선택 기록

| AC ID | 수용 기준 |
|-------|----------|
| AC-03-1 | 기록 화면에 30~40종의 한국어 감정 태그가 카테고리별로 그룹화되어 표시된다 |
| AC-03-2 | 감정 태그를 1~3개 선택할 수 있으며, 3개 초과 선택 시 "최대 3개까지 선택 가능합니다" 메시지가 표시된다 |
| AC-03-3 | 감정 태그 0개 상태에서 저장 버튼이 비활성화된다 |
| AC-03-4 | 감정 태그 1개 이상 선택 후 저장 시 1초 이내에 서버 응답이 완료된다 |
| AC-03-5 | 오프라인 상태에서 저장 시 로컬에 저장되고, 네트워크 복구 시 자동 동기화된다 |

#### FR-04: 활동 태그 연결

| AC ID | 수용 기준 |
|-------|----------|
| AC-04-1 | 사전 정의된 활동 태그(출근, 회의, 운동, 식사, 대화, 수면, 독서, 쇼핑, 여행 등) 15~20종이 표시된다 |
| AC-04-2 | 활동 태그를 0~5개 선택할 수 있다 |
| AC-04-3 | "직접 입력" 옵션으로 커스텀 활동 태그를 추가할 수 있다 (최대 20자) |
| AC-04-4 | 커스텀 태그는 사용자별로 저장되어 이후 기록 시 재사용 가능하다 |

#### FR-05: 한줄 메모

| AC ID | 수용 기준 |
|-------|----------|
| AC-05-1 | 메모 입력 필드는 선택사항이며, 비워두고 저장할 수 있다 |
| AC-05-2 | 100자 초과 입력 시 더 이상 입력되지 않고 글자 수 카운터가 빨간색으로 변한다 |

#### FR-07: 캘린더 뷰 조회

| AC ID | 수용 기준 |
|-------|----------|
| AC-07-1 | 홈 화면에서 월간 캘린더 뷰가 표시되며, 기록된 날짜에 대표 감정 색상 마커가 표시된다 |
| AC-07-2 | 특정 날짜 탭 시 해당 날짜의 모든 감정 기록 목록이 하단에 표시된다 |
| AC-07-3 | 좌우 스와이프로 이전/다음 월로 이동할 수 있다 |
| AC-07-4 | 캘린더 뷰 로딩이 500ms 이내에 완료된다 |

#### FR-08: 기록 상세 조회/수정/삭제

| AC ID | 수용 기준 |
|-------|----------|
| AC-08-1 | 기록 항목 탭 시 상세 화면(감정 태그, 활동 태그, 메모, 기록 시간)이 표시된다 |
| AC-08-2 | 수정 버튼으로 감정 태그, 활동 태그, 메모를 편집할 수 있다 |
| AC-08-3 | 삭제 시 "정말 삭제하시겠습니까?" 확인 다이얼로그가 표시되고, 확인 후 삭제된다 |

#### FR-09: 주간 감정 요약 리포트

| AC ID | 수용 기준 |
|-------|----------|
| AC-09-1 | 해당 주 3일 이상 기록 시 주간 요약 리포트가 자동 생성된다 |
| AC-09-2 | 리포트에 상위 감정 3개, 감정 분포 비율 차트, 기록 일수가 포함된다 |
| AC-09-3 | 리포트는 매주 월요일 오전 9시에 푸시 알림으로 안내된다 |
| AC-09-4 | 리포트 화면 로딩이 2초 이내에 완료된다 |

#### FR-10: 월간 상세 패턴 분석 리포트

| AC ID | 수용 기준 |
|-------|----------|
| AC-10-1 | 해당 월 14일 이상 기록 시 월간 패턴 분석 리포트가 생성된다 |
| AC-10-2 | 리포트에 감정-요일-시간대 히트맵, 활동-감정 상관관계 테이블, 인사이트 문구 3~5개가 포함된다 |
| AC-10-3 | 인사이트 문구는 자연어 형태로 제공된다 (예: "운동한 날은 긍정 감정이 2.1배 높습니다") |
| AC-10-4 | 무료 사용자가 접근 시 "프리미엄 가입" 유도 화면이 표시된다 |
| AC-10-5 | 리포트 생성이 5초 이내에 완료된다 |

#### FR-11: 셀프케어 행동 카드 추천

| AC ID | 수용 기준 |
|-------|----------|
| AC-11-1 | 감정 기록 완료 직후 현재 감정에 매핑된 셀프케어 행동 카드 1~3장이 표시된다 |
| AC-11-2 | 행동 카드에 제목, 소요 시간(예: "3분"), 간단한 설명이 포함된다 |
| AC-11-3 | 무료 사용자는 하루 3장까지, 유료 사용자는 무제한으로 카드를 받을 수 있다 |
| AC-11-4 | 무료 사용자가 일일 한도 초과 시 "오늘의 무료 카드를 모두 사용했습니다" 메시지와 프리미엄 유도가 표시된다 |

#### FR-12: 행동 카드 피드백

| AC ID | 수용 기준 |
|-------|----------|
| AC-12-1 | 행동 카드 하단에 "도움됨 👍" / "아님 👎" 버튼이 표시된다 |
| AC-12-2 | 피드백 제출 시 1초 이내에 서버에 저장되고 "피드백이 반영되었습니다" 토스트가 표시된다 |
| AC-12-3 | 동일 카드에 대해 피드백은 1회만 가능하며, 이미 피드백한 카드는 버튼이 비활성화된다 |

#### FR-14: 기록 알림 설정

| AC ID | 수용 기준 |
|-------|----------|
| AC-14-1 | 설정 화면에서 알림 시간(시:분)과 반복 요일을 선택할 수 있다 |
| AC-14-2 | 최대 3개의 알림을 등록할 수 있다 |
| AC-14-3 | 설정된 시간에 "오늘 기분은 어떠세요?" 푸시 알림이 발송된다 |
| AC-14-4 | 알림 탭 시 앱이 열리며 감정 기록 화면으로 바로 이동한다 |

#### FR-15: 7일 무료 체험

| AC ID | 수용 기준 |
|-------|----------|
| AC-15-1 | 무료 체험 시작 시 결제 정보 입력 없이 즉시 프리미엄 기능이 활성화된다 |
| AC-15-2 | 체험 기간 동안 앱 내에 남은 체험 일수가 표시된다 |
| AC-15-3 | 7일 경과 후 자동으로 무료 플랜으로 전환되며, 유료 기능 접근 시 구독 유도 화면이 표시된다 |
| AC-15-4 | 동일 계정으로 무료 체험은 1회만 가능하다 |

#### FR-16: 월간/연간 구독 결제

| AC ID | 수용 기준 |
|-------|----------|
| AC-16-1 | 구독 화면에 월간(3,900원)과 연간(29,900원, 36% 할인) 플랜이 표시된다 |
| AC-16-2 | 플랜 선택 시 iOS App Store / Google Play 결제 시트가 표시된다 |
| AC-16-3 | 결제 성공 시 2초 이내에 프리미엄 기능이 활성화되고 "구독이 완료되었습니다" 메시지가 표시된다 |
| AC-16-4 | 결제 실패 시 에러 메시지와 재시도 옵션이 표시된다 |

#### FR-17: 구독 상태 확인/해지

| AC ID | 수용 기준 |
|-------|----------|
| AC-17-1 | 설정 > 구독 관리 화면에서 현재 구독 플랜, 다음 결제일, 구독 시작일이 표시된다 |
| AC-17-2 | "구독 관리" 버튼 탭 시 각 OS의 구독 관리 화면(App Store/Play Store)으로 이동한다 |

#### FR-20: 개인정보처리방침/이용약관

| AC ID | 수용 기준 |
|-------|----------|
| AC-20-1 | 설정 화면에서 개인정보처리방침과 이용약관 링크를 탭하면 웹뷰로 전문이 표시된다 |

#### FR-21: 계정 탈퇴/데이터 삭제

| AC ID | 수용 기준 |
|-------|----------|
| AC-21-1 | 설정 > 계정 탈퇴 시 "모든 데이터가 삭제됩니다" 경고 메시지가 표시된다 |
| AC-21-2 | "탈퇴하기" 입력 확인 후 계정과 모든 데이터가 30초 이내에 삭제된다 |
| AC-21-3 | 삭제 완료 후 로그인 화면으로 이동한다 |

---

## 6. Non-functional Requirements

### 6-1. 성능

| 항목 | 기준 |
|------|------|
| 감정 기록 저장 응답 시간 | 1초 이내 (오프라인 시 즉시 로컬 저장) |
| 캘린더 뷰 로딩 | 500ms 이내 |
| 리포트 생성 | 주간 2초, 월간 5초 이내 |
| 앱 콜드 스타트 | 3초 이내 |
| 앱 크기 | 50MB 이하 (다운로드 기준) |

### 6-2. 보안

| 항목 | 기준 |
|------|------|
| 데이터 전송 | TLS 1.2+ 필수 |
| 인증 | Supabase Auth + RLS로 사용자별 데이터 격리 |
| 민감 데이터 | 감정 기록은 사용자 본인만 접근 가능 (RLS 정책) |
| 비밀번호 | 소셜 로그인 전용, 비밀번호 미저장 |
| 계정 삭제 | GDPR/개인정보보호법 준수, 요청 시 모든 데이터 완전 삭제 |
| API Key | 서버 사이드(Edge Function) 또는 환경변수로 관리, 클라이언트 코드에 노출 금지 |

### 6-3. 접근성

| 항목 | 기준 |
|------|------|
| 최소 지원 OS | iOS 15+, Android 10+ |
| 언어 | 한국어 단일 (MVP) |
| 다크 모드 | 시스템 설정 연동 + 수동 전환 |
| 폰트 크기 | 시스템 Dynamic Type 지원 |

### 6-4. 확장성

| 항목 | 기준 |
|------|------|
| MAU 목표 | 출시 1년 내 5만 명 지원 |
| 데이터 증가 | 사용자당 일 평균 2건 × 365일 × 5만 명 = 연 3,650만 건 처리 |
| 수평 확장 | Supabase 매니지드 인프라로 자동 확장 |
| 향후 확장 | LLM API 연동을 위한 Edge Function 구조 선설계 |

---

## 7. Technical Architecture

### 7-1. 기술 스택

| 레이어 | 기술 | 버전/사양 | 선정 사유 |
|--------|------|----------|----------|
| **프레임워크** | Expo Managed Workflow | SDK 52+ | project-init 고정 스택. EAS Build/Submit으로 1인 개발 CI/CD 최적화 |
| **언어** | TypeScript | strict mode | project-init 고정 스택. 컴파일 타임 타입 안전성 |
| **라우팅** | Expo Router | v4+ (파일 기반) | project-init 고정 스택. 파일 기반 라우팅으로 화면 관리 단순화 |
| **UI** | React Native Paper | v5+ | project-init 고정 스택. Material Design 3 기반, 다크 모드 네이티브 지원 |
| **상태 관리** | Zustand | v5+ | project-init 고정 스택. 보일러플레이트 최소화, 미들웨어로 persist 지원 |
| **백엔드** | Supabase | PostgreSQL 15+ | project-init 고정 스택. Auth/RLS/Edge Functions/Realtime 통합 |
| **로컬 KV** | react-native-mmkv | v3+ | project-init 고정 스택. JSI 기반 초고속 KV 저장소 |
| **로컬 DB** | op-sqlite | 최신 안정 버전 | project-init 고정 스택. 오프라인 감정 기록 큐 + 캘린더 캐시용 |
| **인증** | Kakao OAuth, Google OAuth, Apple Auth | - | 조건부 의존성. 한국 시장 주요 3대 소셜 로그인 |
| **알림** | expo-notifications | - | 조건부 의존성. 감정 기록 리마인더 + 주간 리포트 알림 |
| **분석** | Aptabase | - | 조건부 의존성. 프라이버시 우선 분석, Firebase 대비 config plugin 복잡성 낮음 |
| **결제** | RevenueCat | - | 조건부 의존성 테이블 포함. iOS/Android IAP 통합 관리, 1인 개발자에게 최적 |
| **차트** | Victory Native (Skia 기반) | - | 조건부 의존성. 감정 분포/히트맵/트렌드 차트에 고성능 렌더링 필요 |
| **캘린더** | react-native-calendars | - | 조건부 의존성. 월간 캘린더 뷰 + 날짜별 감정 마커 |
| **애니메이션** | Lottie | - | 조건부 의존성. 온보딩/셀프케어 카드 마이크로 인터랙션 |
| **빌드** | EAS Build + EAS Submit | - | Expo 공식 빌드/배포 파이프라인 |

> **참고**: RevenueCat은 project-init 조건부 의존성 매핑에 포함되어 있으나, react-native-iap 대비 구독 관리(영수증 검증, 크로스 플랫폼 구독 상태, 무료 체험 관리)가 내장되어 1인 개발에 적합하다.

### 7-2. 시스템 구조도

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client (React Native / Expo)              │
│                                                                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────────┐ │
│  │  Expo    │  │  Zustand  │  │  op-sqlite│  │  react-native-  │ │
│  │  Router  │  │  Stores   │  │  (오프라인│  │  mmkv (KV)      │ │
│  │  (라우팅)│  │  (상태)   │  │   큐/캐시)│  │  (설정/토큰)    │ │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └───────┬──────────┘ │
│       │             │             │                 │            │
│  ┌────┴─────────────┴─────────────┴─────────────────┴──────────┐ │
│  │                    Service Layer                              │ │
│  │  ┌─────────────┐  ┌──────────────┐  ┌────────────────────┐  │ │
│  │  │ Auth Service │  │ Sync Service  │  │ Notification Svc   │  │ │
│  │  │ (OAuth)      │  │ (오프라인→   │  │ (expo-notifications│  │ │
│  │  │              │  │  서버 동기화) │  │  로컬 스케줄)      │  │ │
│  │  └──────────────┘  └──────────────┘  └────────────────────┘  │ │
│  │  ┌─────────────┐  ┌──────────────┐  ┌────────────────────┐  │ │
│  │  │ IAP Service  │  │ Report Svc   │  │ Analytics Svc      │  │ │
│  │  │ (RevenueCat) │  │ (리포트 생성)│  │ (Aptabase)         │  │ │
│  │  └──────────────┘  └──────────────┘  └────────────────────┘  │ │
│  └──────────────────────────────────────────────────────────────┘ │
└──────────────────────────┬───────────────────────────────────────┘
                           │ HTTPS (TLS 1.2+)
                           ▼
┌──────────────────────────────────────────────────────────────────┐
│                     Supabase Platform                             │
│                                                                   │
│  ┌────────────────┐  ┌─────────────────┐  ┌───────────────────┐  │
│  │  Supabase Auth  │  │  PostgREST      │  │  Edge Functions   │  │
│  │  (OAuth 프록시) │  │  (자동 REST API)│  │  (Deno Runtime)   │  │
│  │                 │  │                 │  │                   │  │
│  │  - Kakao OAuth  │  │  - CRUD 자동    │  │  - 주간 리포트    │  │
│  │  - Google OAuth │  │  - RLS 적용     │  │  - 월간 패턴 분석 │  │
│  │  - Apple Auth   │  │                 │  │  - 셀프케어 추천  │  │
│  │                 │  │                 │  │  - 계정 삭제      │  │
│  └────────┬───────┘  └────────┬────────┘  └──────────┬────────┘  │
│           │                   │                       │           │
│  ┌────────┴───────────────────┴───────────────────────┴────────┐  │
│  │                   PostgreSQL 15+                             │  │
│  │                                                              │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌───────────────┐  │  │
│  │  │ profiles │ │emotion_  │ │selfcare_ │ │subscriptions  │  │  │
│  │  │          │ │logs      │ │cards     │ │               │  │  │
│  │  └──────────┘ └──────────┘ └──────────┘ └───────────────┘  │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌───────────────┐  │  │
│  │  │emotion_  │ │activity_ │ │card_     │ │notification_  │  │  │
│  │  │tags      │ │tags      │ │feedbacks │ │settings       │  │  │
│  │  └──────────┘ └──────────┘ └──────────┘ └───────────────┘  │  │
│  │                                                              │  │
│  │  RLS: 모든 테이블에 user_id = auth.uid() 정책 적용          │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐   │
│  │  pg_cron (Supabase 확장)                                   │   │
│  │  - 매주 월요일 09:00 KST: 주간 리포트 생성 트리거          │   │
│  │  - 매월 1일 09:00 KST: 월간 리포트 생성 트리거             │   │
│  └────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────┘

외부 서비스:
  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
  │  RevenueCat   │  │  Expo Push    │  │  Aptabase    │
  │  (구독 관리)  │  │  (푸시 알림)  │  │  (앱 분석)   │
  └──────────────┘  └──────────────┘  └──────────────┘
```

### 7-3. 오프라인 우선 설계

#### 7-3-1. 로컬 저장소 선택 및 근거

| 저장소 | 역할 | 근거 |
|--------|------|------|
| **react-native-mmkv** | 사용자 설정, 인증 토큰, 온보딩 상태, 테마, 구독 상태 캐시 | JSI 기반 초고속(0.03ms read). key-value 데이터에 최적. 암호화 지원으로 토큰 안전 저장 |
| **op-sqlite** | 오프라인 감정 기록 큐(sync_queue 테이블), 캘린더 뷰 캐시(emotion_logs 로컬 복제) | 구조화된 데이터(감정 기록, 활동 태그)를 SQL로 관리. 오프라인 큐의 FIFO 처리와 상태 관리에 적합 |

#### 7-3-2. 저장소별 역할 분담

| 데이터 | 저장소 | 동기화 방향 | 비고 |
|--------|--------|-----------|------|
| 인증 토큰 (access/refresh) | MMKV | 서버→로컬 | Supabase Auth가 자동 관리, MMKV에 캐시 |
| 온보딩 완료 플래그 | MMKV | 서버→로컬 | 서버 profiles.has_completed_onboarding 동기화 |
| 테마 설정 | MMKV | 로컬 only | 서버 동기화 불필요 |
| 알림 설정 | MMKV | 양방향 | 서버에도 저장하여 재설치 시 복원 |
| 구독 상태 캐시 | MMKV | 서버→로컬 | RevenueCat SDK가 자체 캐시 관리, MMKV에 플래그 캐시 |
| 감정 기록 (오프라인 큐) | op-sqlite | 로컬→서버 | 오프라인 생성 후 서버 동기화 |
| 캘린더 뷰 캐시 | op-sqlite | 서버→로컬 | 월간 감정 요약을 로컬 캐시하여 500ms 로딩 달성 |
| 감정 태그 마스터 데이터 | op-sqlite | 서버→로컬 | 앱 시작 시 서버에서 최신 태그 목록 동기화 |
| 활동 태그 (시스템+커스텀) | op-sqlite | 양방향 | 커스텀 태그 오프라인 생성 가능 |

#### 7-3-3. 동기화 큐 로직

```
[오프라인 감정 기록 흐름]

1. 사용자가 감정 기록 저장
2. NetworkInfo 확인
   ├─ 온라인 → Supabase REST API 직접 저장 → 성공 시 로컬 캐시 업데이트
   └─ 오프라인 → op-sqlite sync_queue에 INSERT (status='pending')
3. 네트워크 복구 감지 (NetInfo 리스너)
4. SyncService 트리거
   ├─ sync_queue에서 status='pending' 레코드를 created_at ASC 순서로 조회
   ├─ 건별 Supabase REST API 호출
   │   ├─ 성공 → sync_queue status='synced', 서버 id를 로컬 레코드에 매핑
   │   └─ 실패 → retry_count++, 재시도 로직 진입
   └─ 전체 완료 후 캘린더 캐시 갱신
```

**재시도 전략:**

| 재시도 횟수 | 대기 시간 | 전략 |
|------------|----------|------|
| 1회 | 2초 | 즉시 재시도 |
| 2회 | 4초 | 지수 백오프 (2^retry × 1초) |
| 3회 | 8초 | 지수 백오프 |
| 4회 | 16초 | 지수 백오프 |
| 5회 (최대) | 30초 | 최대 대기 시간 cap |
| 5회 실패 후 | - | status='failed'로 변경, 다음 앱 포그라운드 전환 시 재시도 |

**최대 큐 크기**: 500건 (사용자당 일 평균 2건 × 250일분. 이를 초과하면 가장 오래된 synced 레코드를 삭제)

#### 7-3-4. 충돌 해결 정책

**Server Wins (서버 우선)** 정책을 채택한다.

| 시나리오 | 처리 |
|----------|------|
| 오프라인에서 생성한 기록이 서버에 없음 | 서버에 INSERT (충돌 없음) |
| 오프라인에서 수정한 기록이 서버에서도 수정됨 | 서버 버전 우선 (updated_at 비교) |
| 오프라인에서 삭제한 기록이 서버에 존재 | 서버에서 DELETE 실행 |
| 서버에서 삭제된 기록이 로컬에 존재 | 로컬에서 DELETE (동기화 시 감지) |

**근거**: 1인 사용자 앱이므로 다중 기기 동시 편집 가능성이 낮고, 서버를 single source of truth로 유지하는 것이 구현 복잡도를 최소화한다.

### 7-4. 핵심 설계 원칙

| # | 원칙 | 설명 |
|---|------|------|
| 1 | **Offline-First, Server-Authoritative** | 감정 기록은 오프라인에서도 즉시 저장되지만, 서버가 최종 권한. op-sqlite 동기화 큐로 일관성 보장 |
| 2 | **RLS-Only Security** | 모든 데이터 접근 제어를 PostgreSQL RLS로 구현. 별도 미들웨어 인증 레이어 없이 Supabase Auth + RLS만으로 보안 확보 |
| 3 | **SQL-First Analytics** | 감정 패턴 분석을 외부 AI/ML 서비스 없이 PostgreSQL 집계 함수(GROUP BY, 윈도우 함수, 크로스탭)로 구현. 외부 의존성 제로로 비용·복잡도 최소화 |
| 4 | **Edge Function for Business Logic** | 단순 CRUD는 PostgREST 자동 API 사용, 복합 비즈니스 로직(리포트 생성, 셀프케어 추천, 계정 삭제)은 Edge Function으로 분리. 관심사 분리 + 향후 LLM 연동 확장점 확보 |
| 5 | **Progressive Value Unlock** | 무료 기능(기록+주간 요약+일일 셀프케어 3장)으로 습관 형성 → 데이터 축적 → 유료 가치(상세 패턴 분석+무제한 셀프케어) 자연 전환. 기술 설계가 비즈니스 모델을 지원 |

### 7-5. DB 스키마

#### 7-5-1. 테이블 정의

```sql
-- ============================================================
-- 1. profiles: 사용자 프로필
-- ============================================================
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name TEXT,
  has_completed_onboarding BOOLEAN NOT NULL DEFAULT FALSE,
  preferred_reminder_time TIME,              -- 기본 알림 시간
  theme TEXT NOT NULL DEFAULT 'system'
    CHECK (theme IN ('light', 'dark', 'system')),
  free_trial_started_at TIMESTAMPTZ,         -- 무료 체험 시작일
  free_trial_ended BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_profiles_created_at ON public.profiles(created_at);

-- ============================================================
-- 2. emotion_tags: 감정 태그 마스터
-- ============================================================
CREATE TABLE public.emotion_tags (
  id SERIAL PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,                 -- 예: 'seorunham', 'dapdapham'
  label TEXT NOT NULL,                       -- 예: '서운함', '답답함'
  category TEXT NOT NULL
    CHECK (category IN ('positive', 'negative', 'neutral')),
  color TEXT NOT NULL,                       -- HEX 컬러 코드 (예: '#FF6B6B')
  display_order SMALLINT NOT NULL DEFAULT 0,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_emotion_tags_category ON public.emotion_tags(category);
CREATE INDEX idx_emotion_tags_active_order ON public.emotion_tags(is_active, display_order);

-- ============================================================
-- 3. activity_tags: 활동 태그 (시스템 + 커스텀)
-- ============================================================
CREATE TABLE public.activity_tags (
  id SERIAL PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,  -- NULL이면 시스템 태그
  label TEXT NOT NULL,                       -- 예: '출근', '회의', '운동'
  icon TEXT,                                 -- 아이콘 이름 (Material icon)
  is_system BOOLEAN NOT NULL DEFAULT FALSE,
  display_order SMALLINT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT uq_activity_tag_per_user UNIQUE (user_id, label)
);

CREATE INDEX idx_activity_tags_user ON public.activity_tags(user_id);
CREATE INDEX idx_activity_tags_system ON public.activity_tags(is_system);

-- ============================================================
-- 4. emotion_logs: 감정 기록 (핵심 테이블)
-- ============================================================
CREATE TABLE public.emotion_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  emotion_tag_ids INTEGER[] NOT NULL,        -- emotion_tags.id 배열 (1~3개)
  activity_tag_ids INTEGER[],                -- activity_tags.id 배열 (0~5개)
  intensity SMALLINT NOT NULL DEFAULT 3
    CHECK (intensity BETWEEN 1 AND 5),
  memo TEXT CHECK (char_length(memo) <= 100),
  recorded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),  -- 사용자가 기록한 시점
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT chk_emotion_tags_count
    CHECK (array_length(emotion_tag_ids, 1) BETWEEN 1 AND 3),
  CONSTRAINT chk_activity_tags_count
    CHECK (activity_tag_ids IS NULL OR array_length(activity_tag_ids, 1) <= 5)
);

CREATE INDEX idx_emotion_logs_user_recorded
  ON public.emotion_logs(user_id, recorded_at DESC);
CREATE INDEX idx_emotion_logs_user_date
  ON public.emotion_logs(user_id, (recorded_at::date));
CREATE INDEX idx_emotion_logs_emotion_tags
  ON public.emotion_logs USING GIN(emotion_tag_ids);
CREATE INDEX idx_emotion_logs_activity_tags
  ON public.emotion_logs USING GIN(activity_tag_ids);

-- ============================================================
-- 5. selfcare_cards: 셀프케어 행동 카드 마스터
-- ============================================================
CREATE TABLE public.selfcare_cards (
  id SERIAL PRIMARY KEY,
  title TEXT NOT NULL,                       -- 예: '5분 호흡법'
  description TEXT NOT NULL,                 -- 간단한 설명
  duration_minutes SMALLINT,                 -- 소요 시간 (분)
  emotion_tag_ids INTEGER[] NOT NULL,        -- 매핑된 감정 태그 ID 배열
  category TEXT NOT NULL
    CHECK (category IN ('breathing', 'movement', 'mindfulness',
                        'social', 'creative', 'rest', 'other')),
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_selfcare_cards_emotion
  ON public.selfcare_cards USING GIN(emotion_tag_ids);
CREATE INDEX idx_selfcare_cards_active
  ON public.selfcare_cards(is_active);

-- ============================================================
-- 6. card_feedbacks: 행동 카드 피드백
-- ============================================================
CREATE TABLE public.card_feedbacks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  card_id INTEGER NOT NULL REFERENCES public.selfcare_cards(id) ON DELETE CASCADE,
  emotion_log_id UUID REFERENCES public.emotion_logs(id) ON DELETE SET NULL,
  is_helpful BOOLEAN NOT NULL,               -- true=도움됨, false=아님
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT uq_feedback_per_log UNIQUE (user_id, card_id, emotion_log_id)
);

CREATE INDEX idx_card_feedbacks_user ON public.card_feedbacks(user_id);
CREATE INDEX idx_card_feedbacks_card ON public.card_feedbacks(card_id);
CREATE INDEX idx_card_feedbacks_helpful
  ON public.card_feedbacks(user_id, is_helpful) WHERE is_helpful = TRUE;

-- ============================================================
-- 7. subscriptions: 구독 상태
-- ============================================================
CREATE TABLE public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  plan TEXT NOT NULL DEFAULT 'free'
    CHECK (plan IN ('free', 'trial', 'monthly', 'yearly')),
  revenuecat_customer_id TEXT,               -- RevenueCat 고객 ID
  started_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_subscriptions_user ON public.subscriptions(user_id);
CREATE INDEX idx_subscriptions_active ON public.subscriptions(is_active);

-- ============================================================
-- 8. notification_settings: 알림 설정
-- ============================================================
CREATE TABLE public.notification_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  reminder_time TIME NOT NULL,               -- 알림 시간 (HH:MM)
  days_of_week SMALLINT[] NOT NULL,          -- 요일 배열 [0=일, 1=월, ..., 6=토]
  is_enabled BOOLEAN NOT NULL DEFAULT TRUE,
  expo_push_token TEXT,                      -- Expo Push Token
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_notification_settings_user
  ON public.notification_settings(user_id);

-- notification_settings 최대 3개 제한 트리거
CREATE OR REPLACE FUNCTION public.check_max_notification_settings()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF (SELECT COUNT(*) FROM public.notification_settings WHERE user_id = NEW.user_id) >= 3 THEN
    RAISE EXCEPTION 'Maximum 3 notification settings per user' USING ERRCODE = 'check_violation';
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_check_max_notifications
  BEFORE INSERT ON public.notification_settings
  FOR EACH ROW
  EXECUTE FUNCTION public.check_max_notification_settings();

-- ============================================================
-- 9. daily_card_usage: 일일 무료 셀프케어 카드 사용 추적
-- ============================================================
CREATE TABLE public.daily_card_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  usage_date DATE NOT NULL DEFAULT CURRENT_DATE,
  card_count SMALLINT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT uq_daily_usage UNIQUE (user_id, usage_date)
);

CREATE INDEX idx_daily_card_usage_user_date
  ON public.daily_card_usage(user_id, usage_date);
```

#### 7-5-2. 자동 updated_at 트리거

```sql
-- 모든 테이블의 updated_at 자동 갱신
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.emotion_logs
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.subscriptions
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.notification_settings
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
```

#### 7-5-3. 신규 사용자 프로필 자동 생성 트리거

```sql
-- Auth 가입 시 profiles + subscriptions 자동 생성
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name', '사용자')
  );

  INSERT INTO public.subscriptions (user_id, plan, is_active)
  VALUES (NEW.id, 'free', FALSE);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

#### 7-5-4. RLS 정책 (CRUD 권한 매트릭스)

| 테이블 | SELECT | INSERT | UPDATE | DELETE | 정책 |
|--------|--------|--------|--------|--------|------|
| profiles | `auth.uid() = id` | 트리거로 자동 생성 | `auth.uid() = id` | 계정 삭제 Edge Function | 본인만 |
| emotion_tags | `TRUE` (모든 인증 사용자) | admin only | admin only | admin only | 마스터 데이터 읽기 전용 |
| activity_tags | `is_system = TRUE OR user_id = auth.uid()` | `auth.uid() = user_id` | `auth.uid() = user_id` | `auth.uid() = user_id` | 시스템 태그는 모두 읽기, 커스텀은 본인만 |
| emotion_logs | `auth.uid() = user_id` | `auth.uid() = user_id` | `auth.uid() = user_id` | `auth.uid() = user_id` | 본인만 CRUD |
| selfcare_cards | `TRUE` (모든 인증 사용자) | admin only | admin only | admin only | 마스터 데이터 읽기 전용 |
| card_feedbacks | `auth.uid() = user_id` | `auth.uid() = user_id` | 불가 | `auth.uid() = user_id` | 본인만. 수정 불가 (재생성) |
| subscriptions | `auth.uid() = user_id` | 트리거로 자동 생성 | Edge Function (service_role) | 계정 삭제 Edge Function | 읽기만 본인, 변경은 서버 |
| notification_settings | `auth.uid() = user_id` | `auth.uid() = user_id` | `auth.uid() = user_id` | `auth.uid() = user_id` | 본인만 CRUD |
| daily_card_usage | `auth.uid() = user_id` | Edge Function (service_role) | Edge Function (service_role) | 불가 | 서버에서만 변경 |

```sql
-- RLS 활성화
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.emotion_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.activity_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.emotion_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.selfcare_cards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.card_feedbacks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_card_usage ENABLE ROW LEVEL SECURITY;

-- profiles
CREATE POLICY "profiles_select_own" ON public.profiles
  FOR SELECT USING (auth.uid() = id);
CREATE POLICY "profiles_update_own" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

-- emotion_tags (마스터 데이터, 인증 사용자 읽기 전용)
CREATE POLICY "emotion_tags_select_all" ON public.emotion_tags
  FOR SELECT USING (auth.role() = 'authenticated');

-- activity_tags
CREATE POLICY "activity_tags_select" ON public.activity_tags
  FOR SELECT USING (is_system = TRUE OR user_id = auth.uid());
CREATE POLICY "activity_tags_insert" ON public.activity_tags
  FOR INSERT WITH CHECK (auth.uid() = user_id AND is_system = FALSE);
CREATE POLICY "activity_tags_update" ON public.activity_tags
  FOR UPDATE USING (auth.uid() = user_id AND is_system = FALSE);
CREATE POLICY "activity_tags_delete" ON public.activity_tags
  FOR DELETE USING (auth.uid() = user_id AND is_system = FALSE);

-- emotion_logs
CREATE POLICY "emotion_logs_select_own" ON public.emotion_logs
  FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "emotion_logs_insert_own" ON public.emotion_logs
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "emotion_logs_update_own" ON public.emotion_logs
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "emotion_logs_delete_own" ON public.emotion_logs
  FOR DELETE USING (auth.uid() = user_id);

-- selfcare_cards (마스터 데이터, 인증 사용자 읽기 전용)
CREATE POLICY "selfcare_cards_select_all" ON public.selfcare_cards
  FOR SELECT USING (auth.role() = 'authenticated');

-- card_feedbacks
CREATE POLICY "card_feedbacks_select_own" ON public.card_feedbacks
  FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "card_feedbacks_insert_own" ON public.card_feedbacks
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "card_feedbacks_delete_own" ON public.card_feedbacks
  FOR DELETE USING (auth.uid() = user_id);

-- subscriptions
CREATE POLICY "subscriptions_select_own" ON public.subscriptions
  FOR SELECT USING (auth.uid() = user_id);

-- notification_settings
CREATE POLICY "notification_settings_select_own" ON public.notification_settings
  FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "notification_settings_insert_own" ON public.notification_settings
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "notification_settings_update_own" ON public.notification_settings
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "notification_settings_delete_own" ON public.notification_settings
  FOR DELETE USING (auth.uid() = user_id);

-- daily_card_usage
CREATE POLICY "daily_card_usage_select_own" ON public.daily_card_usage
  FOR SELECT USING (auth.uid() = user_id);
```

#### 7-5-5. 핵심 DB Function (RPC) — 완전한 SQL 본문

```sql
-- ============================================================
-- RPC 1: get_weekly_summary — 주간 감정 요약 리포트
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_weekly_summary(
  p_user_id UUID,
  p_week_start DATE
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_week_end DATE := p_week_start + INTERVAL '6 days';
  v_result JSONB;
  v_log_days INTEGER;
BEGIN
  -- 기록 일수 확인
  SELECT COUNT(DISTINCT recorded_at::date)
  INTO v_log_days
  FROM public.emotion_logs
  WHERE user_id = p_user_id
    AND recorded_at::date BETWEEN p_week_start AND v_week_end;

  -- 최소 3일 기록 필요
  IF v_log_days < 3 THEN
    RETURN jsonb_build_object(
      'status', 'insufficient_data',
      'log_days', v_log_days,
      'required_days', 3
    );
  END IF;

  SELECT jsonb_build_object(
    'status', 'ok',
    'week_start', p_week_start,
    'week_end', v_week_end,
    'log_days', v_log_days,
    'total_logs', (
      SELECT COUNT(*)
      FROM public.emotion_logs
      WHERE user_id = p_user_id
        AND recorded_at::date BETWEEN p_week_start AND v_week_end
    ),
    'top_emotions', (
      SELECT jsonb_agg(row_to_json(t))
      FROM (
        SELECT et.id, et.label, et.color, et.category, sub.cnt
        FROM (
          SELECT UNNEST(emotion_tag_ids) AS tag_id, COUNT(*) AS cnt
          FROM public.emotion_logs
          WHERE user_id = p_user_id
            AND recorded_at::date BETWEEN p_week_start AND v_week_end
          GROUP BY tag_id
          ORDER BY cnt DESC
          LIMIT 3
        ) sub
        JOIN public.emotion_tags et ON et.id = sub.tag_id
      ) t
    ),
    'emotion_distribution', (
      SELECT jsonb_agg(row_to_json(t))
      FROM (
        SELECT et.category,
               COUNT(*) AS cnt,
               ROUND(COUNT(*) * 100.0 / NULLIF(SUM(COUNT(*)) OVER(), 0), 1) AS pct
        FROM public.emotion_logs el
        CROSS JOIN LATERAL UNNEST(el.emotion_tag_ids) AS tag_id
        JOIN public.emotion_tags et ON et.id = tag_id
        WHERE el.user_id = p_user_id
          AND el.recorded_at::date BETWEEN p_week_start AND v_week_end
        GROUP BY et.category
        ORDER BY cnt DESC
      ) t
    ),
    'avg_intensity', (
      SELECT ROUND(AVG(intensity), 1)
      FROM public.emotion_logs
      WHERE user_id = p_user_id
        AND recorded_at::date BETWEEN p_week_start AND v_week_end
    )
  ) INTO v_result;

  RETURN v_result;
END;
$$;

-- ============================================================
-- RPC 2: get_monthly_pattern_report — 월간 패턴 분석 리포트
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_monthly_pattern_report(
  p_user_id UUID,
  p_year INTEGER,
  p_month INTEGER
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_month_start DATE := make_date(p_year, p_month, 1);
  v_month_end DATE := (v_month_start + INTERVAL '1 month' - INTERVAL '1 day')::date;
  v_log_days INTEGER;
  v_result JSONB;
BEGIN
  -- 기록 일수 확인
  SELECT COUNT(DISTINCT recorded_at::date)
  INTO v_log_days
  FROM public.emotion_logs
  WHERE user_id = p_user_id
    AND recorded_at::date BETWEEN v_month_start AND v_month_end;

  IF v_log_days < 14 THEN
    RETURN jsonb_build_object(
      'status', 'insufficient_data',
      'log_days', v_log_days,
      'required_days', 14
    );
  END IF;

  SELECT jsonb_build_object(
    'status', 'ok',
    'month', p_month,
    'year', p_year,
    'log_days', v_log_days,
    -- 요일별 감정 분포 (히트맵 데이터)
    'day_of_week_distribution', (
      SELECT jsonb_agg(row_to_json(t))
      FROM (
        SELECT EXTRACT(DOW FROM el.recorded_at) AS dow,
               et.label,
               et.color,
               COUNT(*) AS cnt
        FROM public.emotion_logs el
        CROSS JOIN LATERAL UNNEST(el.emotion_tag_ids) AS tag_id
        JOIN public.emotion_tags et ON et.id = tag_id
        WHERE el.user_id = p_user_id
          AND el.recorded_at::date BETWEEN v_month_start AND v_month_end
        GROUP BY dow, et.label, et.color
        ORDER BY dow, cnt DESC
      ) t
    ),
    -- 시간대별 감정 분포 (히트맵 데이터)
    'hour_distribution', (
      SELECT jsonb_agg(row_to_json(t))
      FROM (
        SELECT
          CASE
            WHEN EXTRACT(HOUR FROM el.recorded_at) BETWEEN 6 AND 11 THEN 'morning'
            WHEN EXTRACT(HOUR FROM el.recorded_at) BETWEEN 12 AND 17 THEN 'afternoon'
            WHEN EXTRACT(HOUR FROM el.recorded_at) BETWEEN 18 AND 22 THEN 'evening'
            ELSE 'night'
          END AS time_slot,
          et.category,
          COUNT(*) AS cnt
        FROM public.emotion_logs el
        CROSS JOIN LATERAL UNNEST(el.emotion_tag_ids) AS tag_id
        JOIN public.emotion_tags et ON et.id = tag_id
        WHERE el.user_id = p_user_id
          AND el.recorded_at::date BETWEEN v_month_start AND v_month_end
        GROUP BY time_slot, et.category
        ORDER BY time_slot
      ) t
    ),
    -- 활동-감정 상관관계
    'activity_emotion_correlation', (
      SELECT jsonb_agg(row_to_json(t))
      FROM (
        SELECT at_tag.label AS activity,
               et.category AS emotion_category,
               COUNT(*) AS cnt,
               ROUND(AVG(el.intensity), 1) AS avg_intensity
        FROM public.emotion_logs el
        CROSS JOIN LATERAL UNNEST(el.activity_tag_ids) AS act_id
        CROSS JOIN LATERAL UNNEST(el.emotion_tag_ids) AS emo_id
        JOIN public.activity_tags at_tag ON at_tag.id = act_id
        JOIN public.emotion_tags et ON et.id = emo_id
        WHERE el.user_id = p_user_id
          AND el.recorded_at::date BETWEEN v_month_start AND v_month_end
        GROUP BY at_tag.label, et.category
        HAVING COUNT(*) >= 2
        ORDER BY cnt DESC
      ) t
    ),
    -- 감정 트렌드 (일별)
    'daily_trend', (
      SELECT jsonb_agg(row_to_json(t))
      FROM (
        SELECT el.recorded_at::date AS log_date,
               et.category,
               COUNT(*) AS cnt
        FROM public.emotion_logs el
        CROSS JOIN LATERAL UNNEST(el.emotion_tag_ids) AS tag_id
        JOIN public.emotion_tags et ON et.id = tag_id
        WHERE el.user_id = p_user_id
          AND el.recorded_at::date BETWEEN v_month_start AND v_month_end
        GROUP BY log_date, et.category
        ORDER BY log_date
      ) t
    )
  ) INTO v_result;

  RETURN v_result;
END;
$$;

-- ============================================================
-- RPC 3: get_selfcare_recommendations — 셀프케어 행동 카드 추천
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_selfcare_recommendations(
  p_user_id UUID,
  p_emotion_tag_ids INTEGER[],
  p_limit INTEGER DEFAULT 3
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT jsonb_agg(row_to_json(t))
  INTO v_result
  FROM (
    SELECT sc.id, sc.title, sc.description, sc.duration_minutes, sc.category,
           -- 이 사용자의 과거 피드백 기반 점수 가중
           COALESCE(
             (SELECT AVG(CASE WHEN cf.is_helpful THEN 1.0 ELSE -0.5 END)
              FROM public.card_feedbacks cf
              WHERE cf.card_id = sc.id AND cf.user_id = p_user_id),
             0
           ) AS user_score,
           -- 전체 사용자 긍정 피드백 비율
           COALESCE(
             (SELECT ROUND(
               SUM(CASE WHEN cf.is_helpful THEN 1 ELSE 0 END) * 100.0
               / NULLIF(COUNT(*), 0), 1
             )
              FROM public.card_feedbacks cf
              WHERE cf.card_id = sc.id),
             50
           ) AS global_helpful_pct
    FROM public.selfcare_cards sc
    WHERE sc.is_active = TRUE
      AND sc.emotion_tag_ids && p_emotion_tag_ids  -- 배열 겹침 연산자
      -- 이 사용자가 최근 24시간 내 이미 추천받은 카드 제외
      AND sc.id NOT IN (
        SELECT cf.card_id
        FROM public.card_feedbacks cf
        WHERE cf.user_id = p_user_id
          AND cf.created_at > NOW() - INTERVAL '24 hours'
      )
    ORDER BY user_score DESC, global_helpful_pct DESC, RANDOM()
    LIMIT p_limit
  ) t;

  RETURN COALESCE(v_result, '[]'::jsonb);
END;
$$;

-- ============================================================
-- RPC 4: get_calendar_summary — 캘린더 뷰용 월간 요약
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_calendar_summary(
  p_user_id UUID,
  p_year INTEGER,
  p_month INTEGER
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN (
    SELECT jsonb_agg(row_to_json(t))
    FROM (
      SELECT
        el.recorded_at::date AS log_date,
        COUNT(*) AS log_count,
        -- 그 날의 대표 감정 (가장 빈번한 태그의 색상)
        (
          SELECT et.color
          FROM public.emotion_logs el2
          CROSS JOIN LATERAL UNNEST(el2.emotion_tag_ids) AS tag_id
          JOIN public.emotion_tags et ON et.id = tag_id
          WHERE el2.user_id = p_user_id
            AND el2.recorded_at::date = el.recorded_at::date
          GROUP BY et.color
          ORDER BY COUNT(*) DESC
          LIMIT 1
        ) AS primary_color
      FROM public.emotion_logs el
      WHERE el.user_id = p_user_id
        AND EXTRACT(YEAR FROM el.recorded_at) = p_year
        AND EXTRACT(MONTH FROM el.recorded_at) = p_month
      GROUP BY el.recorded_at::date
      ORDER BY log_date
    ) t
  );
END;
$$;

-- ============================================================
-- RPC 5: delete_user_account — 계정 삭제 (모든 데이터 제거)
-- ============================================================
CREATE OR REPLACE FUNCTION public.delete_user_account(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- FK CASCADE로 대부분 자동 삭제되지만 명시적으로 순서 보장
  DELETE FROM public.daily_card_usage WHERE user_id = p_user_id;
  DELETE FROM public.card_feedbacks WHERE user_id = p_user_id;
  DELETE FROM public.notification_settings WHERE user_id = p_user_id;
  DELETE FROM public.emotion_logs WHERE user_id = p_user_id;
  DELETE FROM public.activity_tags WHERE user_id = p_user_id;
  DELETE FROM public.subscriptions WHERE user_id = p_user_id;
  DELETE FROM public.profiles WHERE id = p_user_id;

  -- auth.users 삭제는 Edge Function에서 supabase admin API로 처리
  RETURN jsonb_build_object('status', 'ok', 'deleted_user_id', p_user_id);
END;
$$;

-- ============================================================
-- RPC 6: increment_daily_card_usage — 일일 카드 사용량 증가
-- ============================================================
CREATE OR REPLACE FUNCTION public.increment_daily_card_usage(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_count SMALLINT;
  v_is_premium BOOLEAN;
BEGIN
  -- 구독 상태 확인
  SELECT is_active INTO v_is_premium
  FROM public.subscriptions
  WHERE user_id = p_user_id;

  -- 유료 사용자는 제한 없음
  IF v_is_premium THEN
    RETURN jsonb_build_object('status', 'ok', 'remaining', -1);
  END IF;

  -- 현재 사용량 사전 체크 (INSERT 전에 한도 확인)
  SELECT card_count INTO v_current_count
  FROM public.daily_card_usage
  WHERE user_id = p_user_id AND usage_date = CURRENT_DATE;

  IF v_current_count IS NOT NULL AND v_current_count >= 3 THEN
    RETURN jsonb_build_object('status', 'limit_exceeded', 'used', v_current_count, 'limit', 3);
  END IF;

  -- 오늘 사용량 UPSERT (한도 미초과 확인 후 실행)
  INSERT INTO public.daily_card_usage (user_id, usage_date, card_count)
  VALUES (p_user_id, CURRENT_DATE, 1)
  ON CONFLICT (user_id, usage_date)
  DO UPDATE SET card_count = daily_card_usage.card_count + 1
  RETURNING card_count INTO v_current_count;

  RETURN jsonb_build_object('status', 'ok', 'used', v_current_count, 'remaining', 3 - v_current_count);
END;
$$;
```

### 7-6. API 설계

#### 7-6-1. Supabase REST vs Edge Function 선택 기준

| 기준 | Supabase REST (PostgREST) | Edge Function |
|------|--------------------------|---------------|
| 단순 CRUD | O | X |
| RLS로 권한 제어 충분 | O | X |
| 복합 비즈니스 로직 | X | O |
| 여러 테이블 트랜잭션 | X | O |
| 외부 API 호출 필요 | X | O |
| 응답 가공/변환 | X | O |

#### 7-6-2. 엔드포인트 목록

**A. Supabase REST API (PostgREST 자동 생성)**

| 경로 | 메서드 | 설명 | 구현 방식 |
|------|--------|------|----------|
| `/rest/v1/profiles` | GET | 내 프로필 조회 | PostgREST + RLS |
| `/rest/v1/profiles` | PATCH | 프로필 수정 (온보딩 완료, 테마 등) | PostgREST + RLS |
| `/rest/v1/emotion_tags` | GET | 감정 태그 마스터 목록 | PostgREST + RLS |
| `/rest/v1/activity_tags` | GET | 활동 태그 목록 (시스템+커스텀) | PostgREST + RLS |
| `/rest/v1/activity_tags` | POST | 커스텀 활동 태그 추가 | PostgREST + RLS |
| `/rest/v1/activity_tags` | DELETE | 커스텀 활동 태그 삭제 | PostgREST + RLS |
| `/rest/v1/emotion_logs` | GET | 감정 기록 조회 (날짜 필터) | PostgREST + RLS |
| `/rest/v1/emotion_logs` | POST | 감정 기록 생성 | PostgREST + RLS |
| `/rest/v1/emotion_logs` | PATCH | 감정 기록 수정 | PostgREST + RLS |
| `/rest/v1/emotion_logs` | DELETE | 감정 기록 삭제 | PostgREST + RLS |
| `/rest/v1/selfcare_cards` | GET | 셀프케어 카드 마스터 목록 | PostgREST + RLS |
| `/rest/v1/card_feedbacks` | GET | 내 피드백 목록 | PostgREST + RLS |
| `/rest/v1/card_feedbacks` | POST | 피드백 제출 | PostgREST + RLS |
| `/rest/v1/subscriptions` | GET | 내 구독 상태 | PostgREST + RLS |
| `/rest/v1/notification_settings` | GET | 알림 설정 조회 | PostgREST + RLS |
| `/rest/v1/notification_settings` | POST | 알림 설정 생성 | PostgREST + RLS |
| `/rest/v1/notification_settings` | PATCH | 알림 설정 수정 | PostgREST + RLS |
| `/rest/v1/notification_settings` | DELETE | 알림 설정 삭제 | PostgREST + RLS |

**B. Supabase RPC (DB Function 호출)**

| 경로 | 메서드 | 설명 | 구현 방식 |
|------|--------|------|----------|
| `/rest/v1/rpc/get_weekly_summary` | POST | 주간 감정 요약 리포트 | DB Function |
| `/rest/v1/rpc/get_calendar_summary` | POST | 캘린더 뷰 월간 요약 | DB Function |
| `/rest/v1/rpc/get_selfcare_recommendations` | POST | 셀프케어 카드 추천 | DB Function |
| `/rest/v1/rpc/increment_daily_card_usage` | POST | 일일 카드 사용량 증가 | DB Function |

**C. Edge Functions**

| 경로 | 메서드 | 설명 | 구현 방식 |
|------|--------|------|----------|
| `/functions/v1/monthly-report` | POST | 월간 패턴 분석 리포트 생성 | Edge Function |
| `/functions/v1/delete-account` | POST | 계정 삭제 (데이터 + auth.users) | Edge Function |
| `/functions/v1/subscription-webhook` | POST | RevenueCat 웹훅 (구독 상태 업데이트) | Edge Function |
| `/functions/v1/start-free-trial` | POST | 7일 무료 체험 시작 | Edge Function |

#### 7-6-3. TypeScript 인터페이스

```typescript
// ============================================================
// 공통 타입
// ============================================================
interface ApiResponse<T> {
  status: 'ok' | 'error' | 'insufficient_data' | 'limit_exceeded';
  data?: T;
  message?: string;
}

// ============================================================
// 감정 기록 (emotion_logs)
// ============================================================
interface CreateEmotionLogRequest {
  emotion_tag_ids: number[];      // 1~3개
  activity_tag_ids?: number[];    // 0~5개
  intensity?: number;             // 1~5, default 3
  memo?: string;                  // 최대 100자
  recorded_at?: string;           // ISO 8601, default: now
}

interface EmotionLog {
  id: string;                     // UUID
  user_id: string;
  emotion_tag_ids: number[];
  activity_tag_ids: number[] | null;
  intensity: number;
  memo: string | null;
  recorded_at: string;
  created_at: string;
  updated_at: string;
}

interface UpdateEmotionLogRequest {
  emotion_tag_ids?: number[];
  activity_tag_ids?: number[];
  intensity?: number;
  memo?: string;
}

// ============================================================
// 감정 태그 (emotion_tags)
// ============================================================
interface EmotionTag {
  id: number;
  slug: string;
  label: string;                  // 예: '서운함'
  category: 'positive' | 'negative' | 'neutral';
  color: string;                  // HEX
  display_order: number;
}

// ============================================================
// 활동 태그 (activity_tags)
// ============================================================
interface ActivityTag {
  id: number;
  user_id: string | null;
  label: string;
  icon: string | null;
  is_system: boolean;
  display_order: number;
}

interface CreateActivityTagRequest {
  label: string;                  // 최대 20자
  icon?: string;
}

// ============================================================
// 주간 요약 리포트
// ============================================================
interface WeeklySummaryRequest {
  p_user_id: string;
  p_week_start: string;           // YYYY-MM-DD (해당 주 월요일)
}

interface WeeklySummaryResponse {
  status: 'ok' | 'insufficient_data';
  week_start: string;
  week_end: string;
  log_days: number;
  total_logs: number;
  top_emotions: Array<{
    id: number;
    label: string;
    color: string;
    category: string;
    cnt: number;
  }>;
  emotion_distribution: Array<{
    category: string;
    cnt: number;
    pct: number;
  }>;
  avg_intensity: number;
  // insufficient_data인 경우
  required_days?: number;
}

// ============================================================
// 월간 패턴 분석 리포트 (Edge Function)
// ============================================================
interface MonthlyReportRequest {
  year: number;
  month: number;
}

interface MonthlyReportResponse {
  status: 'ok' | 'insufficient_data' | 'not_premium';
  month: number;
  year: number;
  log_days: number;
  day_of_week_distribution: Array<{
    dow: number;
    label: string;
    color: string;
    cnt: number;
  }>;
  hour_distribution: Array<{
    time_slot: 'morning' | 'afternoon' | 'evening' | 'night';
    category: string;
    cnt: number;
  }>;
  activity_emotion_correlation: Array<{
    activity: string;
    emotion_category: string;
    cnt: number;
    avg_intensity: number;
  }>;
  daily_trend: Array<{
    log_date: string;
    category: string;
    cnt: number;
  }>;
  insights: string[];             // Edge Function에서 생성한 인사이트 문구
}

// ============================================================
// 셀프케어 카드 추천
// ============================================================
interface SelfcareRecommendRequest {
  p_user_id: string;
  p_emotion_tag_ids: number[];
  p_limit?: number;               // default 3
}

interface SelfcareCard {
  id: number;
  title: string;
  description: string;
  duration_minutes: number | null;
  category: string;
  user_score: number;
  global_helpful_pct: number;
}

// ============================================================
// 카드 피드백
// ============================================================
interface CreateFeedbackRequest {
  card_id: number;
  emotion_log_id?: string;
  is_helpful: boolean;
}

interface CardFeedback {
  id: string;
  user_id: string;
  card_id: number;
  emotion_log_id: string | null;
  is_helpful: boolean;
  created_at: string;
}

// ============================================================
// 캘린더 요약
// ============================================================
interface CalendarSummaryRequest {
  p_user_id: string;
  p_year: number;
  p_month: number;
}

interface CalendarDay {
  log_date: string;
  log_count: number;
  primary_color: string;          // 대표 감정 색상
}

// ============================================================
// 구독 관련
// ============================================================
interface Subscription {
  id: string;
  user_id: string;
  plan: 'free' | 'trial' | 'monthly' | 'yearly';
  revenuecat_customer_id: string | null;
  started_at: string | null;
  expires_at: string | null;
  is_active: boolean;
}

interface StartFreeTrialRequest {}  // 인증 헤더에서 user_id 추출

interface StartFreeTrialResponse {
  status: 'ok' | 'already_used';
  trial_ends_at?: string;
}

// ============================================================
// 계정 삭제
// ============================================================
interface DeleteAccountRequest {
  confirmation: string;           // "탈퇴하기" 입력 확인
}

interface DeleteAccountResponse {
  status: 'ok' | 'error';
  message: string;
}

// ============================================================
// 알림 설정
// ============================================================
interface NotificationSetting {
  id: string;
  user_id: string;
  reminder_time: string;          // HH:MM
  days_of_week: number[];         // [0=일, 1=월, ..., 6=토]
  is_enabled: boolean;
  expo_push_token: string | null;
}

interface CreateNotificationSettingRequest {
  reminder_time: string;
  days_of_week: number[];
  expo_push_token?: string;
}
```

#### 7-6-4. Edge Function 비즈니스 로직 상세

**A. monthly-report (월간 패턴 분석 리포트)**

```
1. 인증 확인: Authorization 헤더에서 JWT 추출 → user_id 획득
2. 구독 상태 확인: subscriptions 테이블에서 is_active 확인
   └─ 비활성 → { status: 'not_premium' } 반환
3. DB Function 호출: get_monthly_pattern_report(user_id, year, month)
4. 인사이트 문구 생성 (규칙 기반):
   a. activity_emotion_correlation에서 긍정 감정 비율이 가장 높은 활동 추출
      → "{활동}한 날은 긍정 감정이 {배수}배 높습니다"
   b. day_of_week_distribution에서 부정 감정이 가장 높은 요일 추출
      → "{요일}에 부정 감정이 집중됩니다"
   c. hour_distribution에서 시간대별 패턴 추출
      → "{시간대}에 {감정}이 가장 많이 기록되었습니다"
   d. daily_trend에서 추세 변화 감지
      → "이번 달 후반으로 갈수록 긍정 감정이 증가했습니다"
   e. 최대 5개 인사이트 생성
5. 결과 조합하여 MonthlyReportResponse 반환
```

**B. delete-account (계정 삭제)**

```
1. 인증 확인: Authorization 헤더에서 JWT 추출 → user_id 획득
2. 확인 문자열 검증: body.confirmation === "탈퇴하기"
   └─ 불일치 → { status: 'error', message: '확인 문자열이 일치하지 않습니다' }
3. RevenueCat 구독 해지: (구독 활성 시) RevenueCat API로 구독 취소
4. DB Function 호출: delete_user_account(user_id) — 모든 사용자 데이터 삭제
5. Supabase Admin API 호출: auth.admin.deleteUser(user_id) — auth.users 레코드 삭제
6. 결과 반환: { status: 'ok', message: '계정이 삭제되었습니다' }
```

**C. subscription-webhook (RevenueCat 웹훅)**

```
1. 웹훅 서명 검증: RevenueCat 공유 비밀로 HMAC 검증
   └─ 실패 → 401 반환
2. 이벤트 유형 분기:
   a. INITIAL_PURCHASE / RENEWAL:
      - subscriptions 테이블 UPDATE: plan='monthly'/'yearly', is_active=TRUE, expires_at 갱신
   b. CANCELLATION / EXPIRATION:
      - subscriptions 테이블 UPDATE: is_active=FALSE
   c. PRODUCT_CHANGE:
      - plan 변경 반영
3. 200 OK 반환
```

**D. start-free-trial (무료 체험 시작)**

```
1. 인증 확인: Authorization 헤더에서 JWT → user_id
2. 기존 체험 여부 확인: profiles.free_trial_ended === TRUE
   └─ TRUE → { status: 'already_used' }
3. profiles UPDATE: free_trial_started_at = NOW()
4. subscriptions UPDATE: plan = 'trial', is_active = TRUE, expires_at = NOW() + 7일
5. 결과 반환: { status: 'ok', trial_ends_at: expires_at }
```

### 7-7. 상태 관리 구조

| Store | 역할 | 주요 상태 필드 | persist |
|-------|------|--------------|---------|
| **useAuthStore** | 인증 상태 관리 | `session: Session \| null`, `user: User \| null`, `isLoading: boolean`, `isAuthenticated: boolean` | MMKV (토큰) |
| **useProfileStore** | 사용자 프로필 | `profile: Profile \| null`, `hasCompletedOnboarding: boolean`, `theme: 'light' \| 'dark' \| 'system'` | MMKV |
| **useEmotionLogStore** | 감정 기록 CRUD | `todayLogs: EmotionLog[]`, `selectedDate: string`, `isCreating: boolean`, `draftLog: Partial<CreateEmotionLogRequest>` | 없음 (서버 기준) |
| **useCalendarStore** | 캘린더 뷰 상태 | `currentMonth: { year: number, month: number }`, `calendarDays: CalendarDay[]`, `isLoading: boolean` | op-sqlite (캐시) |
| **useReportStore** | 리포트 데이터 | `weeklyReport: WeeklySummaryResponse \| null`, `monthlyReport: MonthlyReportResponse \| null`, `isGenerating: boolean` | 없음 |
| **useSelfcareStore** | 셀프케어 카드 | `recommendations: SelfcareCard[]`, `dailyUsage: { used: number, remaining: number }`, `isLoading: boolean` | 없음 |
| **useSubscriptionStore** | 구독 상태 | `subscription: Subscription \| null`, `isPremium: boolean`, `trialDaysLeft: number \| null` | MMKV (캐시) |
| **useNotificationStore** | 알림 설정 | `settings: NotificationSetting[]`, `pushToken: string \| null` | MMKV |
| **useSyncStore** | 오프라인 동기화 | `pendingCount: number`, `isSyncing: boolean`, `lastSyncedAt: string \| null` | MMKV (상태만) |

### 7-8. 기능-테이블-API 매핑표

| FR ID | 기능 | 테이블 | API | 비고 |
|-------|------|--------|-----|------|
| FR-01 | 소셜 로그인 | auth.users, profiles, subscriptions | Supabase Auth OAuth + handle_new_user 트리거 | 카카오/구글/애플 |
| FR-02 | 온보딩 플로우 | profiles | PATCH /rest/v1/profiles | has_completed_onboarding 업데이트 |
| FR-03 | 감정 태그 선택 기록 | emotion_logs, emotion_tags | POST /rest/v1/emotion_logs | emotion_tag_ids 배열 |
| FR-04 | 활동 태그 연결 | emotion_logs, activity_tags | POST /rest/v1/emotion_logs + GET/POST /rest/v1/activity_tags | activity_tag_ids 배열 |
| FR-05 | 한줄 메모 | emotion_logs | POST /rest/v1/emotion_logs | memo 필드 |
| FR-07 | 캘린더 뷰 조회 | emotion_logs, emotion_tags | RPC get_calendar_summary | 월별 요약 |
| FR-08 | 기록 상세 조회/수정/삭제 | emotion_logs | GET/PATCH/DELETE /rest/v1/emotion_logs | id 필터 |
| FR-09 | 주간 감정 요약 리포트 | emotion_logs, emotion_tags | RPC get_weekly_summary | 무료 |
| FR-10 | 월간 패턴 분석 리포트 | emotion_logs, emotion_tags, activity_tags, subscriptions | Edge Function monthly-report → RPC get_monthly_pattern_report | 유료 확인 포함 |
| FR-11 | 셀프케어 행동 카드 추천 | selfcare_cards, card_feedbacks, daily_card_usage | RPC get_selfcare_recommendations + RPC increment_daily_card_usage | 일일 한도 체크 |
| FR-12 | 행동 카드 피드백 | card_feedbacks | POST /rest/v1/card_feedbacks | UNIQUE 제약으로 중복 방지 |
| FR-14 | 기록 알림 설정 | notification_settings | CRUD /rest/v1/notification_settings + expo-notifications 로컬 스케줄 | 최대 3개 앱 레벨 제한 |
| FR-15 | 7일 무료 체험 | profiles, subscriptions | Edge Function start-free-trial | 계정당 1회 |
| FR-16 | 월간/연간 구독 결제 | subscriptions | RevenueCat SDK + Edge Function subscription-webhook | IAP → 웹훅으로 DB 업데이트 |
| FR-17 | 구독 상태 확인/해지 | subscriptions | GET /rest/v1/subscriptions + OS 구독 관리 딥링크 | RevenueCat SDK로 상태 동기화 |
| FR-20 | 개인정보처리방침/이용약관 확인 | - | WebView (외부 호스팅 URL) | 앱스토어 필수 법률 요건, DB/API 불필요 |
| FR-21 | 계정 탈퇴/데이터 삭제 | 전체 테이블 | Edge Function delete-account → RPC delete_user_account + admin API | 전체 데이터 삭제 |

### 7-9. 자체 점검 결과

| # | 점검 항목 | 결과 | 근거 |
|---|----------|------|------|
| 1 | 모든 P0 기능에 번호 형식(AC-XX-X)의 수용 기준이 존재하는가 | **충족** | 섹션 5-2: FR-01~FR-05, FR-07~FR-12, FR-14~FR-17, FR-20, FR-21 모두 AC 작성됨 (총 17개 P0) |
| 2 | P0 기능별 DB 테이블·API 매핑이 매핑표에 존재하는가 | **충족** | 섹션 7-8: 17개 P0 기능 모두 매핑 완료 (FR-20은 DB/API 불필요, WebView) |
| 3 | DB 스키마의 FK 관계가 기능 간 데이터 흐름과 일치하는가 | **충족** | emotion_logs → emotion_tags/activity_tags (배열 참조), card_feedbacks → selfcare_cards (FK), 모든 사용자 테이블 → auth.users (FK CASCADE) |
| 4 | API 엔드포인트가 각 P0 수용 기준을 충족할 수 있는가 | **충족** | AC-03-4(1초 응답): PostgREST 직접 INSERT. AC-07-4(500ms 캘린더): get_calendar_summary RPC + op-sqlite 캐시. AC-10-5(5초 리포트): Edge Function |
| 5 | 핵심 API의 TypeScript 인터페이스(요청/응답)가 존재하는가 | **충족** | 섹션 7-6-3: 전체 20개 인터페이스 작성 |
| 6 | 핵심 DB Function의 SQL 본문이 완성되었는가 | **충족** | 섹션 7-5-5: 6개 RPC 전체 SQL 본문 작성. v1.2에서 RPC 1·2의 implicit/explicit JOIN 혼합을 `CROSS JOIN LATERAL UNNEST`로 통일 (RPC 4와 동일 패턴) |
| 7 | 오프라인 저장소·동기화·충돌 해결 정책이 명시되었는가 | **충족** | 섹션 7-3: 저장소 선택(MMKV+op-sqlite), 역할 분담, 동기화 큐(재시도 5회/지수 백오프), Server Wins 충돌 해결 |
| 8 | 네비게이션 구조 트리 + 핵심 화면 UI 설명이 존재하는가 | **충족** | 섹션 8-1: Expo Router 파일 기반 네비게이션 트리, 섹션 8-2: 9개 핵심 화면 UI 명세 |
| 9 | User Story가 모든 기능 영역을 커버하는가 | **충족** | 섹션 4: 7개 Epic(온보딩/인증, 감정기록, 리포트, 셀프케어, 설정, 결제, 공유) 26개 Story |

---

## 8. Screen Map & UI 명세

### 8-1. 네비게이션 구조 트리

```
app/ (Expo Router 파일 기반)
├── _layout.tsx                    ← Root Layout (테마 Provider, Auth 체크)
├── (auth)/                        ← Auth Stack (미인증 사용자)
│   ├── _layout.tsx
│   ├── login.tsx                  ← 로그인 화면 (소셜 로그인 3종)
│   └── onboarding.tsx             ← 온보딩 화면 (3단계 스와이프)
│
├── (tabs)/                        ← Main Tab Navigator (인증 사용자)
│   ├── _layout.tsx                ← Bottom Tab Bar (홈/기록/리포트/설정)
│   ├── index.tsx                  ← [홈] 캘린더 뷰 + 오늘 감정 요약
│   ├── record.tsx                 ← [기록] 감정 기록 화면
│   ├── report.tsx                 ← [리포트] 주간/월간 리포트
│   └── settings.tsx               ← [설정] 프로필/알림/구독/기타
│
├── log/
│   └── [id].tsx                   ← 기록 상세 (조회/수정/삭제)
│
├── selfcare/
│   └── index.tsx                  ← 셀프케어 카드 결과 (모달)
│
├── subscription/
│   └── index.tsx                  ← 구독/결제 화면
│
├── premium-wall.tsx               ← 프리미엄 유도 화면 (모달)
│
└── +not-found.tsx                 ← 404 화면
```

### 8-2. 핵심 화면별 UI 구성

#### 화면 1: 로그인 화면 `(auth)/login.tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 상단 (40%) | 앱 로고 + "마음날씨" 타이틀 + 한줄 설명 ("매일 10초, 나의 감정을 기록하세요") | 없음 |
| 중앙 (20%) | Lottie 애니메이션 (감정 날씨 일러스트) | 없음 |
| 하단 (40%) | [카카오로 시작하기] 버튼 (노란색, 최상단) → [구글로 시작하기] 버튼 → [Apple로 시작하기] 버튼 (iOS만) → 하단 텍스트: "시작하면 이용약관 및 개인정보처리방침에 동의합니다" | Supabase Auth OAuth |

#### 화면 2: 온보딩 화면 `(auth)/onboarding.tsx`

| 단계 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 1단계: 앱 소개 | 일러스트 + "감정을 기록하고, 패턴을 발견하고, 셀프케어를 시작하세요" + [다음] 버튼 | 없음 |
| 2단계: 감정 어휘 미리보기 | 감정 태그 칩 샘플 (서운함, 답답함, 뿌듯함 등 8~10개) + "한국어로만 표현할 수 있는 나의 감정" + [다음] 버튼 | GET emotion_tags |
| 3단계: 알림 설정 | 시간 피커 (기본값 21:00) + 요일 선택 (기본 월~금) + "매일 이 시간에 감정 기록을 알려드릴게요" + [시작하기] 버튼 | POST notification_settings, PATCH profiles |
| 공통 | 상단 진행 표시 바 (1/3, 2/3, 3/3) + 우측 상단 "건너뛰기" 텍스트 버튼 | - |

#### 화면 3: 홈 (캘린더 뷰) `(tabs)/index.tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 상단 바 | "마음날씨" 타이틀 + 동기화 상태 아이콘 (오프라인 시 구름 아이콘) | useSyncStore |
| 캘린더 (60%) | react-native-calendars 월간 뷰. 기록된 날짜에 대표 감정 색상 원형 마커. 좌우 스와이프로 월 이동. 오늘 날짜 강조 | RPC get_calendar_summary → useCalendarStore |
| 하단 리스트 (40%) | 선택한 날짜의 감정 기록 목록. 각 항목: 감정 태그 칩 + 시간 + 메모 미리보기. 빈 날짜: "아직 기록이 없어요" + [기록하기] CTA | GET emotion_logs (날짜 필터) |
| FAB | 우하단 + 버튼 "기록하기" → record 탭으로 이동 | - |

#### 화면 4: 감정 기록 `(tabs)/record.tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 상단 | "지금 기분이 어때요?" 타이틀 | - |
| 감정 태그 (40%) | 카테고리별 그룹 (긍정/부정/중립) + 각 그룹 내 감정 칩 (Chip 컴포넌트). 선택 시 색상 활성화 + 체크 아이콘. 선택 카운터 "1/3" 표시 | GET emotion_tags (캐시) |
| 활동 태그 (25%) | 접이식 섹션. 아이콘+라벨 그리드. 하단 "+ 직접 입력" 버튼 → 텍스트 입력 모달 | GET activity_tags |
| 메모 (15%) | TextInput (placeholder: "한줄 메모 (선택)") + 글자수 카운터 "0/100" | - |
| 하단 (20%) | [저장하기] 버튼 (Primary, 감정 1개 이상 시 활성화) + 저장 성공 시 셀프케어 카드 모달로 자동 전환 | POST emotion_logs → RPC get_selfcare_recommendations |

#### 화면 5: 셀프케어 카드 결과 `selfcare/index.tsx` (모달)

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 상단 | "이런 건 어때요?" 타이틀 + 닫기(X) 버튼 | - |
| 카드 영역 (70%) | 카드 1~3장 가로 스와이프. 각 카드: 제목 + 소요 시간 배지 ("3분") + 설명 텍스트 + 카테고리 아이콘 | useSelfcareStore.recommendations |
| 피드백 (15%) | 각 카드 하단: [도움됨] [아님] 버튼 쌍 | POST card_feedbacks |
| 하단 (15%) | 무료 사용자: "오늘 남은 카드: {n}장" + 한도 초과 시 "더 많은 제안을 원하시나요?" → 프리미엄 유도 | RPC increment_daily_card_usage |

#### 화면 6: 리포트 `(tabs)/report.tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 탭 바 | [주간] [월간] 세그먼트 탭 | - |
| **주간 탭** | | |
| 상위 감정 | TOP 3 감정 태그 칩 + 기록 횟수 | RPC get_weekly_summary → top_emotions |
| 감정 분포 | Victory Native 도넛 차트 (긍정/부정/중립 비율) | → emotion_distribution |
| 요약 통계 | 기록 일수, 총 기록 수, 평균 강도 | → log_days, total_logs, avg_intensity |
| **월간 탭 (유료)** | | |
| 감정 히트맵 | 요일×시간대 히트맵 그리드 (Victory Native) | Edge Function monthly-report → day_of_week/hour_distribution |
| 활동-감정 상관 | 가로 바 차트 (활동별 긍정/부정 비율) | → activity_emotion_correlation |
| 인사이트 카드 | 자연어 인사이트 3~5개 카드 리스트 | → insights |
| 비프리미엄 사용자 | 블러 처리 + "프리미엄으로 상세 분석 보기" CTA → premium-wall 모달 | useSubscriptionStore.isPremium |
| 공유 버튼 | 우상단 공유 아이콘 → 리포트 이미지 생성 → 공유 시트 | expo-sharing (P1) |

#### 화면 7: 설정 `(tabs)/settings.tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 프로필 섹션 | 사용자 이름 + 가입일 + 총 기록 수 | GET profiles + COUNT emotion_logs |
| 구독 관리 | 현재 플랜 배지 (무료/체험/월간/연간) + [구독 관리] → subscription 화면 or OS 관리 | GET subscriptions |
| 알림 설정 | 알림 목록 (최대 3개) + 각 항목: 시간/요일/활성 토글 + [알림 추가] 버튼 | CRUD notification_settings |
| 테마 | [라이트/다크/시스템] 세그먼트 | MMKV (로컬) |
| 기타 | 이용약관 → WebView, 개인정보처리방침 → WebView, 앱 버전 | - |
| 위험 영역 | [계정 탈퇴] 빨간색 텍스트 버튼 → 확인 다이얼로그 → "탈퇴하기" 입력 → Edge Function delete-account | Edge Function |

#### 화면 8: 구독/결제 `subscription/index.tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 상단 | "프리미엄으로 더 깊은 인사이트" 타이틀 + 가치 제안 3줄 | - |
| 혜택 목록 | 체크 리스트: 월간 상세 패턴 분석 / 무제한 셀프케어 카드 / 감정-활동 상관관계 / 데이터 내보내기 | - |
| 플랜 카드 | [월간 3,900원] 카드 + [연간 29,900원 (36% 할인)] 카드 (추천 배지) | - |
| 무료 체험 | 체험 미사용자: "7일 무료 체험 시작" CTA. 체험 중: "체험 {n}일 남음" | Edge Function start-free-trial |
| 결제 버튼 | [구독하기] → RevenueCat IAP 시트 | RevenueCat SDK |
| 하단 | "언제든 해지 가능합니다" + 이용약관/환불 정책 링크 | - |

#### 화면 9: 기록 상세 `log/[id].tsx`

| 영역 | UI 요소 | 데이터/API |
|------|---------|-----------|
| 상단 | 기록 시간 (예: "2026년 1월 31일 오후 3:24") + [수정] [삭제] 아이콘 버튼 | GET emotion_logs?id=eq.{id} |
| 감정 태그 | 선택된 감정 칩 표시 (색상 + 라벨) | emotion_tags 조인 |
| 활동 태그 | 선택된 활동 칩 표시 (아이콘 + 라벨) | activity_tags 조인 |
| 강도 | 1~5 스케일 시각화 (별 또는 바) | intensity 필드 |
| 메모 | 메모 텍스트 (있는 경우) | memo 필드 |
| 수정 모드 | 감정/활동/메모 편집 가능 → [저장] 버튼 | PATCH emotion_logs |
| 삭제 | 확인 다이얼로그 → DELETE | DELETE emotion_logs |

---

## 9. Competitive Differentiation

### 9-1. 차별화 전략 (경쟁분석 기반)

| 차별점 | 마음날씨 | 하루콩 | 무디 | 루빗 | 데일리오 |
|--------|---------|--------|------|------|---------|
| **한국어 감정 어휘 30~40종** | O (핵심) | X (범용 5종) | 부분 | X | X (번역) |
| **기록→분석→행동 완결 루프** | O | X (기록만) | 부분 (퀘스트) | X (습관 중심) | X (통계만) |
| **AI 감정 패턴 분석** | O (SQL 통계) | X | X (규칙 기반) | X (반응형 위로) | X |
| **개인화 셀프케어 행동 제안** | O (피드백 기반) | X | 부분 (1,200 모듈) | X | X |
| **월 3,900원 셀프케어** | O | 무료+테마 | ~5,000원/월 | ~4,300원/월 | $2.99/월 |

### 9-2. 핵심 차별화 메시지

> **"하루콩으로 기록하고 있다면, 마음날씨로 분석하세요"**

- 기존 감정 기록 앱 사용자의 "기록하고 끝" 불만을 직접 공략
- 경쟁자와 적대하지 않고, 진화된 상위 카테고리로 포지셔닝

### 9-3. 방어 가능한 해자 (Moat) 전략

| 단계 | 해자 | 설명 |
|------|------|------|
| 단기 (0~6개월) | 한국어 감정 분류 체계 선점 | "마음날씨 감정 체계"를 브랜드화. 30~40종 한국어 감정 어휘를 최초로 체계적 분류 |
| 중기 (6~12개월) | 누적 데이터 기반 개인화 | 3개월+ 데이터가 쌓인 사용자에게만 가능한 패턴 인사이트 = 이탈 비용 증가 |
| 장기 (12개월+) | 피드백 루프 최적화 | 사용자 피드백(도움됨/아님) 누적으로 셀프케어 추천 정확도 지속 개선. 데이터가 많을수록 추천이 좋아지는 선순환 |

### 9-4. 라일리 하루 대비 차별화 (경쟁분석 §2-3)

| 항목 | 라일리 하루 | 마음날씨 |
|------|-----------|---------|
| 핵심 가치 | AI 감정 분석 (기술 중심) | 셀프케어 행동 제안 (실용 중심) |
| 입력 방식 | 멀티모달 (글/사진/음성) | 10초 태그 선택 |
| AI 기술 | 자체 소형 LLM | SQL 통계 분석 (외부 AI 무의존) |
| 운영 비용 | LLM 추론 비용 발생 | 거의 0 (PostgreSQL 집계) |
| 차별점 | "분석해주는 AI" | "행동을 제안하는 코치" |

---

## 10. Monetization Strategy

### 10-1. 수익 모델: 프리미엄 구독 (Freemium)

| 구분 | 무료 | 프리미엄 |
|------|------|---------|
| 감정 기록 | 무제한 | 무제한 |
| 활동 태그 연결 | 무제한 | 무제한 |
| 한줄 메모 | 무제한 | 무제한 |
| 캘린더 뷰 | O | O |
| 주간 감정 요약 리포트 | O (기본) | O (기본) |
| 셀프케어 행동 카드 | **3장/일** | **무제한** |
| 월간 상세 패턴 분석 | X | **O** |
| 감정-활동 상관관계 인사이트 | X | **O** |
| 분기별 감정 트렌드 | X | **O** |
| 효과적 셀프케어 히스토리 | X | **O** |
| 데이터 PDF 내보내기 | X | **O** |

### 10-2. 가격 구조

| 플랜 | 가격 | 실질 월 단가 | 할인율 |
|------|------|------------|--------|
| 월간 구독 | 3,900원/월 | 3,900원 | - |
| 연간 구독 | 29,900원/년 | 2,492원 | 36% |
| 7일 무료 체험 | 0원 | - | 계정당 1회 |

**가격 설정 근거** (시장분석 §5):
- RevenueCat 2025: 건강&피트니스 앱 연간 구독 중앙값 $29.65/년 ≈ 39,000원 → 마음날씨 29,900원은 하단 포지셔닝
- 데일리오: $23.99/년 ≈ 32,000원 → 마음날씨는 데일리오 대비 약간 저렴
- 루빗: ~53,000원/년 → 마음날씨의 약 1.8배
- 마보: 27,000원/년 → 마음날씨와 유사 가격대

### 10-3. 전환 유도 전략

| 전략 | 설명 | 근거 |
|------|------|------|
| **7일 무료 체험** (결제 정보 없이) | 무료체험→유료 전환율 44.5% (건강&피트니스 중앙값, RevenueCat 2025) | 결제 정보 없이 시작하여 진입 장벽 최소화 |
| **습관 형성 후 전환** | 2~3주 무료 기록 후 데이터 축적 → "더 깊은 인사이트를 보시겠어요?" | 주 3회+ 사용자 갱신 가능성 4~5배 (RevenueCat 2025) |
| **월간 리포트 블러 처리** | 무료 사용자에게 월간 리포트 미리보기(블러) 제공 → 프리미엄 유도 | 무료→유료 가치 격차를 시각적으로 체감 |
| **연간 플랜 강조** | 구독 화면에서 연간 플랜에 "추천" 배지 + 36% 할인 강조 | 연간 유지율 33~60% vs 월간 갱신율 58~67% |

### 10-4. 수익 전망

| 시나리오 | MAU | 유료 전환율 | 유료 사용자 | 월 매출 | 연 매출 |
|---------|-----|-----------|-----------|--------|--------|
| 보수적 (1년차) | 30,000 | 3% | 900 | 350만 원 | 4,200만 원 |
| 중간 (2년차) | 100,000 | 5% | 5,000 | 1,950만 원 | 2.3억 원 |
| 낙관적 (3년차) | 300,000 | 6% | 18,000 | 7,020만 원 | 8.4억 원 |

※ 월간:연간 구독 비율 4:6 가정, 앱스토어 수수료(15%) 차감 전

---

## 11. Risk Matrix

| # | 리스크 | 유형 | 가능성 | 영향도 | 심각도 | 대응 방안 |
|---|--------|------|--------|--------|--------|----------|
| R1 | **하루콩의 AI 기능 추가** | 사업 | 높음 | 높음 | **Critical** | 한국어 감정 어휘 체계 깊이 + 행동 제안 차별화 선점. 하루콩은 글로벌 전략(해외 80%)으로 한국어 특화 가능성 낮음 |
| R2 | **블루시그넘 생태계 완성** (하루콩+무디+라임AI) | 사업 | 중간 | 높음 | **High** | 1인 개발의 민첩성으로 틈새 포지셔닝. "분석+행동 제안 통합"에 집중하여 생태계 분산의 약점 공략 |
| R3 | **감정 기록 앱 낮은 유료 전환율** (3~5%) | 사업 | 높음 | 중간 | **High** | 7일 무료 체험 + 월간 리포트 블러 전략으로 전환 유도. 연간 구독 강조로 LTV 극대화 |
| R4 | **라일리 하루와의 직접 경쟁** | 사업 | 중간 | 중간 | **Medium** | "분석 중심"(라일리 하루) vs "행동 제안 중심"(마음날씨)으로 포지셔닝 분리 |
| R5 | **ChatGPT/Gemini 범용 AI 대체** | 기술 | 낮음 | 중간 | **Medium** | 누적 데이터 기반 개인화 패턴 분석은 범용 AI가 대체 불가. 10초 기록의 편의성은 채팅 인터페이스와 다름 |
| R6 | **감정 기록 습관화 실패 (높은 이탈)** | 운영 | 높음 | 높음 | **Critical** | 10초 기록 + 푸시 리마인더 + 주간 리포트 보상감 + 셀프케어 카드 즉시 보상으로 습관 루프 강화 |
| R7 | **감정 데이터 개인정보 이슈** | 법률 | 낮음 | 높음 | **Medium** | Supabase RLS로 완전 격리, TLS 전송 암호화, GDPR/개인정보보호법 준수 계정 삭제 기능 |
| R8 | **Supabase 서비스 장애** | 기술 | 낮음 | 중간 | **Low** | 오프라인 우선 설계로 기록은 항상 가능. op-sqlite 큐로 복구 시 자동 동기화 |
| R9 | **앱스토어 심사 리젝** | 운영 | 중간 | 중간 | **Medium** | Apple 구독 가이드라인 준수 (무료 체험 명확 표시, 해지 경로 제공), 개인정보처리방침 사전 준비 |
| R10 | **RevenueCat 의존성** | 기술 | 낮음 | 중간 | **Low** | RevenueCat은 업계 표준 구독 인프라. 대안으로 react-native-iap 직접 구현 가능 (마이그레이션 용이) |

---

## 12. Assumptions & Constraints

### 12-1. 사업적 가정

| # | 가정 | 검증 방법 |
|---|------|----------|
| A1 | MZ세대 감정 관리 관심층 800만 명 중 마음날씨의 타겟(기록+분석+행동)에 관심 있는 비율이 5% 이상 | MVP 출시 후 다운로드 수 / ASO 노출 대비 전환율 측정 |
| A2 | "기록하고 끝" 불만이 유료 전환의 주요 동기가 될 것 | 유료 전환 사용자 대상 인앱 설문 |
| A3 | 월 3,900원 구독 가격이 심리적 허들을 넘지 않을 것 | A/B 테스트 (3,900원 vs 2,900원 vs 4,900원) |
| A4 | 7일 무료 체험이 유료 전환의 핵심 드라이버 | 무료체험 시작률 및 전환율 추적 |
| A5 | 한국어 감정 어휘 특화가 차별적 가치로 인식될 것 | 온보딩 완료율 + 첫 주 기록 빈도 비교 |

### 12-2. 외부 의존성

| 의존성 | 설명 | 리스크 |
|--------|------|--------|
| Supabase | 백엔드 전체 (DB, Auth, Edge Functions) | 서비스 장애 시 오프라인 모드로 대응 |
| RevenueCat | IAP 결제 관리, 구독 상태 관리 | 대안: react-native-iap 직접 구현 |
| Expo EAS | 빌드 및 배포 | 대안: 로컬 빌드 (Expo prebuild) |
| 카카오 Developer | OAuth 인증 | 카카오 API 정책 변경 리스크 |
| Apple/Google | 앱스토어 심사, IAP 수수료 (15~30%) | 수수료 변경 리스크 |

### 12-3. 기술 제약

| 제약 | 설명 |
|------|------|
| 1인 개발 | 모든 개발·디자인·운영을 혼자 수행. 기능 범위를 MVP로 엄격히 제한 |
| 3개월 MVP | 핵심 기능(기록+주간 리포트+셀프케어 카드+구독)만 포함. 월간 상세 리포트는 MVP 후반에 추가 |
| AI/ML 미사용 | MVP에서 외부 LLM API 호출 없음. 모든 분석은 PostgreSQL SQL 집계로 구현 |
| 한국어 단일 | MVP는 한국어만 지원. 다국어는 성공 후 확장 |
| React Native 제약 | 네이티브 수준 애니메이션/그래픽은 제한적. Victory Native (Skia)로 차트 성능 확보 |

### 12-4. project-init 조건부 매핑 미지원 항목

> 아래 기술은 project-init 조건부 의존성 테이블에 매핑되어 있지 않으므로, scaffold 후 수동 설치가 필요하다.

| 기술 | 용도 | 수동 설치 패키지 |
|------|------|----------------|
| expo-sharing | 리포트 이미지 공유 (P1) | `expo-sharing` |

---

## 13. Out of Scope

MVP에서 명시적으로 제외하는 기능·영역:

| # | 제외 항목 | 제외 사유 |
|---|----------|----------|
| 1 | **LLM/AI 대화형 상담** | 외부 LLM API 비용 + 복잡도. MVP는 SQL 통계 분석으로 충분 |
| 2 | **멀티모달 입력** (사진, 음성) | 라일리 하루와의 차별점이 "행동 제안"이지 "입력 방식"이 아님. 10초 태그 입력이 핵심 |
| 3 | **소셜 기능** (친구 추가, 감정 공유 커뮤니티) | 1인 개발 범위 초과. 프라이버시 우려 |
| 4 | **게이미피케이션** (캐릭터 육성, 레벨 시스템) | 루빗/하루콩의 영역. 마음날씨는 "분석+행동"에 집중 |
| 5 | **오프라인 멘탈케어 연계** (상담센터 예약) | 외부 파트너십 필요. 1인 개발 제약 위반 |
| 6 | **다국어 지원** | MVP는 한국 시장 집중 |
| 7 | **웨어러블 연동** (Apple Watch, Galaxy Watch) | 기술 복잡도 + 3개월 MVP 범위 초과 |
| 8 | **분기별 감정 트렌드** | P2 기능. 데이터 축적 후 v1.1에서 추가 |
| 9 | **데이터 PDF 내보내기** | P2 기능. v1.1에서 추가 |
| 10 | **네이버 OAuth** | 카카오/구글/애플 3종으로 한국 시장 커버 충분. 네이버는 v1.1에서 필요 시 추가 |

---

## 14. MVP Roadmap

### 14-1. 3개월 주별 마일스톤

#### Phase 1: Foundation (1~4주)

| 주 | 마일스톤 | 상세 |
|----|---------|------|
| **W1** | 프로젝트 초기화 + DB 스키마 | Expo project-init scaffold, Supabase 프로젝트 생성, 전체 DB 스키마 배포 (9 테이블 + RLS + 트리거), 감정 태그/활동 태그/셀프케어 카드 시드 데이터 |
| **W2** | 인증 + 온보딩 | 카카오/구글/애플 소셜 로그인, Supabase Auth 연동, 온보딩 3단계 UI, 프로필 자동 생성 트리거 검증 |
| **W3** | 감정 기록 핵심 | 감정 태그 선택 UI (카테고리별 칩), 활동 태그 선택 + 커스텀 태그, 한줄 메모, PostgREST CRUD 연동, 기록 저장 1초 이내 성능 검증 |
| **W4** | 캘린더 뷰 + 기록 상세 | react-native-calendars 월간 뷰, get_calendar_summary RPC 연동, 날짜별 감정 마커, 기록 상세 조회/수정/삭제 |

#### Phase 2: Intelligence (5~8주)

| 주 | 마일스톤 | 상세 |
|----|---------|------|
| **W5** | 주간 리포트 | get_weekly_summary RPC, Victory Native 도넛 차트 (감정 분포), TOP 3 감정 카드, 주간 요약 화면 완성 |
| **W6** | 셀프케어 카드 시스템 | selfcare_cards 시드 데이터 (50~80장), get_selfcare_recommendations RPC, 카드 UI (스와이프), 피드백(도움됨/아님) 기능 |
| **W7** | 일일 카드 한도 + 오프라인 | increment_daily_card_usage 무료/유료 분기, op-sqlite 동기화 큐 구현, 오프라인 감정 기록→복구 시 자동 동기화 |
| **W8** | 월간 패턴 분석 리포트 | monthly-report Edge Function, 감정 히트맵 (요일×시간대), 활동-감정 상관관계 차트, 인사이트 문구 생성 (규칙 기반) |

#### Phase 3: Monetization & Polish (9~12주)

| 주 | 마일스톤 | 상세 |
|----|---------|------|
| **W9** | 구독 + 결제 | RevenueCat SDK 연동, 월간/연간 구독 IAP 설정, subscription-webhook Edge Function, 프리미엄 월 모달 (블러 처리) |
| **W10** | 무료 체험 + 알림 | start-free-trial Edge Function, 7일 무료 체험 플로우, expo-notifications 로컬 알림 스케줄, 주간 리포트 알림 |
| **W11** | 계정 관리 + QA | delete-account Edge Function, 계정 탈퇴 플로우, 테마 설정 (라이트/다크), Aptabase 분석 연동, 전체 기능 QA |
| **W12** | 배포 준비 + 출시 | EAS Build (iOS/Android), 앱스토어 메타데이터/스크린샷 준비, 개인정보처리방침/이용약관 페이지, TestFlight/내부 테스트 → 스토어 심사 제출 |

### 14-2. 출시 후 v1.1 계획 (4~6개월차)

| 기능 | 우선순위 | 설명 |
|------|---------|------|
| 리포트 이미지 공유 | P1 | 주간/월간 리포트 카카오톡/인스타그램 공유 |
| 감정-활동 상관관계 인사이트 | P1 | 유료 기능. 30일+ 데이터 필요 |
| 효과적 셀프케어 히스토리 | P1 | "도움됨" 표시 카드 목록 |
| 분기별 감정 트렌드 | P2 | 60일+ 데이터 기반 장기 트렌드 |
| 데이터 PDF 내보내기 | P2 | 상담사 공유용 |

---

## 15. Success Metrics

### 15-1. 핵심 지표 (KPI)

#### 사용자 지표

| 지표 | 목표 (출시 6개월) | 목표 (출시 12개월) | 측정 방법 |
|------|-----------------|------------------|----------|
| 누적 다운로드 | 30,000 | 100,000 | 앱스토어 콘솔 |
| MAU (월간 활성 사용자) | 10,000 | 30,000 | Aptabase 이벤트 |
| DAU/MAU (일간 활성 비율) | 25%+ | 30%+ | Aptabase 계산 |
| D7 리텐션 (7일 유지율) | 30%+ | 35%+ | Aptabase 코호트 |
| D30 리텐션 (30일 유지율) | 15%+ | 20%+ | Aptabase 코호트 |

#### 비즈니스 지표

| 지표 | 목표 (출시 6개월) | 목표 (출시 12개월) | 측정 방법 |
|------|-----------------|------------------|----------|
| 유료 전환율 (DL→구독) | 3%+ | 5%+ | RevenueCat 대시보드 |
| 무료체험 시작율 | 7%+ | 10%+ | RevenueCat 이벤트 |
| 무료체험→유료 전환율 | 40%+ | 45%+ | RevenueCat 코호트 |
| MRR (월간 반복 수익) | 200만 원+ | 1,000만 원+ | RevenueCat 대시보드 |
| 구독 유지율 (연간) | 35%+ | 45%+ | RevenueCat 코호트 |

#### 제품 지표

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| 주간 기록 빈도 (활성 사용자) | 주 4회+ | Supabase SQL: AVG(기록수/주) per active user |
| 온보딩 완료율 | 70%+ | Aptabase: 온보딩 시작 대비 완료 이벤트 |
| 셀프케어 카드 "도움됨" 비율 | 60%+ | Supabase SQL: card_feedbacks is_helpful 비율 |
| 주간 리포트 조회율 (활성 사용자) | 50%+ | Aptabase: 리포트 화면 진입 이벤트 |
| 앱스토어 평점 | 4.5+ | 앱스토어 콘솔 |
| 감정 기록 저장 성공률 | 99.5%+ | Supabase 로그 + Aptabase 에러 이벤트 |

### 15-2. North Star Metric

> **주 3회 이상 감정 기록하는 사용자 수 (Weekly Active Recorders)**

**근거**: RevenueCat 2025 보고서에서 "주 3회+ 사용자의 구독 갱신 가능성이 4~5배 높다"는 데이터에 기반. 이 지표가 높으면 리텐션과 유료 전환이 동시에 개선된다.

### 15-3. 측정 인프라

| 도구 | 역할 | 추적 이벤트 |
|------|------|-----------|
| **Aptabase** | 앱 분석 (프라이버시 우선) | 화면 진입, 감정 기록 완료, 리포트 조회, 셀프케어 피드백, 온보딩 단계, 에러 발생 |
| **RevenueCat** | 구독/결제 분석 | 무료체험 시작, 구독 시작/갱신/취소, 플랜 변경, 환불 |
| **Supabase SQL** | 제품 지표 직접 쿼리 | 기록 빈도, 피드백 비율, 활성 사용자 코호트, 감정 태그 사용 분포 |
| **앱스토어 콘솔** | 스토어 지표 | 다운로드, 평점/리뷰, 국가별 분포, 유입 소스 |

---

## 16. Glossary (용어 사전)

### 도메인 용어

| 용어 | 정의 |
|------|------|
| 감정 태그 (Emotion Tag) | 한국어 고유 감정 어휘(서운함, 답답함, 억울함, 뿌듯함 등)를 칩(Chip) UI로 표현한 것. 30~40종으로 구성되며, 사용자가 기록 시 1~3개를 선택한다. 긍정(positive)/부정(negative)/중립(neutral) 카테고리로 분류된다 |
| 활동 태그 (Activity Tag) | 감정이 발생한 맥락을 기록하는 태그. 시스템 태그(출근, 회의, 운동 등 15~20종)와 사용자 커스텀 태그로 구분된다. 감정-활동 상관관계 분석의 기반 데이터 |
| 셀프케어 카드 (Selfcare Card) | 현재 감정 상태에 맞는 실행 가능한 행동을 제안하는 UI 카드. 제목, 소요 시간, 설명으로 구성되며, breathing/movement/mindfulness/social/creative/rest/other 카테고리로 분류된다. 사용자 피드백(도움됨/아님)으로 추천 정확도가 점진 개선된다 |
| 기록→분석→행동 루프 | 마음날씨의 핵심 가치 제안. (1) 감정 기록(10초 태그 선택) → (2) 패턴 분석(주간/월간 리포트) → (3) 행동 제안(셀프케어 카드)의 완결된 순환 구조. 경쟁사(하루콩: 기록만, 마인드카페: 상담만)와의 차별점 |
| 필코노미 (Feelconomy) | 2026 트렌드코리아(김난도)에서 제시한 키워드. Feel(감정) + Economy(경제)의 합성어. 감정을 관리하는 것이 역량이자 소비 동기가 되는 시대적 트렌드 |
| 메타센싱 (Metasensing) | 대학내일20대연구소가 정의한 Z세대 트렌드. 감정도 MBTI처럼 객관적으로 분석하고 데이터화하려는 욕구. 부정적 감정을 '기분 탓'으로 치부하지 않고 원인을 파악하려는 태도 |
| 프리미엄 월 (Premium Wall) | 무료 사용자가 유료 전용 기능(월간 상세 리포트, 무제한 셀프케어 카드 등)에 접근할 때 표시되는 구독 유도 화면. 블러 처리된 미리보기와 가치 제안으로 전환을 유도한다 |
| 무료 체험 (Free Trial) | 결제 정보 입력 없이 7일간 프리미엄 기능을 체험할 수 있는 제도. 계정당 1회로 제한되며, 체험 종료 후 자동으로 무료 플랜으로 전환된다. RevenueCat 2025 데이터에서 무료체험→유료 전환율 44.5%(건강&피트니스 중앙값)에 근거 |

### 비즈니스 약어

| 약어 | 풀이 | 정의 |
|------|------|------|
| MAU | Monthly Active Users | 월간 활성 사용자 수. 해당 월에 1회 이상 앱을 실행한 고유 사용자 |
| DAU | Daily Active Users | 일간 활성 사용자 수 |
| MRR | Monthly Recurring Revenue | 월간 반복 수익. 활성 구독에서 발생하는 월 단위 매출 |
| ARPU | Average Revenue Per User | 사용자당 평균 수익 |
| LTV | Lifetime Value | 고객 생애 가치. 한 사용자가 서비스 이용 기간 동안 창출하는 총 수익 |
| IAP | In-App Purchase | 인앱결제. iOS App Store / Google Play를 통한 앱 내 결제 |
| TAM | Total Addressable Market | 전체 시장 규모 |
| SAM | Serviceable Addressable Market | 접근 가능 시장 규모 |
| SOM | Serviceable Obtainable Market | 실제 획득 가능 시장 규모 |
| ASO | App Store Optimization | 앱스토어 최적화. 검색 순위와 전환율을 높이기 위한 메타데이터/스크린샷 최적화 |
| CTA | Call To Action | 행동 유도 버튼. 사용자가 다음 행동을 취하도록 유도하는 UI 요소 |
| KPI | Key Performance Indicator | 핵심 성과 지표 |

### 기술 용어

| 용어 | 정의 |
|------|------|
| RLS (Row Level Security) | PostgreSQL의 행 수준 보안 정책. 테이블의 각 행에 대해 사용자별 접근 권한을 SQL 정책으로 제어한다. `auth.uid() = user_id` 같은 조건으로 본인 데이터만 접근 허용 |
| RPC (Remote Procedure Call) | Supabase에서 PostgreSQL Function을 HTTP API로 호출하는 방식. `/rest/v1/rpc/{function_name}`으로 접근하며, 복합 쿼리나 트랜잭션 로직에 사용 |
| PostgREST | PostgreSQL 테이블에 대해 자동으로 RESTful API를 생성하는 서비스. Supabase가 내장하며, 단순 CRUD에 사용. RLS 정책이 자동 적용된다 |
| Edge Function | Supabase에서 Deno Runtime으로 실행되는 서버리스 함수. 복합 비즈니스 로직(리포트 생성, 계정 삭제, 외부 API 호출 등)에 사용 |
| op-sqlite | React Native용 고성능 SQLite 바인딩. 오프라인 감정 기록 큐(sync_queue)와 캘린더 뷰 캐시에 사용. project-init 고정 스택 |
| MMKV | WeChat이 개발한 Key-Value 저장소의 React Native 바인딩(react-native-mmkv). JSI 기반으로 0.03ms 읽기 성능. 인증 토큰, 설정값, 구독 상태 캐시에 사용. project-init 고정 스택 |
| Zustand Store | Zustand 상태 관리 라이브러리에서 정의하는 전역 상태 단위. 본 앱에서 9개 Store(Auth, Profile, EmotionLog, Calendar, Report, Selfcare, Subscription, Notification, Sync)를 사용 |
| sync_queue | op-sqlite에 생성하는 로컬 테이블. 오프라인에서 생성된 감정 기록을 pending→synced→failed 상태로 관리하며, 네트워크 복구 시 서버로 동기화한다 |
| Server Wins | 충돌 해결 정책. 로컬과 서버 데이터가 충돌할 때 서버 버전을 최종 권한(single source of truth)으로 채택한다. 1인 사용자 앱에서 다중 기기 동시 편집 가능성이 낮으므로 적합 |
| RevenueCat | iOS/Android 인앱결제(IAP)를 통합 관리하는 서드파티 SDK. 영수증 검증, 크로스 플랫폼 구독 상태 관리, 무료 체험 관리, 구독 분석 대시보드를 제공. 1인 개발에 최적화된 구독 인프라 |
| Aptabase | 프라이버시 우선(Privacy-first) 앱 분석 도구. Firebase Analytics 대비 config plugin 복잡성이 낮아 Expo Managed Workflow에 적합. 화면 진입, 이벤트 추적, 코호트 분석에 사용 |
| EAS Build | Expo Application Services의 클라우드 빌드 서비스. Windows 환경에서 macOS 없이 iOS 빌드가 가능. `eas build --platform ios`로 실행 |
| North Star Metric | 제품의 핵심 성공을 대표하는 단일 지표. 본 앱에서는 "주 3회 이상 감정 기록하는 사용자 수(Weekly Active Recorders)"로 정의. RevenueCat 2025에서 주 3회+ 사용자의 구독 갱신 가능성이 4~5배 높다는 데이터에 근거 |
