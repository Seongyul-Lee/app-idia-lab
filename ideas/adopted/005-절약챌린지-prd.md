# 005-절약챌린지 PRD (Product Requirements Document)

> **앱명 (가칭)**: 오늘도 무지출
> **작성일**: 2026-01-31
> **버전**: 1.1 (2026-02-02, 4단계 회귀 수정)

---

## 1. Executive Summary

"오늘도 무지출"은 MZ세대의 무지출 챌린지를 게이미피케이션으로 재미있게 만들어, 하루 한 번 탭으로 절약 습관을 형성하고, 커뮤니티(절약방)로 동기를 유지시키는 전용 앱이다. 기존 가계부 앱의 복잡한 UI와 높은 포기율, 카카오톡 거지방·인스타그램 절약스타그램의 비체계적 기록 문제를 해결한다. 무지출 캘린더와 스트릭으로 시각적 동기부여를 제공하고, 주간/월간 챌린지 시스템으로 목표 달성감을 극대화하며, 앱 내 절약 커뮤니티로 소셜 동기부여를 통한 지속성을 확보한다.

---

## 2. Problem Statement

### 2.1 핵심 문제

**가계부 앱의 높은 포기율과 무지출 챌린지 전용 도구의 부재**

한국 MZ세대(20~39세) 약 1,237만 명 중 80.7%가 절약/소비 관리에 관심을 보이지만(한국방송광고진흥공사 조사), 이를 실천하고 지속할 수 있는 적절한 도구가 없다.

### 2.2 구체적 Pain Point

1. **가계부 앱 작심삼일**: "가계부 앱 3개 정도 깔았다 지웠어요. 매번 입력하는 게 귀찮아서 작심삼일"(네이버 블로그 후기). 기존 앱은 복잡한 카테고리 분류·수동 입력을 요구해 지속률이 낮다.

2. **무지출 챌린지 전용 앱 부재**: #무지출챌린지 네이버 블로그 게시글 1.5만건 이상, 카카오톡 거지방 수백 개(대부분 Full)가 운영 중이나, 참여자들은 인스타그램·엑셀·카카오톡에 분산되어 체계적 관리가 불가능하다.

3. **혼자서 절약 습관 유지 어려움**: "혼자서는 꾸준히 실천하기 어려운 절약·저축을 다른 사람과 공유하며 재미있게 할 수 있다는 점"이 SNS 절약 트렌드의 핵심 동력(인크로스 디지털 마케팅 분석). 소셜 동기부여 없이는 습관 형성이 어렵다.

4. **고물가 시대 소비 통제 욕구**: 생활물가지수 3.5% 상승, 신선식품 19.1% 상승(통계청). YOLO에서 YONO(You Only Need One)로 소비 패러다임이 전환되며 절약 도구 수요가 급증한다.

### 2.3 시장 기회

- **SAM**: 약 119만 명 (절약 커뮤니티 적극 참여층)
- **SOM**: 약 47.6만 총 사용자, 약 2.38만 유료 사용자 (1~3년 내)
- 챌린저스가 뷰티 커머스로 피봇하면서 순수 절약/습관 형성 전문 앱에 시장 공백 발생

---

## 3. Target Users & Personas

### Persona 1: 사회초년생 김절약 (26세, 마케팅 대리)

| 항목 | 내용 |
|------|------|
| 연령/성별 | 26세, 여성 |
| 직업 | 중견기업 마케팅 대리 (연봉 3,200만 원) |
| 월 가처분소득 | 약 170만 원 |
| 절약 목표 | 1년 내 비상금 500만 원 마련 |
| 현재 행동 | 인스타 #무지출챌린지 인증, 카카오톡 거지방 2개 참여 |
| Pain Point | 인스타 인증은 까먹기 쉽고, 거지방은 대화가 묻혀서 내 기록을 찾기 어려움 |
| 앱 사용 기대 | 무지출 날 탭 한 번으로 기록, 스트릭으로 동기부여, 비슷한 또래와 절약 팁 공유 |
| 기기 | iPhone 15, 출퇴근 시간에 주로 사용 |

### Persona 2: 대학생 이알뜰 (22세, 경영학과)

| 항목 | 내용 |
|------|------|
| 연령/성별 | 22세, 남성 |
| 직업 | 대학생 (월 생활비 60만 원, 부모 지원 + 알바) |
| 절약 목표 | 월 생활비 50만 원 이하로 유지, 여행 자금 마련 |
| 현재 행동 | 편한가계부 앱 3번 깔았다 삭제, 현재는 메모장에 지출 기록 |
| Pain Point | 가계부 입력이 너무 번거로움. 친구들과 절약 경쟁하고 싶은데 방법이 없음 |
| 앱 사용 기대 | 간단한 무지출/지출 기록, 친구와 챌린지 대결, 월말 절약 리포트 |
| 기기 | Galaxy S23, 하루 종일 사용 |

### Persona 3: 신혼부부 박아끼 (32세, 개발자)

| 항목 | 내용 |
|------|------|
| 연령/성별 | 32세, 남성 |
| 직업 | IT기업 개발자 (연봉 5,500만 원) |
| 월 가처분소득 | 약 250만 원 (부부 합산 가처분 450만 원) |
| 절약 목표 | 내집 마련 위해 월 150만 원 저축, 커피값·배달비 줄이기 |
| 현재 행동 | 토스 가계부 사용 중이나 챌린지 기능이 없어서 별도 동기부여 수단 없음 |
| Pain Point | 토스 가계부는 기록만 가능하고, 절약 동기부여가 없음. 아내와 함께 절약 챌린지를 하고 싶음 |
| 앱 사용 기대 | 커스텀 챌린지(커피 끊기, 배달 줄이기), 부부 함께 참여, 절약 현황 리포트 |
| 기기 | iPhone 16 Pro, 출퇴근+점심시간 사용 |

---

## 4. User Stories

### Epic 1: 온보딩 & 인증

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-01-1 | 사용자로서, 카카오 계정으로 3탭 이내에 가입을 완료하고 싶다. 별도 복잡한 정보 입력 없이 빠르게 시작하기 위해. | P0 |
| US-01-2 | 사용자로서, 구글/애플 계정으로도 가입할 수 있길 원한다. 카카오 계정이 없거나 다른 계정을 선호할 수 있으므로. | P0 |
| US-01-3 | 사용자로서, 온보딩에서 나의 절약 목표(월 목표 금액, 관심 챌린지)를 간단히 설정하고 싶다. 맞춤형 경험을 위해. | P0 |
| US-01-4 | 사용자로서, 앱 재실행 시 자동 로그인이 되길 원한다. 매번 로그인하는 번거로움을 피하기 위해. | P0 |

### Epic 2: 무지출 캘린더 & 스트릭

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-02-1 | 사용자로서, 오늘 무지출했다면 버튼 한 번 탭으로 인증하고 싶다. 가계부처럼 복잡한 입력 없이 간단히 기록하기 위해. | P0 |
| US-02-2 | 사용자로서, 지출한 날에는 금액만 간단히 입력하고 싶다. 상세 카테고리 없이 총액만 기록해 부담을 줄이기 위해. | P0 |
| US-02-3 | 사용자로서, 캘린더에서 무지출 날과 지출 날을 한눈에 구분하고 싶다. 한 달 절약 현황을 시각적으로 파악하기 위해. | P0 |
| US-02-4 | 사용자로서, 연속 무지출 일수(스트릭)가 숫자와 시각적 효과로 표시되길 원한다. 기록을 이어가는 동기부여를 얻기 위해. | P0 |
| US-02-5 | 사용자로서, 월별 무지출 일수와 총 지출 요약을 리포트로 보고 싶다. 내 절약 성과를 객관적으로 확인하기 위해. | P1 |
| US-02-6 | 사용자로서, 지출 입력 시 간단한 메모(선택)를 남기고 싶다. 나중에 어디에 돈을 썼는지 회상하기 위해. | P1 |

### Epic 3: 절약 챌린지 시스템

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-03-1 | 사용자로서, 앱에서 제공하는 공식 챌린지(주간 3일 무지출, 월간 커피값 절약 등)에 참여하고 싶다. 구체적 목표를 갖고 절약하기 위해. | P0 |
| US-03-2 | 사용자로서, 챌린지 진행률(달성/미달성)을 실시간으로 확인하고 싶다. 목표까지 얼마나 남았는지 알기 위해. | P0 |
| US-03-3 | 사용자로서, 챌린지 달성 시 배지와 레벨업 보상을 받고 싶다. 성취감과 재미를 얻기 위해. | P0 |
| US-03-4 | 사용자로서, 나만의 커스텀 챌린지를 생성하고 싶다. 개인 절약 목표에 맞는 챌린지를 만들기 위해. | P1 |
| US-03-5 | 사용자로서, 참여 중인 챌린지의 다른 참여자 랭킹을 보고 싶다. 경쟁 심리로 동기부여를 얻기 위해. | P1 |

### Epic 4: 절약 커뮤니티 (절약방)

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-04-1 | 사용자로서, 절약방(공개 커뮤니티)에 무지출 인증이나 절약 팁을 공유하고 싶다. 다른 사람들과 절약 경험을 나누기 위해. | P0 |
| US-04-2 | 사용자로서, 다른 사람의 절약 인증 게시글에 응원(좋아요/댓글)을 남기고 싶다. 서로 격려하며 동기를 유지하기 위해. | P0 |
| US-04-3 | 사용자로서, 절약방에서 인기글/최신글을 볼 수 있길 원한다. 유용한 절약 팁을 쉽게 찾기 위해. | P1 |
| US-04-4 | 사용자로서, 부적절한 게시글을 신고할 수 있길 원한다. 건전한 커뮤니티 환경을 유지하기 위해. | P1 |

### Epic 5: 리포트 & 통계

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-05-1 | 사용자로서, 주간/월간 절약 리포트를 확인하고 싶다. 내 절약 패턴과 성과를 분석하기 위해. | P1 |
| US-05-2 | 사용자로서, 지난 달 대비 절약률 변화를 그래프로 보고 싶다. 절약 습관의 개선 추이를 파악하기 위해. | P2 |

### Epic 6: 알림 & 리마인더

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-06-1 | 사용자로서, 매일 저녁 무지출 인증 알림을 받고 싶다. 기록을 잊지 않기 위해. | P0 |
| US-06-2 | 사용자로서, 알림 시간을 직접 설정할 수 있길 원한다. 내 생활 패턴에 맞추기 위해. | P1 |
| US-06-3 | 사용자로서, 스트릭이 끊기기 직전에 경고 알림을 받고 싶다. 기록을 놓치지 않기 위해. | P1 |

### Epic 7: 설정 & 계정 관리

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-07-1 | 사용자로서, 내 프로필(닉네임, 절약 목표)을 수정할 수 있길 원한다. 변경된 상황을 반영하기 위해. | P0 |
| US-07-2 | 사용자로서, 앱 테마(다크모드)를 설정할 수 있길 원한다. 내 취향에 맞는 UI를 사용하기 위해. | P2 |
| US-07-3 | 사용자로서, 계정을 탈퇴하고 데이터를 삭제할 수 있길 원한다. 개인정보 보호를 위해. | P0 |
| US-07-4 | 사용자로서, 로그아웃 후 다른 계정으로 전환할 수 있길 원한다. 여러 계정을 사용하기 위해. | P1 |

### Epic 8: 결제 & 프리미엄

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-08-1 | 사용자로서, 프리미엄 구독 혜택(상세 분석, 커스텀 챌린지, 광고 제거)을 확인하고 구매할 수 있길 원한다. 더 풍부한 기능을 사용하기 위해. | P1 |
| US-08-2 | 사용자로서, 구독을 관리(해지/갱신 확인)할 수 있길 원한다. 과금을 통제하기 위해. | P1 |
| US-08-3 | 사용자로서, 구독 없이도 핵심 기능(무지출 캘린더, 기본 챌린지, 커뮤니티)을 사용할 수 있길 원한다. 무료 사용자로서 충분한 가치를 얻기 위해. | P0 |

---

## 5. Functional Requirements

### 5.1 P0 (Must Have) — MVP 핵심

#### FR-01: 소셜 로그인 & 온보딩

| 항목 | 내용 |
|------|------|
| 설명 | 카카오/구글/애플 OAuth로 가입·로그인 |
| 입력 | OAuth 토큰, 닉네임(자동생성 가능), 월 절약 목표금액 |
| 출력 | 사용자 계정 생성, 세션 토큰 발급, 홈 화면 이동 |
| 제한사항 | 3탭 이내 가입 완료, 필수 입력은 닉네임+목표금액만 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-01-1: 카카오/구글/애플 로그인 버튼 탭 후 3탭 이내에 홈 화면에 도달한다
- AC-01-2: 온보딩에서 닉네임(2~10자)과 월 절약 목표금액(1만~999만 원)을 설정할 수 있다
- AC-01-3: 앱 종료 후 재실행 시 자동 로그인되어 홈 화면이 표시된다
- AC-01-4: 로그인 실패 시(네트워크 오류 등) 사용자에게 에러 메시지를 표시한다

#### FR-02: 무지출 인증 (원탭)

| 항목 | 내용 |
|------|------|
| 설명 | 홈 화면 메인 버튼 탭으로 오늘 무지출 인증 |
| 입력 | 탭(무지출) 또는 지출 금액(원 단위) + 메모(선택) |
| 출력 | 일일 기록 저장, 캘린더 반영, 스트릭 갱신 |
| 제한사항 | 하루 1회만 인증 가능 (수정 가능), 금액 범위 0~9,999,999원 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-02-1: 홈 화면의 "오늘 무지출!" 버튼을 1탭하면 무지출 기록이 저장되고, 2초 이내에 축하 애니메이션이 표시된다
- AC-02-2: "지출 있음" 선택 시 금액 입력 필드가 표시되고, 금액(필수)+메모(선택) 입력 후 저장된다
- AC-02-3: 이미 인증한 날에 다시 접근하면 기존 기록이 표시되고, "수정" 버튼으로 변경할 수 있다
- AC-02-4: 인증 데이터는 오프라인에서도 로컬에 저장되고, 온라인 복귀 시 서버와 동기화된다

#### FR-03: 무지출 캘린더

| 항목 | 내용 |
|------|------|
| 설명 | 월별 캘린더에 무지출/지출 일자를 시각적으로 표시 |
| 입력 | 월 선택 (좌우 스와이프) |
| 출력 | 캘린더 뷰 (무지출=초록, 지출=빨강, 미기록=회색), 월간 요약 통계 |
| 제한사항 | 과거 날짜 소급 입력 가능 (최대 7일 전까지) |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-03-1: 캘린더에 무지출 날(초록), 지출 날(빨강), 미기록 날(회색)이 색상으로 구분 표시된다
- AC-03-2: 캘린더 상단에 해당 월의 무지출 일수, 총 지출 금액, 일평균 지출이 표시된다
- AC-03-3: 날짜 셀 탭 시 해당 날의 상세 기록(무지출 여부, 금액, 메모)이 표시된다
- AC-03-4: 최대 7일 전까지 소급 입력/수정이 가능하다

#### FR-04: 스트릭 시스템

| 항목 | 내용 |
|------|------|
| 설명 | 연속 무지출 일수를 카운트하고 시각적으로 표시 |
| 입력 | 일일 무지출 인증 데이터 |
| 출력 | 현재 스트릭 수, 최장 스트릭 기록, 스트릭 시각 효과 |
| 제한사항 | 자정(KST) 기준으로 일 구분, 지출 기록 시 스트릭 리셋 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-04-1: 무지출 인증이 연속될 때마다 스트릭 카운터가 1씩 증가한다
- AC-04-2: 지출 기록 또는 미기록 시 스트릭이 0으로 리셋된다
- AC-04-3: 홈 화면에 현재 스트릭과 역대 최장 스트릭이 표시된다
- AC-04-4: 스트릭 마일스톤(3일, 7일, 14일, 30일) 달성 시 축하 모션이 표시된다

#### FR-05: 공식 챌린지 참여

| 항목 | 내용 |
|------|------|
| 설명 | 앱에서 제공하는 사전 정의된 챌린지에 참여 |
| 입력 | 챌린지 선택 및 참여 버튼 탭 |
| 출력 | 참여 등록, 진행률 표시, 달성 시 배지 지급 |
| 제한사항 | 동시 참여 가능 챌린지 최대 3개 |
| 무료/유료 | 무료 (기본 챌린지) |

**수용 기준:**
- AC-05-1: 챌린지 목록에서 진행 중인 공식 챌린지를 확인하고, "참여하기" 버튼으로 즉시 참여할 수 있다
- AC-05-2: 참여 중인 챌린지의 진행률(달성 일수/목표 일수)이 프로그레스 바로 표시된다
- AC-05-3: 챌린지 달성 시 배지가 지급되고, 배지함에서 확인할 수 있다
- AC-05-4: 동시 참여 챌린지가 3개를 초과하면 참여 불가 메시지가 표시된다

#### FR-06: 배지 & 레벨 시스템

| 항목 | 내용 |
|------|------|
| 설명 | 챌린지 달성, 스트릭 마일스톤 등에 대한 배지 지급 및 레벨업 |
| 입력 | 달성 이벤트 트리거 |
| 출력 | 배지 획득 알림, 경험치 부여, 레벨 업 시 시각 효과 |
| 제한사항 | 동일 배지 중복 획득 불가 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-06-1: 챌린지 완료, 스트릭 마일스톤, 커뮤니티 활동 등 조건 달성 시 해당 배지가 자동 지급된다
- AC-06-2: 배지 획득 시 팝업 알림과 축하 애니메이션이 표시된다
- AC-06-3: 배지함에서 획득한 배지 목록과 미획득 배지(잠김 상태)를 확인할 수 있다
- AC-06-4: 경험치 누적에 따라 레벨이 상승하고, 현재 레벨과 다음 레벨까지 필요 경험치가 표시된다

#### FR-07: 절약방 (커뮤니티 피드)

| 항목 | 내용 |
|------|------|
| 설명 | 무지출 인증, 절약 팁 등을 공유하는 커뮤니티 피드 |
| 입력 | 게시글 작성(텍스트 + 이미지 선택), 좋아요, 댓글 |
| 출력 | 피드 목록(최신순/인기순), 좋아요 수, 댓글 목록 |
| 제한사항 | 게시글 텍스트 최대 500자, 이미지 최대 3장, 댓글 최대 200자 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-07-1: 게시글 작성 시 텍스트(최대 500자)와 이미지(최대 3장)를 첨부할 수 있다
- AC-07-2: 피드에서 최신순/인기순 정렬을 전환할 수 있다
- AC-07-3: 게시글에 좋아요와 댓글(최대 200자)을 남길 수 있다
- AC-07-4: 부적절한 게시글/댓글을 신고할 수 있고, 신고된 콘텐츠는 관리 정책에 따라 처리된다

#### FR-08: 일일 리마인더 알림

| 항목 | 내용 |
|------|------|
| 설명 | 매일 설정 시간에 무지출 인증 리마인드 푸시 알림 |
| 입력 | 알림 시간 설정 |
| 출력 | 푸시 알림 수신 |
| 제한사항 | 기본 시간 21:00 KST, 사용자 변경 가능 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-08-1: 온보딩 완료 후 알림 권한을 요청하고, 기본 21:00 KST에 리마인더가 발송된다
- AC-08-2: 설정에서 알림 시간을 변경할 수 있다
- AC-08-3: 이미 오늘 인증을 완료한 경우에는 리마인더가 발송되지 않는다

#### FR-09: 계정 관리

| 항목 | 내용 |
|------|------|
| 설명 | 프로필 수정, 로그아웃, 계정 탈퇴 |
| 입력 | 닉네임 변경, 목표금액 변경, 탈퇴 확인 |
| 출력 | 프로필 업데이트, 세션 종료, 데이터 삭제 |
| 제한사항 | 탈퇴 시 30일 유예 기간 후 완전 삭제 |
| 무료/유료 | 무료 |

**수용 기준:**
- AC-09-1: 설정 화면에서 닉네임(2~10자)과 월 절약 목표금액을 수정할 수 있다
- AC-09-2: 로그아웃 시 로컬 세션이 초기화되고 로그인 화면으로 이동한다
- AC-09-3: 계정 탈퇴 요청 시 확인 다이얼로그가 표시되고, 확인 후 30일 유예 기간이 시작된다
- AC-09-4: 유예 기간 내 재로그인하면 탈퇴가 취소된다

### 5.2 P1 (Should Have)

| ID | 기능 | 설명 | 무료/유료 |
|----|------|------|-----------|
| FR-10 | 월간 리포트 | 무지출 일수, 총 지출, 절약률 등 월간 통계 리포트 | 무료(기본) / 유료(상세) |
| FR-11 | 커스텀 챌린지 | 사용자가 직접 챌린지 생성 (목표, 기간, 규칙 설정) | 유료 |
| FR-12 | 챌린지 랭킹 | 참여 중인 챌린지의 참여자 순위 표시 | 무료 |
| FR-13 | 알림 시간 커스텀 | 리마인더 알림 시간 변경 | 무료 |
| FR-14 | 스트릭 경고 알림 | 스트릭 끊기기 직전(당일 미인증) 추가 알림 | 무료 |
| FR-15 | 프리미엄 구독 관리 | 인앱구매 기반 프리미엄 구독 결제/해지 | 유료 |
| FR-16 | 커뮤니티 정렬/필터 | 인기글/최신글 정렬, 태그 기반 필터 | 무료 |

### 5.3 P2 (Nice to Have)

| ID | 기능 | 설명 | 무료/유료 |
|----|------|------|-----------|
| FR-17 | 소비 패턴 분석 차트 | 월별/카테고리별 지출 트렌드 시각화 | 유료 |
| FR-18 | 다크 모드 | 앱 테마 전환 | 무료 |
| FR-19 | 소셜 공유 | 스트릭/배지 성과를 SNS로 공유 | 무료 |
| FR-20 | 52주 저축 챌린지 | 장기 저축 목표 관리 템플릿 | 무료 |

---

## 6. Non-functional Requirements

### 6.1 성능

| 항목 | 요구사항 |
|------|---------|
| 앱 초기 로드 | 콜드 스타트 3초 이내 |
| 화면 전환 | 300ms 이내 |
| 무지출 인증 응답 | 로컬 저장 즉시, 서버 동기화 2초 이내 |
| 커뮤니티 피드 로딩 | 첫 페이지 20개 게시글 1.5초 이내 |
| 오프라인 동작 | 인증·캘린더 조회·스트릭 확인이 오프라인에서 정상 동작 |

### 6.2 보안

| 항목 | 요구사항 |
|------|---------|
| 인증 | Supabase Auth + OAuth 2.0, JWT 토큰 기반 |
| 데이터 암호화 | HTTPS(TLS 1.2+) 전송 암호화 |
| RLS | Supabase Row Level Security로 사용자 데이터 격리 |
| 개인정보 | 최소 수집 원칙 (이메일, 닉네임, 절약 기록만) |
| 탈퇴 | GDPR/개인정보보호법 준수, 30일 유예 후 완전 삭제 |

### 6.3 접근성

| 항목 | 요구사항 |
|------|---------|
| 최소 OS | iOS 15+, Android 10+ |
| 화면 크기 | 4.7인치~6.7인치 대응 |
| 다국어 | 한국어 전용 (MVP) |
| 접근성 | 기본 VoiceOver/TalkBack 라벨링 |

### 6.4 확장성

| 항목 | 요구사항 |
|------|---------|
| 동시 사용자 | MVP 기준 DAU 1만 명 처리 가능 설계 |
| DB | Supabase 무료/Pro 플랜으로 초기 커버, 스케일업 가능 구조 |
| 코드 구조 | Feature-based 디렉토리 구조로 기능 추가 용이 |

---

## 7. Technical Architecture

### 7-1. 기술 스택

| 레이어 | 기술 | 선정 사유 |
|--------|------|-----------|
| **프레임워크** | Expo Managed Workflow (SDK 52) | OTA 업데이트, 빌드 서비스(EAS) 내장. 1인 개발에서 네이티브 빌드 관리 부담 제거 |
| **언어** | TypeScript (strict mode) | 컴파일 타임 타입 검증으로 런타임 버그 최소화. 1인 개발 시 리팩터링 안전성 확보 |
| **라우팅** | Expo Router (파일 기반) | 파일 시스템 기반 라우팅으로 화면 구조 직관적 파악. Deep linking 자동 지원 |
| **UI** | React Native Paper | Material Design 3 기반 컴포넌트 라이브러리. 테마 시스템 내장, 다크모드 지원 |
| **상태 관리** | Zustand | 보일러플레이트 최소, 미들웨어로 persist/devtools 지원. 러닝커브 낮음 |
| **로컬 KV** | react-native-mmkv | C++ JSI 기반으로 AsyncStorage 대비 30배 빠른 읽기/쓰기. 세션 토큰, 설정값, 동기화 큐 저장 |
| **로컬 DB** | op-sqlite | SQLite 기반 관계형 로컬 DB. 오프라인 일일 기록 캐싱, 캘린더 데이터 로컬 조회에 사용 |
| **백엔드** | Supabase (PostgreSQL + Auth + Edge Functions + Storage) | 인증·DB·스토리지·서버리스 함수 올인원. 1인 개발에 최적. RLS로 보안 강화 |
| **인증** | Kakao OAuth, Google OAuth, Apple Auth | 한국 시장 점유율 1위 카카오 + 글로벌 표준(구글/애플). Supabase Auth와 통합 |
| **알림** | expo-notifications | Expo 생태계 내장 푸시 알림. 로컬/원격 알림 모두 지원 |
| **결제** | RevenueCat | 인앱구매 서버사이드 영수증 검증 자동화. iOS/Android 통합 관리. 1인 개발에서 결제 로직 복잡도 대폭 감소 |
| **차트** | Gifted Charts (SVG 기반) | 경량 SVG 렌더링, 커스터마이징 용이. 월간 리포트 차트에 사용 |
| **캘린더** | react-native-calendars | 검증된 RN 캘린더 컴포넌트. 커스텀 날짜 마킹, 월 단위 스와이프 지원 |
| **이미지** | expo-image-picker | 커뮤니티 게시글 이미지 첨부용. Expo 생태계 내장 |
| **애니메이션** | Lottie | 스트릭 축하, 배지 획득 등 마이크로 인터랙션. JSON 기반 경량 애니메이션 |
| **햅틱** | expo-haptics | 무지출 인증 탭 시 촉각 피드백. 사용자 만족감 향상 |
| **분석** | Aptabase | 프라이버시 우선 분석 도구. GDPR 준수, 경량. 절약 앱 사용자의 프라이버시 민감성 고려 |
| **빌드** | EAS Build + EAS Submit | Expo 통합 빌드/배포 파이프라인. CI/CD 자동화 |

### 7-2. 시스템 구조도

```
┌─────────────────────────────────────────────────────────────────────┐
│                         클라이언트 (React Native / Expo)              │
│                                                                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ 홈/인증   │  │ 캘린더    │  │ 챌린지    │  │ 커뮤니티   │           │
│  │ 화면      │  │ 화면      │  │ 화면      │  │ 화면      │           │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘           │
│       │             │             │             │                   │
│  ┌────┴─────────────┴─────────────┴─────────────┴──────────┐      │
│  │                    Zustand Store Layer                    │      │
│  │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐         │      │
│  │  │Auth  │ │Record│ │Chall.│ │Commu.│ │Badge │         │      │
│  │  │Store │ │Store │ │Store │ │Store │ │Store │         │      │
│  │  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘         │      │
│  └──────────────────────┬──────────────────────────────────┘      │
│                         │                                          │
│  ┌──────────────────────┴──────────────────────────────────┐      │
│  │               오프라인 계층 (Offline Layer)                │      │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │      │
│  │  │ op-sqlite    │  │ MMKV         │  │ SyncQueue    │  │      │
│  │  │ (일일기록,   │  │ (세션토큰,   │  │ (동기화 큐   │  │      │
│  │  │  캘린더캐시) │  │  설정, KV)   │  │  관리)       │  │      │
│  │  └──────────────┘  └──────────────┘  └──────────────┘  │      │
│  └─────────────────────────────────────────────────────────┘      │
└────────────────────────────────┬────────────────────────────────────┘
                                 │ HTTPS
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         Supabase Backend                            │
│                                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │
│  │ Supabase     │  │ PostgreSQL   │  │ Supabase     │             │
│  │ Auth         │  │ + RLS        │  │ Storage      │             │
│  │ (OAuth)      │  │ (핵심 데이터) │  │ (이미지)     │             │
│  └──────────────┘  └──────────────┘  └──────────────┘             │
│                                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │
│  │ Edge         │  │ Supabase     │  │ Database     │             │
│  │ Functions    │  │ Realtime     │  │ Functions    │             │
│  │ (비즈니스    │  │ (커뮤니티    │  │ (RPC: 스트릭 │             │
│  │  로직)       │  │  실시간)     │  │  계산 등)    │             │
│  └──────────────┘  └──────────────┘  └──────────────┘             │
└─────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         외부 서비스                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │
│  │ RevenueCat   │  │ Expo Push    │  │ Aptabase     │             │
│  │ (결제 관리)  │  │ (푸시 알림)  │  │ (분석)       │             │
│  └──────────────┘  └──────────────┘  └──────────────┘             │
└─────────────────────────────────────────────────────────────────────┘
```

**데이터 흐름:**
1. **무지출 인증**: 사용자 탭 → Zustand RecordStore 업데이트 → op-sqlite 로컬 저장 → SyncQueue에 등록 → 온라인 시 Supabase REST API로 동기화
2. **챌린지 참여**: 사용자 참여 → Edge Function(참여 가능 여부 검증) → PostgreSQL 저장 → Zustand ChallengeStore 업데이트
3. **커뮤니티 피드**: 게시글 작성 → Supabase Storage(이미지 업로드) → PostgreSQL 저장 → Supabase Realtime으로 타 사용자에게 실시간 반영
4. **알림**: expo-notifications 로컬 스케줄링(일일 리마인더) + Supabase Edge Function → Expo Push Service(서버 발송)

### 7-3. 오프라인 우선 설계

#### 저장소별 역할 분담

| 저장소 | 저장 데이터 | 선택 근거 |
|--------|------------|-----------|
| **MMKV** | 세션 토큰, 사용자 설정(알림시간, 테마), 온보딩 완료 플래그, 동기화 큐 메타데이터 | 단순 KV 데이터. C++ JSI 기반 초고속 읽기/쓰기. 앱 시작 시 즉시 로드 필요한 데이터에 적합 |
| **op-sqlite** | 일일 기록(daily_records), 캘린더 캐시(월별 데이터), 스트릭 상태, 챌린지 진행 데이터, 배지 목록 | 관계형 쿼리 필요(월별 필터, 집계). 오프라인 캘린더 조회, 스트릭 계산에 SQL 활용 |
| **Supabase Storage** | 커뮤니티 게시글 이미지 | 바이너리 파일 저장. 온라인 전용 (오프라인 시 캐시된 URL 사용) |

#### 동기화 큐 로직

```
┌─────────────────────────────────────────────┐
│              SyncQueue (MMKV 기반)            │
│                                             │
│  큐 항목 구조:                                │
│  {                                          │
│    id: string (UUID)                        │
│    type: 'CREATE' | 'UPDATE' | 'DELETE'     │
│    table: string                            │
│    payload: JSON                            │
│    created_at: ISO timestamp                │
│    retry_count: number                      │
│    next_retry_at: ISO timestamp             │
│  }                                          │
└─────────────────────────────────────────────┘
```

**동기화 전략:**
- **트리거**: 네트워크 상태 변경(오프라인→온라인) 감지 시 자동 실행 + 앱 포그라운드 전환 시 실행
- **처리 순서**: FIFO (created_at 순서)
- **재시도 횟수**: 최대 5회
- **백오프 전략**: 지수 백오프 (1초 → 2초 → 4초 → 8초 → 16초)
- **최대 큐 크기**: 1,000건 (초과 시 가장 오래된 항목부터 삭제)
- **실패 처리**: 5회 실패 시 해당 항목을 `failed_queue`로 이동, 사용자에게 알림

#### 충돌 해결 정책

| 정책 | **Server Wins** (기본 정책) |
|------|---------------------------|
| 원칙 | 동일 레코드에 서버·로컬 모두 변경이 있을 경우, 서버 데이터를 우선한다 |
| 적용 대상 | 일일 기록, 챌린지 참여, 프로필 정보 |
| 구현 방식 | 동기화 시 서버의 `updated_at`이 로컬 `updated_at`보다 최신이면 서버 데이터로 덮어쓰기 |
| 예외 | 아직 서버에 존재하지 않는 레코드(CREATE)는 충돌 없이 서버에 삽입 |

**충돌 감지 흐름:**
1. 로컬에서 변경 발생 → SyncQueue에 추가 (로컬 `updated_at` 기록)
2. 온라인 복귀 시 서버에 동기화 요청
3. 서버 측에서 해당 레코드의 `updated_at` 비교
4. 서버가 더 최신이면 → 서버 데이터 반환, 로컬 덮어쓰기
5. 로컬이 더 최신이면 → 서버 업데이트

### 7-4. 핵심 설계 원칙

1. **Offline-First**: 무지출 인증·캘린더 조회·스트릭 확인은 네트워크 없이도 완전히 동작해야 한다. 절약 기록은 즉시성이 핵심이며, 네트워크 지연이 사용자 경험을 해쳐서는 안 된다.

2. **Extreme Simplicity**: 핵심 인터랙션(무지출 인증)은 1탭으로 완료되어야 한다. 가계부 앱의 복잡한 입력이 사용자 이탈의 주 원인이므로, 모든 UI 결정에서 단순함을 우선한다.

3. **Server-Authoritative for Gamification**: 배지·레벨·챌린지 달성 판정은 반드시 서버(Edge Function/DB Function)에서 수행한다. 클라이언트 조작으로 게이미피케이션 무결성이 훼손되면 커뮤니티 신뢰가 붕괴한다.

4. **Feature-Based Modularity**: 기능별 디렉토리 구조(`features/auth/`, `features/record/`, `features/challenge/` 등)로 코드를 분리한다. 1인 개발에서 기능 간 의존성을 최소화하고, MVP 이후 기능 추가/제거를 용이하게 한다.

5. **Progressive Enhancement**: 무료 사용자에게 핵심 가치(인증·캘린더·기본 챌린지·커뮤니티)를 완전히 제공하고, 프리미엄은 분석·커스텀 챌린지·광고 제거 등 부가 가치로 한정한다. 절약 앱 사용자의 과금 민감성을 고려한 전략.

### 7-5. DB 스키마

#### 테이블 정의

```sql
-- ============================================
-- 1. profiles (사용자 프로필)
-- ============================================
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname TEXT NOT NULL CHECK (char_length(nickname) BETWEEN 2 AND 10),
  monthly_goal INTEGER NOT NULL CHECK (monthly_goal BETWEEN 10000 AND 9990000),
  level INTEGER NOT NULL DEFAULT 1 CHECK (level >= 1),
  total_xp INTEGER NOT NULL DEFAULT 0 CHECK (total_xp >= 0),
  current_streak INTEGER NOT NULL DEFAULT 0 CHECK (current_streak >= 0),
  longest_streak INTEGER NOT NULL DEFAULT 0 CHECK (longest_streak >= 0),
  is_premium BOOLEAN NOT NULL DEFAULT FALSE,
  premium_expires_at TIMESTAMPTZ,
  push_token TEXT,
  reminder_time TIME NOT NULL DEFAULT '21:00:00',
  delete_requested_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_profiles_nickname ON public.profiles(nickname);
CREATE INDEX idx_profiles_delete_requested ON public.profiles(delete_requested_at) WHERE delete_requested_at IS NOT NULL;

-- ============================================
-- 2. daily_records (일일 무지출/지출 기록)
-- ============================================
CREATE TABLE public.daily_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  record_date DATE NOT NULL,
  is_no_spend BOOLEAN NOT NULL,
  amount INTEGER NOT NULL DEFAULT 0 CHECK (amount BETWEEN 0 AND 9999999),
  memo TEXT CHECK (char_length(memo) <= 200),
  synced_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, record_date)
);

CREATE INDEX idx_daily_records_user_date ON public.daily_records(user_id, record_date DESC);
CREATE INDEX idx_daily_records_user_month ON public.daily_records(user_id, record_date)
  WHERE record_date >= date_trunc('month', CURRENT_DATE);

-- ============================================
-- 3. challenges (챌린지 정의)
-- ============================================
CREATE TABLE public.challenges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL CHECK (char_length(title) BETWEEN 2 AND 50),
  description TEXT NOT NULL CHECK (char_length(description) <= 500),
  challenge_type TEXT NOT NULL CHECK (challenge_type IN ('no_spend_days', 'spending_limit', 'custom')),
  duration_days INTEGER NOT NULL CHECK (duration_days BETWEEN 1 AND 365),
  target_value INTEGER NOT NULL CHECK (target_value > 0),
  badge_id UUID REFERENCES public.badge_definitions(id),
  xp_reward INTEGER NOT NULL DEFAULT 0 CHECK (xp_reward >= 0),
  is_official BOOLEAN NOT NULL DEFAULT TRUE,
  is_premium BOOLEAN NOT NULL DEFAULT FALSE,
  created_by UUID REFERENCES public.profiles(id),
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_challenges_active ON public.challenges(is_active, is_official);

-- ============================================
-- 4. challenge_participants (챌린지 참여)
-- ============================================
CREATE TABLE public.challenge_participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  challenge_id UUID NOT NULL REFERENCES public.challenges(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  joined_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  started_date DATE NOT NULL DEFAULT CURRENT_DATE,
  end_date DATE NOT NULL,
  progress INTEGER NOT NULL DEFAULT 0 CHECK (progress >= 0),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed', 'failed', 'abandoned')),
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(challenge_id, user_id)
);

CREATE INDEX idx_challenge_participants_user ON public.challenge_participants(user_id, status);
CREATE INDEX idx_challenge_participants_challenge ON public.challenge_participants(challenge_id, status);
CREATE INDEX idx_challenge_participants_ranking ON public.challenge_participants(challenge_id, progress DESC) WHERE status = 'active';

-- ============================================
-- 5. badge_definitions (배지 정의)
-- ============================================
CREATE TABLE public.badge_definitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE CHECK (char_length(name) BETWEEN 2 AND 30),
  description TEXT NOT NULL CHECK (char_length(description) <= 200),
  icon_url TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('streak', 'challenge', 'community', 'special')),
  condition_type TEXT NOT NULL CHECK (condition_type IN ('streak_days', 'challenge_complete', 'post_count', 'level_reach', 'custom')),
  condition_value INTEGER NOT NULL DEFAULT 0,
  xp_reward INTEGER NOT NULL DEFAULT 0 CHECK (xp_reward >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- 6. user_badges (사용자 배지 획득)
-- ============================================
CREATE TABLE public.user_badges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  badge_id UUID NOT NULL REFERENCES public.badge_definitions(id) ON DELETE CASCADE,
  earned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, badge_id)
);

CREATE INDEX idx_user_badges_user ON public.user_badges(user_id, earned_at DESC);

-- ============================================
-- 7. community_posts (커뮤니티 게시글)
-- ============================================
CREATE TABLE public.community_posts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL CHECK (char_length(content) BETWEEN 1 AND 500),
  image_urls TEXT[] DEFAULT '{}' CHECK (array_length(image_urls, 1) IS NULL OR array_length(image_urls, 1) <= 3),
  like_count INTEGER NOT NULL DEFAULT 0 CHECK (like_count >= 0),
  comment_count INTEGER NOT NULL DEFAULT 0 CHECK (comment_count >= 0),
  report_count INTEGER NOT NULL DEFAULT 0,
  is_hidden BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_community_posts_feed ON public.community_posts(created_at DESC) WHERE is_hidden = FALSE;
CREATE INDEX idx_community_posts_popular ON public.community_posts(like_count DESC, created_at DESC) WHERE is_hidden = FALSE;
CREATE INDEX idx_community_posts_user ON public.community_posts(user_id, created_at DESC);

-- ============================================
-- 8. post_likes (게시글 좋아요)
-- ============================================
CREATE TABLE public.post_likes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID NOT NULL REFERENCES public.community_posts(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(post_id, user_id)
);

CREATE INDEX idx_post_likes_post ON public.post_likes(post_id);

-- ============================================
-- 9. post_comments (게시글 댓글)
-- ============================================
CREATE TABLE public.post_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID NOT NULL REFERENCES public.community_posts(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL CHECK (char_length(content) BETWEEN 1 AND 200),
  report_count INTEGER NOT NULL DEFAULT 0,
  is_hidden BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_post_comments_post ON public.post_comments(post_id, created_at ASC);

-- ============================================
-- 10. reports (신고)
-- ============================================
CREATE TABLE public.reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reporter_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  target_type TEXT NOT NULL CHECK (target_type IN ('post', 'comment')),
  target_id UUID NOT NULL,
  reason TEXT NOT NULL CHECK (char_length(reason) <= 500),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'reviewed', 'resolved')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(reporter_id, target_type, target_id)
);

CREATE INDEX idx_reports_status ON public.reports(status, created_at DESC);

-- ============================================
-- 11. xp_levels (레벨 정의 - 시드 데이터)
-- ============================================
CREATE TABLE public.xp_levels (
  level INTEGER PRIMARY KEY CHECK (level >= 1),
  required_xp INTEGER NOT NULL CHECK (required_xp >= 0),
  title TEXT NOT NULL
);

-- 시드 데이터
INSERT INTO public.xp_levels (level, required_xp, title) VALUES
  (1, 0, '절약 새싹'),
  (2, 100, '절약 초보'),
  (3, 300, '절약 견습생'),
  (4, 600, '절약 수련생'),
  (5, 1000, '절약 숙련자'),
  (6, 1500, '절약 전문가'),
  (7, 2200, '절약 달인'),
  (8, 3000, '절약 고수'),
  (9, 4000, '절약 마스터'),
  (10, 5500, '절약 그랜드마스터');
```

#### updated_at 자동 갱신 트리거

```sql
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER trg_daily_records_updated_at
  BEFORE UPDATE ON public.daily_records
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER trg_challenge_participants_updated_at
  BEFORE UPDATE ON public.challenge_participants
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER trg_community_posts_updated_at
  BEFORE UPDATE ON public.community_posts
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
```

#### RLS 정책 (CRUD 권한 매트릭스)

| 테이블 | SELECT | INSERT | UPDATE | DELETE |
|--------|--------|--------|--------|--------|
| **profiles** | 본인만 (타인 공개 정보는 `get_public_profile` RPC 또는 `public_profiles` 뷰로 조회) | 자동 (auth trigger) | 본인만 | 불가 (soft delete) |
| **daily_records** | 본인만 | 본인만 | 본인만 (7일 이내) | 불가 |
| **challenges** | 모든 인증 사용자 | 프리미엄 사용자 (custom만) | 생성자만 (custom만) | 불가 |
| **challenge_participants** | 본인 + 동일 챌린지 참여자 | 본인만 | 본인만 (status 변경) | 불가 |
| **badge_definitions** | 모든 인증 사용자 | 관리자만 | 관리자만 | 관리자만 |
| **user_badges** | 본인 + 타인 (프로필 배지 공개) | 시스템만 (DB Function) | 불가 | 불가 |
| **community_posts** | 모든 인증 사용자 (is_hidden=false) | 모든 인증 사용자 | 작성자만 | 작성자만 |
| **post_likes** | 모든 인증 사용자 | 모든 인증 사용자 | 불가 | 본인만 |
| **post_comments** | 모든 인증 사용자 (is_hidden=false) | 모든 인증 사용자 | 작성자만 | 작성자만 |
| **reports** | 본인만 | 모든 인증 사용자 | 불가 | 불가 |

```sql
-- profiles RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "profiles_select_own" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "profiles_update_own" ON public.profiles
  FOR UPDATE USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);

-- 타 사용자의 공개 정보 조회용 뷰 (민감 필드 제외)
CREATE OR REPLACE VIEW public.public_profiles AS
SELECT
  id,
  nickname,
  level,
  total_xp,
  current_streak,
  longest_streak,
  created_at
FROM public.profiles
WHERE delete_requested_at IS NULL;

-- public_profiles 뷰에 RLS 없이 접근 가능하도록 설정
-- 뷰는 SECURITY INVOKER(기본값)이므로, 테이블 RLS를 우회하기 위해 SECURITY DEFINER 함수로 감싸거나
-- 별도의 RPC를 사용한다. 여기서는 RPC 방식을 채택:
CREATE OR REPLACE FUNCTION public.get_public_profile(p_user_id UUID)
RETURNS JSON AS $$
BEGIN
  RETURN (
    SELECT json_build_object(
      'id', id,
      'nickname', nickname,
      'level', level,
      'total_xp', total_xp,
      'current_streak', current_streak,
      'longest_streak', longest_streak,
      'created_at', created_at
    )
    FROM public.profiles
    WHERE id = p_user_id AND delete_requested_at IS NULL
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- daily_records RLS
ALTER TABLE public.daily_records ENABLE ROW LEVEL SECURITY;

CREATE POLICY "daily_records_select_own" ON public.daily_records
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "daily_records_insert_own" ON public.daily_records
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "daily_records_update_own" ON public.daily_records
  FOR UPDATE USING (
    auth.uid() = user_id
    AND record_date >= CURRENT_DATE - INTERVAL '7 days'
  );

-- challenges RLS
ALTER TABLE public.challenges ENABLE ROW LEVEL SECURITY;

CREATE POLICY "challenges_select_all" ON public.challenges
  FOR SELECT USING (is_active = TRUE);

CREATE POLICY "challenges_insert_premium" ON public.challenges
  FOR INSERT WITH CHECK (
    auth.uid() = created_by
    AND challenge_type = 'custom'
    AND EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_premium = TRUE)
  );

-- challenge_participants RLS
ALTER TABLE public.challenge_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "challenge_participants_select" ON public.challenge_participants
  FOR SELECT USING (
    auth.uid() = user_id
    OR challenge_id IN (
      SELECT challenge_id FROM public.challenge_participants WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "challenge_participants_insert_own" ON public.challenge_participants
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "challenge_participants_update_own" ON public.challenge_participants
  FOR UPDATE USING (auth.uid() = user_id);

-- badge_definitions RLS (공개 읽기)
ALTER TABLE public.badge_definitions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "badge_definitions_select_all" ON public.badge_definitions
  FOR SELECT USING (true);

-- user_badges RLS
ALTER TABLE public.user_badges ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_badges_select_all" ON public.user_badges
  FOR SELECT USING (true);

-- community_posts RLS
ALTER TABLE public.community_posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "community_posts_select_visible" ON public.community_posts
  FOR SELECT USING (is_hidden = FALSE);

CREATE POLICY "community_posts_insert_auth" ON public.community_posts
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "community_posts_update_own" ON public.community_posts
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "community_posts_delete_own" ON public.community_posts
  FOR DELETE USING (auth.uid() = user_id);

-- post_likes RLS
ALTER TABLE public.post_likes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "post_likes_select_all" ON public.post_likes
  FOR SELECT USING (true);

CREATE POLICY "post_likes_insert_auth" ON public.post_likes
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "post_likes_delete_own" ON public.post_likes
  FOR DELETE USING (auth.uid() = user_id);

-- post_comments RLS
ALTER TABLE public.post_comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "post_comments_select_visible" ON public.post_comments
  FOR SELECT USING (is_hidden = FALSE);

CREATE POLICY "post_comments_insert_auth" ON public.post_comments
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "post_comments_update_own" ON public.post_comments
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "post_comments_delete_own" ON public.post_comments
  FOR DELETE USING (auth.uid() = user_id);

-- reports RLS
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

CREATE POLICY "reports_select_own" ON public.reports
  FOR SELECT USING (auth.uid() = reporter_id);

CREATE POLICY "reports_insert_auth" ON public.reports
  FOR INSERT WITH CHECK (auth.uid() = reporter_id);
```

#### 핵심 DB Function (RPC) — 완전한 SQL 본문

```sql
-- ============================================
-- RPC 1: 일일 기록 저장 + 스트릭 갱신
-- ============================================
CREATE OR REPLACE FUNCTION public.upsert_daily_record(
  p_record_date DATE,
  p_is_no_spend BOOLEAN,
  p_amount INTEGER DEFAULT 0,
  p_memo TEXT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_prev_date DATE;
  v_prev_is_no_spend BOOLEAN;
  v_current_streak INTEGER;
  v_longest_streak INTEGER;
  v_new_streak INTEGER;
  v_record daily_records;
  v_xp_earned INTEGER := 0;
  v_new_badges UUID[] := '{}';
  v_badge RECORD;
BEGIN
  -- 1. 소급 입력 제한 검증 (7일)
  IF p_record_date < CURRENT_DATE - INTERVAL '7 days' THEN
    RAISE EXCEPTION 'Cannot record more than 7 days in the past';
  END IF;
  IF p_record_date > CURRENT_DATE THEN
    RAISE EXCEPTION 'Cannot record future dates';
  END IF;

  -- 2. 일일 기록 UPSERT
  INSERT INTO public.daily_records (user_id, record_date, is_no_spend, amount, memo, synced_at)
  VALUES (v_user_id, p_record_date, p_is_no_spend, p_amount, p_memo, now())
  ON CONFLICT (user_id, record_date)
  DO UPDATE SET
    is_no_spend = EXCLUDED.is_no_spend,
    amount = EXCLUDED.amount,
    memo = EXCLUDED.memo,
    synced_at = now(),
    updated_at = now()
  RETURNING * INTO v_record;

  -- 3. 스트릭 재계산 (오늘 기준으로 연속 무지출 일수)
  IF p_is_no_spend THEN
    v_new_streak := 0;
    FOR v_prev_date IN
      SELECT record_date FROM public.daily_records
      WHERE user_id = v_user_id AND record_date <= CURRENT_DATE
      ORDER BY record_date DESC
    LOOP
      IF v_prev_date = CURRENT_DATE - v_new_streak AND
         (SELECT is_no_spend FROM public.daily_records WHERE user_id = v_user_id AND record_date = v_prev_date) = TRUE
      THEN
        v_new_streak := v_new_streak + 1;
      ELSE
        EXIT;
      END IF;
    END LOOP;
  ELSE
    v_new_streak := 0;
  END IF;

  -- 4. 프로필 스트릭 업데이트
  SELECT longest_streak INTO v_longest_streak FROM public.profiles WHERE id = v_user_id;

  UPDATE public.profiles SET
    current_streak = v_new_streak,
    longest_streak = GREATEST(v_longest_streak, v_new_streak),
    updated_at = now()
  WHERE id = v_user_id;

  -- 5. 무지출 시 경험치 부여 (10 XP)
  IF p_is_no_spend THEN
    v_xp_earned := 10;
    UPDATE public.profiles SET
      total_xp = total_xp + v_xp_earned,
      updated_at = now()
    WHERE id = v_user_id;
  END IF;

  -- 6. 스트릭 배지 확인 및 부여
  FOR v_badge IN
    SELECT id, condition_value, xp_reward FROM public.badge_definitions
    WHERE category = 'streak'
      AND condition_type = 'streak_days'
      AND condition_value <= v_new_streak
      AND id NOT IN (SELECT badge_id FROM public.user_badges WHERE user_id = v_user_id)
  LOOP
    INSERT INTO public.user_badges (user_id, badge_id)
    VALUES (v_user_id, v_badge.id)
    ON CONFLICT DO NOTHING;

    IF FOUND THEN
      v_new_badges := array_append(v_new_badges, v_badge.id);
      v_xp_earned := v_xp_earned + v_badge.xp_reward;
      UPDATE public.profiles SET total_xp = total_xp + v_badge.xp_reward WHERE id = v_user_id;
    END IF;
  END LOOP;

  -- 7. 레벨 갱신
  UPDATE public.profiles SET
    level = COALESCE(
      (SELECT MAX(level) FROM public.xp_levels WHERE required_xp <= (SELECT total_xp FROM public.profiles WHERE id = v_user_id)),
      1
    )
  WHERE id = v_user_id;

  -- 8. 결과 반환
  RETURN json_build_object(
    'record', row_to_json(v_record),
    'current_streak', v_new_streak,
    'longest_streak', GREATEST(v_longest_streak, v_new_streak),
    'xp_earned', v_xp_earned,
    'new_badges', v_new_badges
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC 2: 월간 요약 통계 조회
-- ============================================
CREATE OR REPLACE FUNCTION public.get_monthly_summary(
  p_year INTEGER,
  p_month INTEGER
)
RETURNS JSON AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_start_date DATE;
  v_end_date DATE;
  v_no_spend_days INTEGER;
  v_spend_days INTEGER;
  v_total_amount BIGINT;
  v_avg_daily_amount NUMERIC;
  v_total_days INTEGER;
  v_recorded_days INTEGER;
BEGIN
  v_start_date := make_date(p_year, p_month, 1);
  v_end_date := (v_start_date + INTERVAL '1 month' - INTERVAL '1 day')::DATE;

  -- 해당 월이 미래인 경우 오늘까지만
  IF v_end_date > CURRENT_DATE THEN
    v_end_date := CURRENT_DATE;
  END IF;

  v_total_days := v_end_date - v_start_date + 1;

  SELECT
    COALESCE(SUM(CASE WHEN is_no_spend THEN 1 ELSE 0 END), 0),
    COALESCE(SUM(CASE WHEN NOT is_no_spend THEN 1 ELSE 0 END), 0),
    COALESCE(SUM(amount), 0),
    COUNT(*)
  INTO v_no_spend_days, v_spend_days, v_total_amount, v_recorded_days
  FROM public.daily_records
  WHERE user_id = v_user_id
    AND record_date BETWEEN v_start_date AND v_end_date;

  v_avg_daily_amount := CASE
    WHEN v_spend_days > 0 THEN ROUND(v_total_amount::NUMERIC / v_spend_days, 0)
    ELSE 0
  END;

  RETURN json_build_object(
    'year', p_year,
    'month', p_month,
    'total_days', v_total_days,
    'recorded_days', v_recorded_days,
    'no_spend_days', v_no_spend_days,
    'spend_days', v_spend_days,
    'total_amount', v_total_amount,
    'avg_daily_amount', v_avg_daily_amount,
    'no_spend_rate', CASE
      WHEN v_recorded_days > 0 THEN ROUND(v_no_spend_days::NUMERIC / v_recorded_days * 100, 1)
      ELSE 0
    END
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC 3: 챌린지 참여 처리
-- ============================================
CREATE OR REPLACE FUNCTION public.join_challenge(
  p_challenge_id UUID
)
RETURNS JSON AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_challenge challenges;
  v_active_count INTEGER;
  v_participant challenge_participants;
BEGIN
  -- 1. 챌린지 존재 및 활성 확인
  SELECT * INTO v_challenge FROM public.challenges
  WHERE id = p_challenge_id AND is_active = TRUE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Challenge not found or inactive';
  END IF;

  -- 2. 프리미엄 전용 챌린지 검증
  IF v_challenge.is_premium THEN
    IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_user_id AND is_premium = TRUE) THEN
      RAISE EXCEPTION 'Premium subscription required';
    END IF;
  END IF;

  -- 3. 동시 참여 제한 (최대 3개)
  SELECT COUNT(*) INTO v_active_count
  FROM public.challenge_participants
  WHERE user_id = v_user_id AND status = 'active';

  IF v_active_count >= 3 THEN
    RAISE EXCEPTION 'Maximum 3 active challenges allowed';
  END IF;

  -- 4. 이미 참여 중인지 확인
  IF EXISTS (
    SELECT 1 FROM public.challenge_participants
    WHERE challenge_id = p_challenge_id AND user_id = v_user_id AND status = 'active'
  ) THEN
    RAISE EXCEPTION 'Already participating in this challenge';
  END IF;

  -- 5. 참여 등록
  INSERT INTO public.challenge_participants (
    challenge_id, user_id, started_date, end_date
  ) VALUES (
    p_challenge_id, v_user_id, CURRENT_DATE, CURRENT_DATE + v_challenge.duration_days - 1
  )
  RETURNING * INTO v_participant;

  RETURN json_build_object(
    'participant', row_to_json(v_participant),
    'challenge', row_to_json(v_challenge)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC 4: 챌린지 진행률 갱신 (일일 기록 후 호출)
-- ============================================
CREATE OR REPLACE FUNCTION public.update_challenge_progress()
RETURNS JSON AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_participant RECORD;
  v_progress INTEGER;
  v_completed_challenges UUID[] := '{}';
  v_xp_earned INTEGER := 0;
  v_badge RECORD;
BEGIN
  FOR v_participant IN
    SELECT cp.*, c.challenge_type, c.target_value, c.xp_reward, c.badge_id
    FROM public.challenge_participants cp
    JOIN public.challenges c ON c.id = cp.challenge_id
    WHERE cp.user_id = v_user_id AND cp.status = 'active'
  LOOP
    -- 챌린지 타입별 진행률 계산
    CASE v_participant.challenge_type
      WHEN 'no_spend_days' THEN
        SELECT COUNT(*) INTO v_progress
        FROM public.daily_records
        WHERE user_id = v_user_id
          AND is_no_spend = TRUE
          AND record_date BETWEEN v_participant.started_date AND LEAST(v_participant.end_date, CURRENT_DATE);
      WHEN 'spending_limit' THEN
        SELECT COALESCE(SUM(amount), 0) INTO v_progress
        FROM public.daily_records
        WHERE user_id = v_user_id
          AND record_date BETWEEN v_participant.started_date AND LEAST(v_participant.end_date, CURRENT_DATE);
        -- spending_limit의 경우 target_value 이하면 성공이므로 progress = target_value - actual
        v_progress := GREATEST(v_participant.target_value - v_progress, 0);
      ELSE
        v_progress := v_participant.progress;
    END CASE;

    -- 진행률 업데이트
    UPDATE public.challenge_participants SET
      progress = v_progress,
      updated_at = now()
    WHERE id = v_participant.id;

    -- 완료 판정: no_spend_days — 목표 무지출 일수 달성 시 즉시 완료
    IF v_participant.challenge_type = 'no_spend_days' AND v_progress >= v_participant.target_value THEN
      UPDATE public.challenge_participants SET
        status = 'completed',
        completed_at = now()
      WHERE id = v_participant.id;

      v_completed_challenges := array_append(v_completed_challenges, v_participant.challenge_id);
      v_xp_earned := v_xp_earned + v_participant.xp_reward;

      -- XP 부여
      UPDATE public.profiles SET total_xp = total_xp + v_participant.xp_reward WHERE id = v_user_id;

      -- 배지 부여
      IF v_participant.badge_id IS NOT NULL THEN
        INSERT INTO public.user_badges (user_id, badge_id)
        VALUES (v_user_id, v_participant.badge_id)
        ON CONFLICT DO NOTHING;
      END IF;

    -- 완료 판정: spending_limit — 기간 종료 시 총 지출이 target_value 이하이면 성공
    ELSIF v_participant.challenge_type = 'spending_limit' AND CURRENT_DATE >= v_participant.end_date THEN
      DECLARE
        v_actual_spending INTEGER;
      BEGIN
        SELECT COALESCE(SUM(amount), 0) INTO v_actual_spending
        FROM public.daily_records
        WHERE user_id = v_user_id
          AND record_date BETWEEN v_participant.started_date AND v_participant.end_date;

        IF v_actual_spending <= v_participant.target_value THEN
          -- 목표 이하 지출: 성공
          UPDATE public.challenge_participants SET
            status = 'completed',
            completed_at = now()
          WHERE id = v_participant.id;

          v_completed_challenges := array_append(v_completed_challenges, v_participant.challenge_id);
          v_xp_earned := v_xp_earned + v_participant.xp_reward;

          UPDATE public.profiles SET total_xp = total_xp + v_participant.xp_reward WHERE id = v_user_id;

          IF v_participant.badge_id IS NOT NULL THEN
            INSERT INTO public.user_badges (user_id, badge_id)
            VALUES (v_user_id, v_participant.badge_id)
            ON CONFLICT DO NOTHING;
          END IF;
        ELSE
          -- 목표 초과 지출: 실패
          UPDATE public.challenge_participants SET
            status = 'failed'
          WHERE id = v_participant.id;
        END IF;
      END;
    END IF;

    -- 기간 만료 판정 (no_spend_days 타입 전용: 기간 내 목표 미달성 시 실패)
    IF v_participant.challenge_type = 'no_spend_days'
       AND CURRENT_DATE > v_participant.end_date
       AND (SELECT status FROM public.challenge_participants WHERE id = v_participant.id) = 'active' THEN
      UPDATE public.challenge_participants SET status = 'failed' WHERE id = v_participant.id;
    END IF;
  END LOOP;

  -- 레벨 갱신
  IF v_xp_earned > 0 THEN
    UPDATE public.profiles SET
      level = COALESCE(
        (SELECT MAX(level) FROM public.xp_levels WHERE required_xp <= (SELECT total_xp FROM public.profiles WHERE id = v_user_id)),
        1
      )
    WHERE id = v_user_id;
  END IF;

  RETURN json_build_object(
    'completed_challenges', v_completed_challenges,
    'xp_earned', v_xp_earned
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC 5: 좋아요 토글
-- ============================================
CREATE OR REPLACE FUNCTION public.toggle_post_like(
  p_post_id UUID
)
RETURNS JSON AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_liked BOOLEAN;
BEGIN
  -- 이미 좋아요했으면 취소
  IF EXISTS (SELECT 1 FROM public.post_likes WHERE post_id = p_post_id AND user_id = v_user_id) THEN
    DELETE FROM public.post_likes WHERE post_id = p_post_id AND user_id = v_user_id;
    UPDATE public.community_posts SET like_count = like_count - 1 WHERE id = p_post_id;
    v_liked := FALSE;
  ELSE
    INSERT INTO public.post_likes (post_id, user_id) VALUES (p_post_id, v_user_id);
    UPDATE public.community_posts SET like_count = like_count + 1 WHERE id = p_post_id;
    v_liked := TRUE;
  END IF;

  RETURN json_build_object(
    'post_id', p_post_id,
    'liked', v_liked,
    'like_count', (SELECT like_count FROM public.community_posts WHERE id = p_post_id)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC 6: 프로필 생성 (Auth 트리거에서 호출)
-- ============================================
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, nickname, monthly_goal)
  VALUES (
    NEW.id,
    '절약러' || substr(NEW.id::TEXT, 1, 4),
    500000
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

### 7-6. API 설계

#### Supabase REST vs Edge Function 선택 기준

| 기준 | Supabase REST (PostgREST) | Edge Function (Deno) |
|------|--------------------------|---------------------|
| 단순 CRUD | O — RLS만으로 보안 충족 | X |
| 복합 비즈니스 로직 | X | O — 다단계 검증, 외부 API 호출 |
| 트랜잭션 필요 | DB Function(RPC)으로 처리 | O — 여러 서비스 조합 |
| 외부 서비스 호출 | X | O — RevenueCat, Push Service |

#### 엔드포인트 목록

| 경로 | 메서드 | 설명 | 구현 방식 |
|------|--------|------|-----------|
| `/rest/v1/profiles` | GET | 내 프로필 조회 | REST + RLS |
| `/rest/v1/profiles` | PATCH | 프로필 수정 (닉네임, 목표금액) | REST + RLS |
| `/rest/v1/rpc/get_public_profile` | POST | 타 사용자 공개 프로필 조회 (닉네임, 레벨, 스트릭만) | DB Function (RPC, SECURITY DEFINER) |
| `/rest/v1/rpc/upsert_daily_record` | POST | 일일 기록 저장 + 스트릭 갱신 | DB Function (RPC) |
| `/rest/v1/rpc/get_monthly_summary` | POST | 월간 요약 통계 | DB Function (RPC) |
| `/rest/v1/daily_records` | GET | 월별 일일 기록 목록 | REST + RLS (필터: record_date) |
| `/rest/v1/challenges` | GET | 챌린지 목록 조회 | REST + RLS |
| `/rest/v1/rpc/join_challenge` | POST | 챌린지 참여 | DB Function (RPC) |
| `/rest/v1/rpc/update_challenge_progress` | POST | 챌린지 진행률 갱신 | DB Function (RPC) |
| `/rest/v1/challenge_participants` | GET | 내 챌린지 참여 현황 | REST + RLS |
| `/rest/v1/badge_definitions` | GET | 배지 목록 조회 | REST + RLS |
| `/rest/v1/user_badges` | GET | 내 배지 목록 | REST + RLS |
| `/rest/v1/community_posts` | GET | 커뮤니티 피드 조회 | REST + RLS (정렬: created_at/like_count) |
| `/rest/v1/community_posts` | POST | 게시글 작성 | REST + RLS |
| `/rest/v1/community_posts` | DELETE | 게시글 삭제 | REST + RLS |
| `/rest/v1/rpc/toggle_post_like` | POST | 좋아요 토글 | DB Function (RPC) |
| `/rest/v1/post_comments` | GET | 댓글 목록 | REST + RLS |
| `/rest/v1/post_comments` | POST | 댓글 작성 | REST + RLS |
| `/rest/v1/reports` | POST | 신고 접수 | REST + RLS |
| `/functions/v1/complete-onboarding` | POST | 온보딩 완료 (닉네임+목표 설정) | Edge Function |
| `/functions/v1/delete-account` | POST | 계정 탈퇴 요청 | Edge Function |
| `/functions/v1/verify-premium` | POST | RevenueCat 구독 상태 동기화 | Edge Function |
| `/functions/v1/upload-post-image` | POST | 게시글 이미지 업로드 | Edge Function |
| `/functions/v1/send-reminder` | POST | 리마인더 푸시 발송 (Cron 호출) | Edge Function |

#### 핵심 TypeScript 인터페이스

```typescript
// ============================================
// 공통 타입
// ============================================
interface ApiResponse<T> {
  data: T | null;
  error: { message: string; code: string } | null;
}

// ============================================
// 프로필
// ============================================
interface Profile {
  id: string;
  nickname: string;
  monthly_goal: number;
  level: number;
  total_xp: number;
  current_streak: number;
  longest_streak: number;
  is_premium: boolean;
  premium_expires_at: string | null;
  reminder_time: string;
  created_at: string;
  updated_at: string;
}

interface UpdateProfileRequest {
  nickname?: string;
  monthly_goal?: number;
  reminder_time?: string;
  push_token?: string;
}

// 타 사용자 공개 프로필 (민감 필드 제외)
interface PublicProfile {
  id: string;
  nickname: string;
  level: number;
  total_xp: number;
  current_streak: number;
  longest_streak: number;
  created_at: string;
}

interface GetPublicProfileRequest {
  p_user_id: string;
}

// ============================================
// 일일 기록
// ============================================
interface DailyRecord {
  id: string;
  user_id: string;
  record_date: string; // 'YYYY-MM-DD'
  is_no_spend: boolean;
  amount: number;
  memo: string | null;
  created_at: string;
  updated_at: string;
}

interface UpsertDailyRecordRequest {
  p_record_date: string; // 'YYYY-MM-DD'
  p_is_no_spend: boolean;
  p_amount?: number;
  p_memo?: string;
}

interface UpsertDailyRecordResponse {
  record: DailyRecord;
  current_streak: number;
  longest_streak: number;
  xp_earned: number;
  new_badges: string[]; // badge_id[]
}

// ============================================
// 월간 요약
// ============================================
interface GetMonthlySummaryRequest {
  p_year: number;
  p_month: number;
}

interface MonthlySummary {
  year: number;
  month: number;
  total_days: number;
  recorded_days: number;
  no_spend_days: number;
  spend_days: number;
  total_amount: number;
  avg_daily_amount: number;
  no_spend_rate: number;
}

// ============================================
// 챌린지
// ============================================
interface Challenge {
  id: string;
  title: string;
  description: string;
  challenge_type: 'no_spend_days' | 'spending_limit' | 'custom';
  duration_days: number;
  target_value: number;
  badge_id: string | null;
  xp_reward: number;
  is_official: boolean;
  is_premium: boolean;
  is_active: boolean;
  created_at: string;
}

interface ChallengeParticipant {
  id: string;
  challenge_id: string;
  user_id: string;
  started_date: string;
  end_date: string;
  progress: number;
  status: 'active' | 'completed' | 'failed' | 'abandoned';
  completed_at: string | null;
}

interface JoinChallengeRequest {
  p_challenge_id: string;
}

interface JoinChallengeResponse {
  participant: ChallengeParticipant;
  challenge: Challenge;
}

// ============================================
// 배지
// ============================================
interface BadgeDefinition {
  id: string;
  name: string;
  description: string;
  icon_url: string;
  category: 'streak' | 'challenge' | 'community' | 'special';
  condition_type: string;
  condition_value: number;
  xp_reward: number;
}

interface UserBadge {
  id: string;
  user_id: string;
  badge_id: string;
  earned_at: string;
}

// ============================================
// 커뮤니티
// ============================================
interface CommunityPost {
  id: string;
  user_id: string;
  content: string;
  image_urls: string[];
  like_count: number;
  comment_count: number;
  created_at: string;
  // JOIN으로 가져오는 필드
  author_nickname?: string;
  author_level?: number;
  is_liked?: boolean;
}

interface CreatePostRequest {
  content: string;
  image_urls?: string[];
}

interface PostComment {
  id: string;
  post_id: string;
  user_id: string;
  content: string;
  created_at: string;
  author_nickname?: string;
}

interface CreateCommentRequest {
  post_id: string;
  content: string;
}

interface ToggleLikeResponse {
  post_id: string;
  liked: boolean;
  like_count: number;
}

// ============================================
// 온보딩
// ============================================
interface CompleteOnboardingRequest {
  nickname: string;
  monthly_goal: number;
  push_token?: string;
}

// ============================================
// 계정 탈퇴
// ============================================
interface DeleteAccountRequest {
  confirmation: 'DELETE';
}

// ============================================
// 이미지 업로드
// ============================================
interface UploadPostImageResponse {
  url: string;
  path: string;
}
```

#### Edge Function 비즈니스 로직 상세

**1. `complete-onboarding`**
```
1. 요청에서 nickname, monthly_goal, push_token 추출
2. 닉네임 유효성 검증 (2~10자, 금칙어 필터)
3. monthly_goal 범위 검증 (10,000~9,990,000)
4. profiles 테이블 UPDATE (닉네임, 목표금액, 푸시 토큰)
5. 초기 배지 '절약 새싹' 부여 (user_badges INSERT)
6. 성공 응답 반환
```

**2. `delete-account`**
```
1. confirmation === 'DELETE' 검증
2. profiles.delete_requested_at = now() 업데이트
3. MMKV/로컬 데이터 삭제 안내 플래그 반환
4. (30일 후 Cron Job이 실제 삭제 수행)
   - auth.users에서 사용자 삭제 → CASCADE로 모든 데이터 제거
```

**3. `verify-premium`**
```
1. RevenueCat REST API 호출 (GET /subscribers/{app_user_id})
2. 구독 상태 확인 (active/expired/cancelled)
3. profiles.is_premium, premium_expires_at 업데이트
4. 구독 상태 반환
```

**4. `upload-post-image`**
```
1. multipart/form-data에서 이미지 파일 추출
2. 파일 크기 검증 (최대 5MB)
3. 파일 타입 검증 (JPEG, PNG, WebP만 허용)
4. Supabase Storage에 업로드 (경로: posts/{user_id}/{uuid}.{ext})
5. 공개 URL 생성 및 반환
```

**5. `send-reminder` (Cron: 매 정시 실행)**
```
1. 현재 KST 시(hour)에 해당하는 사용자 목록 조회
   SELECT id, push_token FROM profiles
   WHERE reminder_time의 시(hour) = 현재 KST 시
   AND push_token IS NOT NULL
   AND delete_requested_at IS NULL
2. 오늘 이미 인증한 사용자 제외
   LEFT JOIN daily_records (record_date = TODAY)
   WHERE daily_records.id IS NULL
3. Expo Push API로 배치 발송
   - 제목: "오늘도 무지출! 🎯"
   - 본문: "오늘 지출 기록을 남겨보세요. 스트릭을 이어가세요!"
4. 발송 결과 로깅
```

### 7-7. 상태 관리 구조 (Zustand)

#### Store 목록

**1. AuthStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| `session` | `Session \| null` | Supabase 세션 (JWT 토큰 포함) |
| `profile` | `Profile \| null` | 사용자 프로필 정보 |
| `isLoading` | `boolean` | 인증 상태 로딩 중 |
| `isOnboarded` | `boolean` | 온보딩 완료 여부 (MMKV persist) |
| `signIn()` | `function` | 소셜 로그인 실행 |
| `signOut()` | `function` | 로그아웃 |
| `updateProfile()` | `function` | 프로필 수정 |
| `deleteAccount()` | `function` | 계정 탈퇴 요청 |

**2. RecordStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| `todayRecord` | `DailyRecord \| null` | 오늘의 기록 |
| `monthlyRecords` | `Map<string, DailyRecord>` | 현재 보고 있는 월의 기록 (key: YYYY-MM-DD) |
| `currentStreak` | `number` | 현재 스트릭 |
| `longestStreak` | `number` | 최장 스트릭 |
| `monthlySummary` | `MonthlySummary \| null` | 월간 요약 통계 |
| `isSubmitting` | `boolean` | 인증 제출 중 |
| `submitRecord()` | `function` | 일일 기록 저장 (로컬 → 서버) |
| `fetchMonthlyRecords()` | `function` | 월별 기록 조회 |
| `fetchMonthlySummary()` | `function` | 월간 요약 조회 |

**3. ChallengeStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| `availableChallenges` | `Challenge[]` | 참여 가능한 챌린지 목록 |
| `myParticipations` | `ChallengeParticipant[]` | 내 참여 중인 챌린지 |
| `selectedChallenge` | `Challenge \| null` | 상세 보기 중인 챌린지 |
| `isLoading` | `boolean` | 로딩 상태 |
| `fetchChallenges()` | `function` | 챌린지 목록 조회 |
| `joinChallenge()` | `function` | 챌린지 참여 |
| `abandonChallenge()` | `function` | 챌린지 포기 |

**4. CommunityStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| `posts` | `CommunityPost[]` | 피드 게시글 목록 |
| `sortBy` | `'latest' \| 'popular'` | 정렬 기준 |
| `hasMore` | `boolean` | 추가 로드 가능 여부 |
| `isLoading` | `boolean` | 로딩 상태 |
| `selectedPost` | `CommunityPost \| null` | 상세 보기 중인 게시글 |
| `comments` | `PostComment[]` | 선택된 게시글의 댓글 |
| `fetchPosts()` | `function` | 피드 조회 (페이지네이션) |
| `createPost()` | `function` | 게시글 작성 |
| `toggleLike()` | `function` | 좋아요 토글 |
| `addComment()` | `function` | 댓글 작성 |
| `reportContent()` | `function` | 신고 |

**5. BadgeStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| `allBadges` | `BadgeDefinition[]` | 전체 배지 목록 |
| `myBadges` | `UserBadge[]` | 내가 획득한 배지 |
| `newBadgeQueue` | `string[]` | 새로 획득한 배지 ID 큐 (팝업 표시용) |
| `fetchBadges()` | `function` | 배지 목록 조회 |
| `showNextBadge()` | `function` | 큐에서 다음 배지 팝업 표시 |

**6. SyncStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| `isOnline` | `boolean` | 네트워크 연결 상태 |
| `pendingCount` | `number` | 동기화 대기 중인 항목 수 |
| `isSyncing` | `boolean` | 동기화 진행 중 |
| `lastSyncAt` | `string \| null` | 마지막 동기화 시각 |
| `processQueue()` | `function` | 동기화 큐 처리 |

### 7-8. 기능-테이블-API 매핑표

| P0 기능 | 관련 테이블 | 관련 API | 비고 |
|---------|------------|---------|------|
| **FR-01: 소셜 로그인 & 온보딩** | `auth.users`, `profiles` | Supabase Auth (OAuth), `POST /functions/v1/complete-onboarding` | Auth 트리거로 profiles 자동 생성 |
| **FR-02: 무지출 인증 (원탭)** | `daily_records`, `profiles` (스트릭), `user_badges`, `xp_levels` | `POST /rest/v1/rpc/upsert_daily_record`, `POST /rest/v1/rpc/update_challenge_progress` | RPC 내부에서 스트릭+배지+XP 처리 |
| **FR-03: 무지출 캘린더** | `daily_records` | `GET /rest/v1/daily_records` (필터: user_id, record_date), `POST /rest/v1/rpc/get_monthly_summary` | 월별 필터 쿼리 |
| **FR-04: 스트릭 시스템** | `profiles` (current_streak, longest_streak), `daily_records` | `POST /rest/v1/rpc/upsert_daily_record` (내부 처리), `GET /rest/v1/profiles` | 스트릭은 upsert_daily_record RPC에서 자동 계산 |
| **FR-05: 공식 챌린지 참여** | `challenges`, `challenge_participants`, `user_badges` | `GET /rest/v1/challenges`, `POST /rest/v1/rpc/join_challenge`, `GET /rest/v1/challenge_participants` | 참여/진행률/달성 모두 RPC 처리 |
| **FR-06: 배지 & 레벨** | `badge_definitions`, `user_badges`, `xp_levels`, `profiles` (level, total_xp) | `GET /rest/v1/badge_definitions`, `GET /rest/v1/user_badges` | 배지 지급은 서버 RPC 내부에서만 수행 |
| **FR-07: 절약방 (커뮤니티)** | `community_posts`, `post_likes`, `post_comments`, `reports` | `GET/POST/DELETE /rest/v1/community_posts`, `POST /rest/v1/rpc/toggle_post_like`, `GET/POST /rest/v1/post_comments`, `POST /rest/v1/reports`, `POST /functions/v1/upload-post-image` | 이미지는 Edge Function, 나머지 REST |
| **FR-08: 일일 리마인더 알림** | `profiles` (push_token, reminder_time), `daily_records` | `POST /functions/v1/send-reminder` (Cron), `PATCH /rest/v1/profiles` (시간 변경) | expo-notifications 로컬 + 서버 발송 |
| **FR-09: 계정 관리** | `profiles` | `PATCH /rest/v1/profiles`, `POST /functions/v1/delete-account` | 탈퇴는 Edge Function, 프로필 수정은 REST |

### 7-9. 자체 점검 결과

| # | 점검 항목 | 결과 | 비고 |
|---|----------|------|------|
| 1 | 모든 P0 기능에 AC-XX-X 수용 기준 존재 | PASS | FR-01~FR-09 모두 AC 작성 완료 |
| 2 | P0 기능별 DB 테이블·API 매핑표 존재 | PASS | 섹션 7-8에 전체 매핑 완료 |
| 3 | DB 스키마 FK 관계가 데이터 흐름과 일치 | PASS | profiles→daily_records, challenges→participants, posts→likes/comments 정합성 확인 |
| 4 | API 엔드포인트가 P0 수용 기준 충족 가능 | PASS | 각 AC의 기능이 대응 API로 구현 가능 확인 |
| 5 | 핵심 API TypeScript 인터페이스 존재 | PASS | 섹션 7-6에 전체 인터페이스 작성 완료 |
| 6 | 핵심 DB Function SQL 본문 완성 | PASS | 7개 RPC 모두 완전한 SQL 작성 (스텁 아님). v1.1에서 get_public_profile RPC 추가, update_challenge_progress에 spending_limit 완료 판정 로직 보완 |
| 7 | 오프라인 저장소·동기화·충돌 해결 정책 명시 | PASS | 섹션 7-3에 MMKV/op-sqlite 역할분담, SyncQueue, Server Wins 정책 명시 |
| 8 | 네비게이션 구조 트리 + 핵심 화면 UI 존재 | — | 섹션 8에서 작성 예정 |
| 9 | User Story가 모든 기능 영역 커버 | PASS | 온보딩·인증·핵심·설정·결제 8개 Epic 24개 Story |

---

## 8. Screen Map & UI 명세

### 8.1 네비게이션 구조 트리

```
App Root (Expo Router)
├── (auth)                          ← Auth Stack (미인증 사용자)
│   ├── login                       ← 로그인 화면
│   └── onboarding                  ← 온보딩 화면 (닉네임 + 목표 설정)
│
├── (main)                          ← Main Tab Navigator (인증 사용자)
│   ├── (home)                      ← 홈 탭
│   │   └── index                   ← 홈 화면 (무지출 인증 + 스트릭)
│   │
│   ├── (calendar)                  ← 캘린더 탭
│   │   └── index                   ← 무지출 캘린더 화면
│   │
│   ├── (challenge)                 ← 챌린지 탭
│   │   ├── index                   ← 챌린지 목록 화면
│   │   └── [id]                    ← 챌린지 상세 화면
│   │
│   ├── (community)                 ← 커뮤니티 탭
│   │   ├── index                   ← 절약방 피드 화면
│   │   └── [id]                    ← 게시글 상세 화면
│   │
│   └── (profile)                   ← 프로필 탭
│       ├── index                   ← 프로필/설정 화면
│       └── badges                  ← 배지함 화면
│
├── Modal Stack                     ← 모달
│   ├── record-input                ← 지출 금액 입력 모달
│   ├── create-post                 ← 게시글 작성 모달
│   ├── badge-earned                ← 배지 획득 축하 모달
│   ├── premium                     ← 프리미엄 구독 화면
│   └── report                      ← 신고 모달
```

### 8.2 핵심 화면별 UI 구성

#### 화면 1: 로그인 (login)

| 영역 | 구성 요소 |
|------|----------|
| 상단 (30%) | 앱 로고 + 캐치프레이즈 "오늘도 무지출!" |
| 중앙 (40%) | 일러스트레이션 (절약 관련 Lottie 애니메이션) |
| 하단 (30%) | 카카오 로그인 버튼 (노란색, 최상단), 구글 로그인 버튼, 애플 로그인 버튼 |
| **데이터** | 없음 |
| **API** | Supabase Auth (signInWithOAuth) |

#### 화면 2: 온보딩 (onboarding)

| 영역 | 구성 요소 |
|------|----------|
| 상단 | 진행률 표시 (Step 1/2) |
| Step 1 | 닉네임 입력 TextInput (2~10자), "어떤 이름으로 불러드릴까요?" |
| Step 2 | 월 절약 목표금액 슬라이더 (10만~500만, 10만 단위) + 직접 입력, "매달 얼마를 절약하고 싶으세요?" |
| 하단 | "시작하기" CTA 버튼 (Primary), 알림 권한 요청 다이얼로그 |
| **데이터** | nickname, monthly_goal |
| **API** | `POST /functions/v1/complete-onboarding` |

#### 화면 3: 홈 (home/index) — 핵심 화면

| 영역 | 구성 요소 |
|------|----------|
| 상단 바 | 닉네임 + 레벨 배지, 알림 아이콘 |
| 상단 카드 | 현재 스트릭 (큰 숫자 + 불꽃 아이콘), 최장 스트릭 (작은 텍스트) |
| 중앙 (핵심) | **무지출 인증 메인 버튼** (원형, 큰 사이즈). 미인증 시: "오늘 무지출!" (탭 가능). 인증 완료 시: 체크마크 + "인증 완료!" (수정 가능) |
| 중앙 하단 | "지출 있었어요" 텍스트 버튼 → record-input 모달 열기 |
| 하단 카드 | 오늘의 미니 캘린더 (최근 7일), 참여 중인 챌린지 진행률 (최대 3개 프로그레스 바) |
| **데이터** | todayRecord, currentStreak, longestStreak, myParticipations |
| **API** | `POST /rest/v1/rpc/upsert_daily_record`, `GET /rest/v1/profiles` |

#### 화면 4: 지출 금액 입력 모달 (record-input)

| 영역 | 구성 요소 |
|------|----------|
| 상단 | "오늘 지출 기록" 제목, X 닫기 버튼 |
| 중앙 | 금액 입력 필드 (숫자 키패드, 원 단위), 메모 입력 필드 (선택, TextInput) |
| 하단 | "기록하기" CTA 버튼 |
| **데이터** | amount, memo |
| **API** | `POST /rest/v1/rpc/upsert_daily_record` (is_no_spend: false) |

#### 화면 5: 무지출 캘린더 (calendar/index)

| 영역 | 구성 요소 |
|------|----------|
| 상단 | 월 선택 (< 2026년 1월 >, 좌우 스와이프) |
| 상단 통계 카드 | 무지출 N일 / 지출 N일 / 총 지출 N원 / 일평균 N원 |
| 중앙 | react-native-calendars 캘린더. 날짜 셀 색상: 초록(무지출), 빨강(지출), 회색(미기록). 날짜 탭 → 하단에 상세 기록 표시 |
| 하단 | 선택된 날짜의 상세 기록 (무지출 여부, 금액, 메모). 미기록 날짜 탭 시 "기록하기" 버튼 (7일 이내만) |
| **데이터** | monthlyRecords, monthlySummary |
| **API** | `GET /rest/v1/daily_records`, `POST /rest/v1/rpc/get_monthly_summary` |

#### 화면 6: 챌린지 목록 (challenge/index)

| 영역 | 구성 요소 |
|------|----------|
| 상단 | "챌린지" 제목, 참여 중(N/3) 배지 |
| 내 챌린지 섹션 | 참여 중인 챌린지 카드 리스트 (프로그레스 바, 남은 일수, 진행률 %) |
| 참여 가능 섹션 | 공식 챌린지 카드 리스트 (제목, 설명, 기간, XP 보상, "참여하기" 버튼) |
| 카드 UI | 챌린지 아이콘 + 제목 + 기간 + 참여자 수 + 프로그레스 바 |
| **데이터** | availableChallenges, myParticipations |
| **API** | `GET /rest/v1/challenges`, `GET /rest/v1/challenge_participants` |

#### 화면 7: 챌린지 상세 (challenge/[id])

| 영역 | 구성 요소 |
|------|----------|
| 상단 | 챌린지 아이콘 + 제목 + 뒤로가기 |
| 상세 정보 | 설명, 기간, 목표, 보상(XP + 배지), 참여자 수 |
| 진행률 (참여 중일 때) | 큰 프로그레스 링, 달성/목표 숫자, 남은 일수 |
| 랭킹 (참여 중일 때) | 상위 10명 리스트 (닉네임, 진행률) — P1 |
| 하단 | "참여하기" / "포기하기" 버튼 |
| **데이터** | selectedChallenge, ChallengeParticipant |
| **API** | `POST /rest/v1/rpc/join_challenge`, `GET /rest/v1/challenge_participants` |

#### 화면 8: 절약방 피드 (community/index)

| 영역 | 구성 요소 |
|------|----------|
| 상단 | "절약방" 제목, 정렬 토글 (최신순/인기순) |
| 피드 | FlatList 무한 스크롤. 게시글 카드: 작성자 닉네임+레벨, 내용 텍스트, 이미지 (있을 경우), 좋아요 수+댓글 수, 작성 시간 |
| FAB | 게시글 작성 플로팅 버튼 → create-post 모달 |
| **데이터** | posts, sortBy, hasMore |
| **API** | `GET /rest/v1/community_posts`, Supabase Realtime 구독 |

#### 화면 9: 게시글 상세 (community/[id])

| 영역 | 구성 요소 |
|------|----------|
| 상단 | 작성자 정보 (닉네임, 레벨), 작성 시간, 더보기 메뉴(신고/삭제) |
| 본문 | 게시글 내용 + 이미지 |
| 반응 바 | 좋아요 버튼 + 카운트, 댓글 카운트 |
| 댓글 섹션 | 댓글 리스트 (닉네임, 내용, 시간) |
| 하단 | 댓글 입력 필드 + 전송 버튼 |
| **데이터** | selectedPost, comments |
| **API** | `POST /rest/v1/rpc/toggle_post_like`, `GET/POST /rest/v1/post_comments` |

#### 화면 10: 프로필/설정 (profile/index)

| 영역 | 구성 요소 |
|------|----------|
| 상단 카드 | 닉네임, 레벨 + 경험치 바, 현재/최장 스트릭, 대표 배지 3개 |
| 설정 리스트 | 프로필 편집 (닉네임, 목표금액), 알림 설정 (시간 변경), 배지함 바로가기, 프리미엄 구독, 다크모드 (P2), 로그아웃, 계정 탈퇴 |
| **데이터** | profile, myBadges |
| **API** | `GET /rest/v1/profiles`, `PATCH /rest/v1/profiles` |

#### 화면 11: 배지함 (profile/badges)

| 영역 | 구성 요소 |
|------|----------|
| 상단 | "배지함" 제목, 획득 N/전체 M |
| 카테고리 탭 | 전체 / 스트릭 / 챌린지 / 커뮤니티 / 스페셜 |
| 그리드 | 배지 아이콘 그리드 (3열). 획득: 컬러 아이콘 + 이름. 미획득: 흑백 아이콘 + 자물쇠 + 조건 텍스트 |
| **데이터** | allBadges, myBadges |
| **API** | `GET /rest/v1/badge_definitions`, `GET /rest/v1/user_badges` |

#### 화면 12: 배지 획득 축하 모달 (badge-earned)

| 영역 | 구성 요소 |
|------|----------|
| 배경 | 반투명 오버레이 + 컨페티 Lottie 애니메이션 |
| 중앙 | 배지 아이콘 (크게), 배지 이름, 획득 조건 설명, "+N XP" 텍스트 |
| 하단 | "확인" 버튼 |
| **데이터** | newBadgeQueue 에서 pop |
| **API** | 없음 (로컬 상태) |

---

## 9. Competitive Differentiation

### 포지셔닝
> **"무지출 챌린지 전용 앱"** — 가계부도, 금융 슈퍼앱도, 뷰티 커머스도 아닌, 오직 절약 습관 형성과 커뮤니티에 집중

### 핵심 차별점

| 차별점 | 우리 앱 | 경쟁사 현황 | 차별화 근거 |
|--------|---------|------------|------------|
| **극단적 단순화 (1탭 인증)** | 홈 화면 버튼 1탭으로 무지출 인증 | 뱅크샐러드/토스: 복잡한 지출 분류 UI | 가계부 앱 포기율의 핵심 원인(입력 번거로움)을 제거 |
| **스트릭 기반 장기 습관 형성** | 연속 무지출 일수 시각화 + 마일스톤 보상 | 챌린저스: 단기 이벤트 중심, 뱅크샐러드: 5일 게임만 | 행동 심리학의 streak motivation 활용, 장기 리텐션 확보 |
| **앱 내 절약 커뮤니티 (절약방)** | 피드형 커뮤니티, 좋아요/댓글/인증 공유 | 카카오톡 거지방: 비체계적, 데이터 축적 불가 | 거지방 문화를 체계적으로 흡수, 소셜 동기부여 제공 |
| **독립 전용 앱** | 절약 챌린지만을 위한 전용 앱 | 뱅크샐러드/카카오페이: 부가 기능 수준 | 진입 장벽 낮음, 절약 목적에 100% 집중된 UX |
| **게이미피케이션 깊이** | 배지+레벨+XP+챌린지+랭킹 통합 시스템 | 카카오페이: 배지 4개로 제한, 뱅크샐러드: 상금만 | 카카오페이의 검증된 패턴을 확장, 장기 몰입 유도 |

### 경쟁 대응 전략

- **뱅크샐러드 샐러드게임 강화 시**: 마이데이터 미연동의 약점을 "극단적 단순화"로 역전. 참가권 없이 언제든 시작 가능한 자유도 강조
- **카카오페이 챌린지 독립 시**: 커뮤니티와 커스텀 챌린지라는 차별점으로 대응. 카카오페이에 없는 소셜 요소가 핵심 해자
- **새로운 경쟁자 진입 시**: 커뮤니티 콘텐츠와 배지 시스템의 네트워크 효과로 방어

---

## 10. Monetization Strategy

### 수익 모델 구조

```
┌─────────────────────────────────────────┐
│           무료 (Free Tier)               │
│  - 무지출 인증 & 캘린더 & 스트릭          │
│  - 공식 챌린지 참여 (3개까지)             │
│  - 커뮤니티 (절약방) 이용                 │
│  - 기본 월간 요약                         │
│  - 배지 & 레벨 시스템                     │
│  - 배너 광고 (하단)                       │
├─────────────────────────────────────────┤
│         프리미엄 (월 2,900원)             │
│  - 모든 무료 기능 +                       │
│  - 광고 완전 제거                         │
│  - 커스텀 챌린지 생성                     │
│  - 상세 소비 분석 차트 (P2)               │
│  - 프리미엄 배지 (전용 디자인)            │
│  - 향후: 절약 리워드 우선 참여            │
└─────────────────────────────────────────┘
```

### 수익 전망 (SOM 기준, 1~3년 내)

| 수익원 | 산출 근거 | 연간 수익 |
|--------|----------|----------|
| 프리미엄 구독 | 유료 2.38만 명 × 월 2,900원 × 12개월 | 약 8.3억 원 |
| 광고 (배너) | 무료 45만 명 × eCPM 1,000원 × 일 2회 × 365일 ÷ 1,000 | 약 3.3억 원 |
| **합계** | | **약 11.6억 원** |

### 과금 전략

1. **무료 티어의 충분한 가치**: 핵심 기능(인증·캘린더·챌린지·커뮤니티)은 모두 무료. 절약 앱 사용자의 과금 민감성을 존중
2. **ROI 메시지**: "프리미엄 월 2,900원으로 월 N만 원 절약!" — 프리미엄 비용 대비 절약 효과를 수치로 보여주는 마케팅
3. **무료 → 유료 전환 트리거**: 커스텀 챌린지 생성 시도, 광고 피로감 누적 시점에 프리미엄 유도
4. **RevenueCat 통합**: iOS/Android 인앱구매 통합 관리, 구독 갱신율·LTV 추적

---

## 11. Risk Matrix

| 분류 | 리스크 | 영향도 | 발생 가능성 | 대응 방안 |
|------|--------|--------|------------|----------|
| **사업** | 대기업(뱅크샐러드/카카오페이)이 챌린지 기능을 독립 앱 수준으로 강화 | 높음 | 중간 | 커뮤니티+게이미피케이션 깊이로 차별화. 대기업이 만들기 어려운 "가벼운 전용 앱" 포지셔닝 유지 |
| **사업** | 무지출 챌린지 트렌드가 일시적 유행에 그침 | 높음 | 낮음 | 2022년부터 3년+ 지속 중인 트렌드. 고물가가 계속되는 한 구조적 수요. 절약 습관 일반으로 확장 가능 |
| **사업** | 절약 앱 사용자의 유료 전환 저항 | 중간 | 높음 | 광고 수익을 1차 수익원으로 유지. 프리미엄은 부가 수익. ROI 메시지로 과금 합리화 |
| **기술** | 오프라인-온라인 동기화 충돌/데이터 손실 | 중간 | 낮음 | Server Wins 정책 + SyncQueue 재시도 로직 + 로컬 DB 백업 |
| **기술** | Supabase 무료 플랜 한계 (접속 제한, DB 용량) | 중간 | 중간 | 초기 사용자 5,000명까지 무료 플랜 커버. 이후 Pro 플랜(월 $25) 전환. 수익으로 충분히 감당 |
| **운영** | 커뮤니티 콜드 스타트 (초기 사용자 부족) | 높음 | 높음 | 카카오톡 거지방 대상 타겟 마케팅. 시드 콘텐츠(운영자 계정) 미리 투입. 초기에는 커뮤니티보다 개인 기록 기능에 집중 |
| **운영** | 커뮤니티 유해 콘텐츠/스팸 | 중간 | 중간 | 신고 기능 + report_count 임계값(3회) 자동 숨김 + 주기적 모니터링 |
| **법률** | 개인정보보호법 준수 | 낮음 | 낮음 | 최소 수집 원칙(이메일, 닉네임만). 탈퇴 시 30일 유예 후 완전 삭제. 개인정보 처리방침 고지 |
| **의존성** | RevenueCat 서비스 장애 | 낮음 | 낮음 | 구독 상태를 로컬에도 캐싱. RevenueCat 장애 시 기존 프리미엄 상태 유지 (grace period) |
| **의존성** | Supabase 서비스 장애 | 중간 | 낮음 | 오프라인 우선 설계로 핵심 기능(인증·캘린더·스트릭) 로컬 동작. 서버 복구 후 동기화 |

---

## 12. Assumptions & Constraints

### 사업적 가정

1. 무지출 챌린지 트렌드가 최소 2년 이상 지속된다 (2022년 시작, 고물가 구조적 요인)
2. MZ세대 절약 관심층 중 5%가 전용 앱 사용 의향이 있다
3. 프리미엄 전환율 5%는 보수적 추정이며, 커뮤니티 활성화 시 상향 가능하다
4. 카카오톡 거지방 사용자가 체계적 기록 도구를 원한다

### 외부 의존성

| 의존성 | 설명 | 리스크 수준 |
|--------|------|------------|
| Supabase | 백엔드 전체 (Auth, DB, Storage, Edge Functions) | 중간 — 오픈소스 기반이므로 셀프호스팅 전환 가능 |
| RevenueCat | 인앱구매 관리 | 낮음 — 대안(react-native-iap 직접 구현) 존재 |
| Expo Push Service | 푸시 알림 발송 | 낮음 — Expo 생태계 핵심 서비스, 안정적 |
| App Store / Play Store | 앱 배포 및 인앱구매 수수료(15~30%) | 필수 — 회피 불가 |
| Kakao OAuth | 한국 사용자 주요 로그인 수단 | 낮음 — 안정적 서비스, 구글/애플 대안 존재 |

### 기술 제약

1. **마이데이터 미연동**: 은행/카드 자동 지출 연동 불가. 수동 입력(1탭 인증) 방식으로 대체
2. **1인 개발 규모**: 복잡한 실시간 기능(채팅, 화상통화 등) 구현 불가. 커뮤니티는 비동기 피드 방식
3. **3개월 MVP 제약**: P2 기능은 MVP 이후로 연기. P0/P1에 집중
4. **Expo Managed Workflow**: 네이티브 모듈 직접 수정 불가. Expo SDK가 지원하는 범위 내에서 구현

### project-init 관련

- 모든 기술 선택이 project-init 고정 스택 및 조건부 의존성 테이블 범위 내에 있음
- 수동 설치 필요 패키지: 없음

---

## 13. Out of Scope

MVP에서 **명시적으로 제외**하는 기능 및 영역:

| 제외 항목 | 제외 사유 |
|----------|----------|
| 마이데이터 연동 (은행/카드 자동 지출 추적) | 금융 인허가·API 연동 복잡성. 1인 개발 규모 초과 |
| 실시간 채팅 (1:1, 그룹) | 커뮤니티는 비동기 피드로 MVP 검증. 채팅은 리소스 과다 |
| 소셜 그래프 (친구 추가/팔로우) | 커뮤니티 콜드 스타트 해결 후 검토. MVP는 공개 피드만 |
| 지출 카테고리 분류 시스템 | 극단적 단순화 원칙. 가계부가 아닌 챌린지 앱 |
| 다국어 지원 (영어 등) | 한국 시장 전용 MVP. 해외 확장은 트랙션 확인 후 |
| 웹 버전 | 모바일 앱 전용. 웹은 MVP 이후 검토 |
| 돈 걸기/상금 시스템 | 챌린저스 모델. 법적 검토 필요, MVP에서 제외 |
| 제휴 브랜드 쿠폰/리워드 | 제휴 파트너십 필요. MVP 이후 사용자 확보 후 추진 |
| AI 기반 절약 추천 | 데이터 축적 후 검토. MVP 범위 초과 |
| 위젯 (iOS/Android 홈 화면) | P2 이후. MVP 핵심 가치와 무관 |

---

## 14. MVP Roadmap

### 3개월 로드맵 (12주)

#### Phase 1: 기반 구축 (Week 1~3)

| 주차 | 마일스톤 | 상세 |
|------|---------|------|
| W1 | 프로젝트 초기화 & 인증 | Expo 프로젝트 셋업, Supabase 프로젝트 생성, DB 스키마 적용, OAuth 로그인(카카오/구글/애플) 구현 |
| W2 | 온보딩 & 프로필 | 온보딩 플로우(닉네임+목표 설정), 프로필 화면, 설정 화면, 자동 로그인 |
| W3 | 오프라인 인프라 | op-sqlite 로컬 DB 셋업, MMKV 설정, SyncQueue 구현, 네트워크 상태 감지 |

#### Phase 2: 핵심 기능 (Week 4~7)

| 주차 | 마일스톤 | 상세 |
|------|---------|------|
| W4 | 무지출 인증 & 스트릭 | 홈 화면 UI, 1탭 무지출 인증, 지출 입력 모달, 스트릭 계산 (로컬+서버), Lottie 축하 애니메이션 |
| W5 | 캘린더 | react-native-calendars 통합, 월별 기록 조회, 날짜별 상세 보기, 소급 입력, 월간 요약 통계 |
| W6 | 챌린지 시스템 | 챌린지 목록/상세 화면, 참여 로직, 진행률 표시, 시드 챌린지 데이터 |
| W7 | 배지 & 레벨 | 배지 정의 시드, 배지 획득 로직(스트릭/챌린지), 배지함 화면, 레벨업 시스템, XP 경험치 |

#### Phase 3: 소셜 & 마무리 (Week 8~12)

| 주차 | 마일스톤 | 상세 |
|------|---------|------|
| W8 | 커뮤니티 기본 | 절약방 피드 화면, 게시글 작성(텍스트+이미지), 좋아요, 댓글 |
| W9 | 커뮤니티 고도화 & 알림 | 최신순/인기순 정렬, 신고 기능, 푸시 알림(일일 리마인더), 알림 설정 |
| W10 | 프리미엄 & 결제 | RevenueCat 통합, 프리미엄 구독 화면, 인앱구매 플로우, 광고 배너 통합 |
| W11 | 통합 테스트 & 버그 수정 | E2E 테스트, 오프라인/동기화 테스트, 성능 최적화, 엣지케이스 수정 |
| W12 | 출시 준비 | App Store/Play Store 제출, 스토어 메타데이터(스크린샷, 설명), 개인정보 처리방침, 출시 |

### 핵심 마일스톤 체크포인트

| 시점 | 체크포인트 | 성공 기준 |
|------|----------|----------|
| W3 끝 | 인증+오프라인 인프라 완성 | 카카오 로그인 → 온보딩 → 프로필 조회까지 동작 |
| W5 끝 | 핵심 루프 완성 | 무지출 인증 → 캘린더 반영 → 스트릭 표시 전체 플로우 동작 |
| W7 끝 | 게이미피케이션 완성 | 챌린지 참여 → 달성 → 배지 획득 → 레벨업 전체 플로우 동작 |
| W9 끝 | 전 기능 동작 | 커뮤니티 + 알림 포함 모든 P0 기능 동작 |
| W12 끝 | 스토어 출시 | App Store + Play Store 심사 통과 및 공개 |

---

## 15. Success Metrics

### 핵심 지표 (KPI)

#### 사용자 지표

| 지표 | 정의 | 목표 (출시 3개월) | 측정 방법 |
|------|------|------------------|----------|
| **MAU** (Monthly Active Users) | 월 1회 이상 앱 오픈 사용자 | 10,000명 | Aptabase 분석 |
| **DAU** (Daily Active Users) | 일 1회 이상 앱 오픈 사용자 | 3,000명 | Aptabase 분석 |
| **DAU/MAU 비율** | 일간/월간 활성 비율 (stickiness) | 30% 이상 | Aptabase 계산 |
| **D7 리텐션** | 설치 7일 후 복귀율 | 40% 이상 | Aptabase 코호트 |
| **D30 리텐션** | 설치 30일 후 복귀율 | 20% 이상 | Aptabase 코호트 |

#### 비즈니스 지표

| 지표 | 정의 | 목표 (출시 6개월) | 측정 방법 |
|------|------|------------------|----------|
| **프리미엄 전환율** | 무료→유료 전환 비율 | 3% 이상 | RevenueCat 대시보드 |
| **MRR** (Monthly Recurring Revenue) | 월간 반복 매출 | 300만 원 | RevenueCat 대시보드 |
| **ARPU** (Average Revenue Per User) | 사용자당 평균 매출 | 300원/월 (광고+구독) | 계산 (MRR + 광고 수익) / MAU |
| **구독 해지율** | 월간 구독 해지 비율 | 10% 미만 | RevenueCat 대시보드 |

#### 제품 지표

| 지표 | 정의 | 목표 | 측정 방법 |
|------|------|------|----------|
| **일일 인증률** | DAU 중 무지출/지출 인증 완료 비율 | 70% 이상 | DB 쿼리 (daily_records / DAU) |
| **평균 스트릭** | 전체 활성 사용자의 평균 연속 무지출 일수 | 5일 이상 | DB 집계 (profiles.current_streak) |
| **챌린지 참여율** | MAU 중 1개 이상 챌린지 참여 비율 | 50% 이상 | DB 쿼리 (challenge_participants) |
| **챌린지 완료율** | 참여한 챌린지의 완료 비율 | 30% 이상 | DB 쿼리 (status='completed') |
| **커뮤니티 게시글/주** | 주당 신규 게시글 수 | 500건 이상 (출시 3개월) | DB 쿼리 (community_posts) |
| **앱 스토어 평점** | App Store + Play Store 평균 | 4.5 이상 | 스토어 대시보드 |

### North Star Metric

> **주간 무지출 인증 횟수 (Weekly Certifications)**

이 앱의 핵심 가치는 "절약 습관 형성"이다. 사용자가 매일(또는 자주) 무지출 인증을 수행한다는 것은 앱이 습관 형성 도구로서 작동하고 있다는 증거다. 이 지표가 성장하면 리텐션·스트릭·챌린지 달성·커뮤니티 활동이 자연스럽게 따라온다.

---

## 16. Glossary (용어 사전)

| 용어 | 정의 |
|------|------|
| **무지출 인증** | 하루 동안 지출이 없었음을 앱에서 기록하는 행위. 홈 화면의 메인 버튼 1탭으로 완료한다. |
| **스트릭 (Streak)** | 연속으로 무지출 인증에 성공한 일수. 지출이 발생하거나 인증을 하지 않으면 0으로 리셋된다. 습관 형성의 핵심 동기부여 요소. |
| **원탭 인증** | 사용자가 버튼 한 번 탭으로 무지출 기록을 완료하는 UX 패턴. 기존 가계부 앱의 복잡한 입력을 극단적으로 단순화한 것. |
| **절약방** | 앱 내 커뮤니티 피드. 사용자들이 무지출 인증, 절약 팁, 절약 성과 등을 공유하는 공간. 카카오톡 '거지방' 문화를 체계적으로 흡수한 기능. |
| **배지 (Badge)** | 특정 조건(스트릭 마일스톤, 챌린지 완료, 커뮤니티 활동 등) 달성 시 지급되는 시각적 보상 아이템. 배지함에서 확인 가능. |
| **XP (경험치)** | Experience Points. 무지출 인증, 챌린지 완료, 배지 획득 등 활동에 따라 부여되는 포인트. XP 누적에 따라 레벨이 상승한다. |
| **레벨** | 사용자의 절약 활동 누적도를 나타내는 등급. XP 경험치에 따라 1(절약 새싹)부터 10(절약 그랜드마스터)까지 상승. xp_levels 테이블에서 정의. |
| **챌린지** | 일정 기간 동안 특정 절약 목표를 달성하는 미션. `no_spend_days`(무지출 일수 달성)와 `spending_limit`(지출 한도 이내) 두 가지 타입이 있다. |
| **공식 챌린지** | 앱 운영진이 사전 정의하여 제공하는 챌린지. 무료 사용자도 참여 가능. |
| **커스텀 챌린지** | 프리미엄 사용자가 직접 목표·기간·규칙을 설정하여 생성하는 챌린지. |
| **거지방** | 카카오톡 오픈채팅방 기반의 절약 커뮤니티. 수백 개 방이 운영 중이며, 본 앱의 절약방이 이 문화를 체계적으로 대체하는 것을 목표로 한다. |
| **Server Wins** | 오프라인-온라인 동기화 시 충돌 해결 정책. 동일 레코드에 서버와 로컬 모두 변경이 있을 경우, 서버 데이터를 우선(updated_at 비교)하여 덮어쓰는 전략. |
| **SyncQueue (동기화 큐)** | 오프라인 상태에서 발생한 데이터 변경을 MMKV에 순서대로 저장해두고, 온라인 복귀 시 FIFO 순서로 서버에 동기화하는 큐 구조. 지수 백오프(1s→2s→4s→8s→16s) 재시도, 최대 5회. |
| **RLS (Row Level Security)** | Supabase(PostgreSQL)의 행 단위 보안 정책. 각 사용자가 자신의 데이터에만 접근할 수 있도록 테이블별 CRUD 권한을 정의한다. |
| **Edge Function** | Supabase에서 제공하는 서버리스 함수(Deno 런타임). 외부 API 호출(RevenueCat, Expo Push), 복합 비즈니스 로직 등 단순 CRUD를 넘어서는 처리에 사용. |
| **RPC (Remote Procedure Call)** | PostgreSQL DB Function을 Supabase REST API를 통해 호출하는 방식. 트랜잭션이 필요한 복합 로직(스트릭 계산, 챌린지 진행률 갱신 등)에 사용. SECURITY DEFINER로 실행. |
| **MMKV** | C++ JSI 기반의 초고속 Key-Value 로컬 저장소(react-native-mmkv). 세션 토큰, 설정값, 동기화 큐 메타데이터 등 단순 KV 데이터 저장에 사용. |
| **op-sqlite** | SQLite 기반 관계형 로컬 DB 라이브러리. 오프라인 일일 기록 캐싱, 캘린더 데이터 로컬 조회 등 관계형 쿼리가 필요한 데이터에 사용. |
| **RevenueCat** | 인앱구매(IAP) 서버사이드 관리 서비스. iOS/Android 영수증 검증 자동화, 구독 상태 관리, LTV/MRR 추적을 제공. |
| **YONO (You Only Need One)** | YOLO(You Only Live Once)의 반대 개념으로, "정말 필요한 것 하나만"이라는 절약형 소비 트렌드. MZ세대의 소비 패러다임 전환을 대표하는 키워드. |
