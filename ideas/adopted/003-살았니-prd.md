# 살았니 (SafePin) — PRD v1.4

> 작성일: 2026-01-31
> 최종 수정: 2026-02-02 (v5 리뷰 Minor 2건 반영 — §8-2 화면별 API 경로 정식화)
> 상태: Review Ready
> 대상: 003-살았니

---

## 1. Executive Summary

살았니(SafePin)는 한국 20~50대 1인가구를 위한 일일 안부 체크인 앱이다. 매일 설정한 시간에 "살았어" 버튼 하나로 생존을 확인하고, 일정 시간(12/24/48시간) 미응답 시 긴급연락처에 카카오톡·SMS 이중 알림을 자동 발송한다. 한국 1인가구 804만 가구(36.1%) 중 20~59세 503만 가구가 정부 AI 안부확인 서비스의 사각지대에 놓여 있으며, 중국 Demumu(死了麼)의 글로벌 바이럴(Apple App Store 유료 1위, CNN·BBC 등 보도)이 "안부확인 앱" 카테고리 수요를 검증한 상황에서, 한국 시장에는 직접 경쟁자가 전무하다. 카카오톡 알림 연동이라는 한국 로컬 킬러 차별점과 월 1,900~3,900원의 프리미엄 구독 모델로, 1년 차 3~6만 유료 사용자(SOM 7.2~14.4억 원)를 목표로 한다.

---

## 2. Problem Statement

### 2-1. 핵심 Pain Point

| # | Pain Point | 근거 |
|---|-----------|------|
| P1 | **"혼자 쓰러지면 아무도 모른다" 불안**: 1인가구 62%가 외로움을 느끼며, "혼자 살다 쓰러지면 아무도 모를까 봐 불안하다"는 게시글이 네이버 블로그 641건, 카페 267건에서 반복 확인됨 | 시장분석 §3 — 커뮤니티 실제 근거 |
| P2 | **고독사는 노인만의 문제가 아님**: 2024년 고독사 3,924명 중 40~60대가 75.9%(50대 30.5%, 60대 32.4%, 40대 13.0%). 중장년 1인가구의 핵심 리스크 | 시장분석 §2 — 고독사 현황 |
| P3 | **정부 서비스의 사각지대**: 지자체 AI 안부확인·IoT 스마트플러그 등은 고령층·취약계층 한정, 신청 절차 복잡, 지자체별 파편화. 20~59세 일반 청장년은 이용 불가 | 시장분석 §2 — 정부 정책 기조 |
| P4 | **기존 대안의 한계**: 가족 수동 연락(매일 부담), Apple Watch(고가·낙상만 감지), IoT플러그(별도 기기·저정밀도) — 어느 것도 "간편한 능동적 셀프 체크인"을 제공하지 못함 | 시장분석 §3 — JTBD 분석 |
| P5 | **글로벌 수요 검증, 한국 공백**: Demumu가 10만+ DL·4.3★로 전 세계 바이럴되었으나, 이메일 알림 전용·한국어 미지원으로 한국 시장은 완전한 공백 상태 | 경쟁분석 §1-1, 시장분석 §2 |

### 2-2. 시장 배경

- **한국 1인가구 804만 가구(36.1%)**: 2015년 이래 매년 최고치 경신. 서울·경기 42.7% (국가데이터처 2025)
- **고독사 3,924명/년(2024)**: 전년 대비 7.2% 증가, 가족·지인 발견은 최근 5년간 감소 → 사회적 고립 심화 (시장분석 §2)
- **Demumu 바이럴과 이후 경과**: 2026년 1월 중국 유료 1위를 기록하며 CNN·BBC·Reuters 등 글로벌 주요 매체가 보도했으나, 2026년 1월 15일 중국 앱스토어에서 제거됨 (경쟁분석 §1-1). 바이럴 자체는 소멸 가능성이 있으나, "1인가구 안부확인"이라는 니즈가 전 세계적으로 검증된 사실은 변하지 않음. 한국 내 네이버 뉴스 관련 보도 0건 → 한국어 서비스 공백 상태 지속 (시장분석 §2)
- **네이버 트렌드**: "고독사/고독사 예방" 검색량 높음(피크 100), "안부확인 앱" 검색량 거의 0 → 문제 인식은 크지만 해결책 인지도 부재 (시장분석 §2)

---

## 3. Target Users & Personas

### 페르소나 1: 이준혁 (32세, IT 직장인)

| 항목 | 내용 |
|------|------|
| 배경 | 서울 강서구 원룸 1인가구, 개발자 5년차. 야근이 잦고 주말에 집에서 혼자 보내는 경우 많음 |
| 현재 행동 | 부모님께 격일로 카톡 보내지만, 급성 질환(뇌졸중 등) 발생 시 수시간~수일간 발견 안 될 수 있다는 불안 |
| Pain Point | "혼자 쓰러지면 최소 2~3일은 아무도 모른다". 부모님께 매일 연락하기는 부담스러움 |
| 기대 가치 | 하루 1번 버튼만 누르면 부모님이 안심. 미응답 시 자동 알림으로 안전망 확보 |
| 지불 의향 | 월 1,900~3,900원은 보험료보다 저렴. 안전이라는 가치에 충분히 납득 |

### 페르소나 2: 박미경 (48세, 이혼 후 1인가구)

| 항목 | 내용 |
|------|------|
| 배경 | 경기도 수원 아파트 1인가구, 사무직 20년차. 이혼 후 혼자 살기 시작. 성인 자녀는 타지 거주 |
| 현재 행동 | 딸에게 주 2~3회 카톡, 동네 친구와 가끔 만남. 만성 고혈압 복용 중 |
| Pain Point | 고혈압으로 갑자기 쓰러질 수 있다는 걱정. 고독사 뉴스 볼 때마다 자기 일처럼 느껴짐 |
| 기대 가치 | 매일 체크인으로 딸에게 "엄마 오늘도 괜찮아" 신호. 이상 시 즉시 알림 |
| 지불 의향 | 카카오톡 알림이 되는 게 핵심. 월 3,900원 기꺼이 결제 |

### 페르소나 3: 김서연 (24세, 자취 대학생)

| 항목 | 내용 |
|------|------|
| 배경 | 대전 대학가 원룸 자취, 대학교 4학년. 부모님은 지방 거주. Demumu 뉴스를 SNS에서 봄 |
| 현재 행동 | 부모님과 주 1회 전화. 급성 질환보다는 범죄·사고에 대한 불안이 더 큼 |
| Pain Point | 부모님이 "매일 연락해"라고 하지만 현실적으로 어려움. 간편한 방법이 있으면 좋겠음 |
| 기대 가치 | 버튼 한 번으로 부모님 안심. 체크인 스트릭으로 습관화 |
| 지불 의향 | 무료 기본 기능 사용, 카카오톡 알림 위해 소액 결제 고려 |

---

## 4. User Stories

### Epic 1: 온보딩 & 인증

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-01 | As a 신규 사용자, I want 카카오/구글/애플 소셜 로그인으로 10초 내에 가입할 수 있기를, so that 별도 비밀번호 없이 바로 시작할 수 있다 | P0 |
| US-02 | As a 신규 사용자, I want 첫 실행 시 3단계 온보딩(앱 소개/체크인 주기 설정/긴급연락처 등록)을 경험하기를, so that 앱의 핵심 기능을 즉시 활성화할 수 있다 | P0 |
| US-03 | As a 기존 사용자, I want 앱 재설치 시 기존 데이터가 복원되기를, so that 체크인 기록이 유실되지 않는다 | P1 |

### Epic 2: 체크인

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-04 | As a 사용자, I want 설정한 시간에 푸시 알림을 받고 "살았어" 버튼을 눌러 체크인하기를, so that 매일 간편하게 안부를 확인할 수 있다 | P0 |
| US-05 | As a 사용자, I want 체크인 시 선택적으로 한줄 상태 메모(최대 100자)를 남기기를, so that 그날의 상태를 기록할 수 있다 | P0 |
| US-06 | As a 사용자, I want 체크인 주기를 12시간/24시간/48시간 중 선택하기를, so that 나의 생활 패턴에 맞는 주기로 안전을 관리할 수 있다 | P0 |
| US-07 | As a 사용자, I want 푸시 알림 없이도 앱을 열어 수동으로 체크인할 수 있기를, so that 알림 전에도 자유롭게 체크인할 수 있다 | P1 |
| US-08 | As a 사용자, I want 체크인 시 현재 위치를 선택적으로 기록하기를, so that 긴급 시 마지막 위치를 긴급연락처에 공유할 수 있다 | P1 |

### Epic 3: 긴급연락처 관리

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-09 | As a 사용자, I want 최대 3명의 긴급연락처(이름, 전화번호, 관계)를 등록하기를, so that 미응답 시 알림을 받을 사람을 지정할 수 있다 | P0 |
| US-10 | As a 사용자, I want 긴급연락처를 추가/수정/삭제하기를, so that 연락처를 최신 상태로 유지할 수 있다 | P0 |
| US-11 | As a 사용자, I want 긴급연락처 등록 시 상대방에게 동의 요청 SMS를 보내기를, so that 상대방이 자신의 역할을 인지하고 동의할 수 있다 | P0 |
| US-12 | As a 긴급연락처(수신자), I want 사용자의 안부 상태를 확인할 수 있는 웹 대시보드에 접근하기를, so that 앱 설치 없이도 안부를 확인할 수 있다 | P1 |

### Epic 4: 미응답 감지 & 알림 발송

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-13 | As a 사용자, I want 체크인 주기 만료 전 리마인더 푸시(1시간 전, 30분 전)를 받기를, so that 체크인을 놓치지 않을 수 있다 | P0 |
| US-14 | As a 시스템, I want 체크인 주기가 만료되면 긴급연락처에 SMS를 자동 발송하기를, so that 미응답 상황을 신속히 알릴 수 있다 | P0 |
| US-15 | As a 시스템, I want SMS 발송 후 카카오톡 알림톡도 발송하기를(프리미엄), so that 알림 도달률을 극대화할 수 있다 | P0 |
| US-16 | As a 사용자, I want 미응답 알림 발송 전 "정말 괜찮아요" 취소 버튼을 누를 수 있는 5분 유예 시간이 있기를, so that 실수로 인한 오알림을 방지할 수 있다 | P0 |
| US-17 | As a 긴급연락처(수신자), I want 알림 메시지에 사용자의 마지막 체크인 시각과 위치(허용 시)가 포함되기를, so that 상황을 신속히 판단할 수 있다 | P1 |

### Epic 5: 안부 타임라인 & 리포트

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-18 | As a 사용자, I want 달력 뷰에서 체크인 기록(성공/실패/미체크인)을 확인하기를, so that 안부 이력을 한눈에 볼 수 있다 | P0 |
| US-19 | As a 사용자, I want 연속 체크인 스트릭(연속 N일)을 확인하기를, so that 체크인 습관을 유지하는 동기부여를 얻을 수 있다 | P1 |
| US-20 | As a 유료 사용자, I want 주간/월간 체크인 리포트(체크인율, 평균 응답 시간, 미응답 횟수)를 보기를, so that 안전 관리 현황을 파악할 수 있다 | P1 |

### Epic 6: 설정

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-21 | As a 사용자, I want 체크인 알림 시간을 변경하기를, so that 내 생활 패턴에 맞출 수 있다 | P0 |
| US-22 | As a 사용자, I want 일시정지 모드(여행·입원 등)를 설정하기를, so that 일정 기간 체크인을 건너뛸 수 있다 | P1 |
| US-23 | As a 사용자, I want 내 프로필(닉네임, 프로필 이미지)을 수정하기를, so that 긴급연락처에게 표시되는 정보를 관리할 수 있다 | P1 |
| US-24 | As a 사용자, I want 위치 공유 허용/거부를 설정하기를, so that 프라이버시를 제어할 수 있다 | P1 |

### Epic 7: 구독 & 결제

| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-25 | As a 사용자, I want 무료/프리미엄 요금제를 비교하고 프리미엄으로 업그레이드하기를, so that 카카오톡 알림, 위치 공유 등 추가 기능을 사용할 수 있다 | P0 |
| US-26 | As a 유료 사용자, I want 구독을 관리(해지/변경)하기를, so that 결제를 통제할 수 있다 | P0 |
| US-27 | As a 사용자, I want 7일 무료 체험 후 구독을 결정하기를, so that 결제 전에 프리미엄 기능을 경험할 수 있다 | P1 |

---

## 5. Functional Requirements

### 5-1. 기능 목록 및 우선순위

#### P0 — MVP 필수 기능

| ID | 기능 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|------|------|---------|----------|
| FR-01 | 소셜 로그인 (카카오/구글/애플) | OAuth 토큰 | 인증 세션, 사용자 프로필 | 3개 소셜 로그인 중 1개 이상 필수 | 무료 |
| FR-02 | 온보딩 플로우 | 사용자 입력(체크인 주기, 알림 시간) | 초기 설정 완료 | 3단계 이내 | 무료 |
| FR-03 | 체크인 (버튼 탭) | 버튼 탭 + 선택적 메모(100자) | 체크인 기록 저장, 타이머 리셋 | 주기당 1회, 메모 100자 제한 | 무료 |
| FR-04 | 체크인 주기 설정 | 12h/24h/48h 선택 | 타이머 주기 변경 | 무료: 24h 고정. 프리미엄: 12h/24h/48h 선택 | 무료(24h) / 유료(선택) |
| FR-05 | 체크인 리마인더 푸시 | 시스템 스케줄 | 푸시 알림 (1시간 전, 30분 전) | 기기 푸시 허용 필요 | 무료 |
| FR-06 | 긴급연락처 등록/수정/삭제 | 이름, 전화번호, 관계 | 연락처 목록 | 최대 3명 | 무료(1명) / 유료(3명) |
| FR-07 | 긴급연락처 동의 요청 SMS | 사용자 요청 | SMS 발송 | 등록 시 1회 | 무료 |
| FR-08 | 미응답 감지 | 체크인 주기 만료 | 미응답 이벤트 트리거 | 서버 cron 기반 | 무료 |
| FR-09 | 5분 유예 + 취소 | 유예 시작 → 취소 버튼 또는 5분 경과 | 알림 취소 또는 발송 진행 | 유예 중 푸시+진동 | 무료 |
| FR-10 | SMS 긴급 알림 발송 | 미응답 확정 | 긴급연락처에 SMS 발송 | 건당 과금(알리고 API) | 무료 |
| FR-11 | 카카오톡 알림톡 발송 | 미응답 확정 | 긴급연락처에 카카오 알림톡 발송 | 카카오 비즈메시지 API, 건당 ~8원 | 유료 |
| FR-12 | 안부 타임라인 (달력 뷰) | 날짜 범위 | 체크인/미체크인 표시 달력 | 최근 90일 무료, 전체 이력 유료 | 무료(90일) / 유료(전체) |
| FR-13 | 프리미엄 구독 (인앱 결제) | 결제 정보 | 구독 활성화/해지 | App Store/Google Play IAP | 유료 |
| FR-14 | 구독 관리 (해지/변경) | 사용자 요청 | 구독 상태 변경 | 스토어 기본 기능 활용 | 유료 |

#### P1 — MVP 후속 (출시 후 1~2개월)

| ID | 기능 | 무료/유료 |
|----|------|----------|
| FR-15 | 위치 기록 (체크인 시 GPS) | 유료 |
| FR-16 | 긴급연락처 웹 대시보드 | 유료 |
| FR-17 | 체크인 스트릭 (연속 기록) | 무료 |
| FR-18 | 일시정지 모드 | 무료 |
| FR-19 | 주간/월간 체크인 리포트 | 유료 |
| FR-20 | 프로필 관리 | 무료 |
| FR-21 | 수동 체크인 (알림 없이) | 무료 |

#### P2 — 장기 로드맵

| ID | 기능 | 무료/유료 |
|----|------|----------|
| FR-22 | 긴급연락처 앱 설치 유도 + 양방향 체크인 | 무료 |
| FR-23 | 건강 데이터 연동 (Apple Health/Google Fit) | 유료 |
| FR-24 | 커뮤니티 기능 (1인가구 안전 팁) | 무료 |
| FR-25 | B2G 지자체 대시보드 | B2G |

### 5-2. P0 기능별 수용 기준 (Acceptance Criteria)

#### FR-01: 소셜 로그인

| AC ID | 수용 기준 |
|-------|----------|
| AC-01-1 | 카카오/구글/애플 중 하나를 선택하여 3탭 이내에 로그인이 완료된다 |
| AC-01-2 | 로그인 완료 후 2초 이내에 홈 화면으로 전환된다 |
| AC-01-3 | 이미 가입된 소셜 계정으로 재로그인 시 기존 데이터가 복원된다 |
| AC-01-4 | 네트워크 오류 시 "연결 상태를 확인해주세요" 에러 메시지가 표시된다 |

#### FR-02: 온보딩 플로우

| AC ID | 수용 기준 |
|-------|----------|
| AC-02-1 | 첫 로그인 후 3단계 온보딩(앱 소개 → 체크인 주기 선택 → 긴급연락처 등록)이 표시된다 |
| AC-02-2 | 각 단계는 5초 이내에 완료 가능하다 (총 온보딩 15초 이내) |
| AC-02-3 | 긴급연락처를 1명 이상 등록해야 온보딩이 완료된다 |
| AC-02-4 | 온보딩 완료 후 첫 체크인 푸시 알림이 설정된 시간에 예약된다 |

#### FR-03: 체크인

| AC ID | 수용 기준 |
|-------|----------|
| AC-03-1 | 홈 화면의 "살았어" 버튼을 탭하면 1초 이내에 체크인이 서버에 저장된다 |
| AC-03-2 | 체크인 성공 시 다음 체크인 마감 시각이 화면에 표시된다 |
| AC-03-3 | 체크인 시 선택적 한줄 메모(최대 100자)를 입력할 수 있다 |
| AC-03-4 | 오프라인 상태에서 체크인 시 로컬에 저장되고, 네트워크 복구 후 3초 이내에 서버에 동기화된다 |
| AC-03-5 | 현재 주기 내 중복 체크인 시 마지막 체크인으로 갱신된다 |

#### FR-04: 체크인 주기 설정

| AC ID | 수용 기준 |
|-------|----------|
| AC-04-1 | 프리미엄 사용자는 12시간/24시간/48시간 중 하나를 선택할 수 있다. 무료 사용자는 24시간 고정이며, 변경 시도 시 프리미엄 업그레이드 안내가 표시된다 |
| AC-04-2 | 주기 변경 시 현재 진행 중인 타이머가 새 주기로 즉시 리셋된다 (next_deadline_at = NOW() + 새 주기) |
| AC-04-3 | 변경 사항이 1초 이내에 서버에 반영된다 |

#### FR-05: 체크인 리마인더 푸시

| AC ID | 수용 기준 |
|-------|----------|
| AC-05-1 | 체크인 마감 1시간 전에 첫 번째 리마인더 푸시가 발송된다 |
| AC-05-2 | 체크인 마감 30분 전에 두 번째 리마인더 푸시가 발송된다 |
| AC-05-3 | 이미 체크인한 경우 리마인더가 발송되지 않는다 |
| AC-05-4 | 일시정지 모드(P1)에서는 리마인더가 발송되지 않는다 |

#### FR-06: 긴급연락처 관리

| AC ID | 수용 기준 |
|-------|----------|
| AC-06-1 | 긴급연락처를 이름, 전화번호(한국 번호 형식 검증), 관계(드롭다운)로 등록할 수 있다 |
| AC-06-2 | 무료 사용자는 1명, 유료 사용자는 최대 3명까지 등록할 수 있다 |
| AC-06-3 | 등록/수정/삭제 시 1초 이내에 서버에 반영된다 |
| AC-06-4 | 전화번호 형식이 올바르지 않은 경우 즉시 에러 메시지가 표시된다 |

#### FR-07: 긴급연락처 동의 요청 SMS

| AC ID | 수용 기준 |
|-------|----------|
| AC-07-1 | 긴급연락처 등록 시 상대방에게 동의 요청 SMS가 자동 발송된다 |
| AC-07-2 | SMS에는 앱 이름, 사용자 닉네임, 동의 확인 URL이 포함된다 |
| AC-07-3 | 상대방이 동의 URL을 클릭하면 연락처 상태가 "동의 완료"로 변경된다 |
| AC-07-4 | 동의 미완료 연락처에도 긴급 알림은 발송된다 (안전 우선 원칙) |

#### FR-08: 미응답 감지

| AC ID | 수용 기준 |
|-------|----------|
| AC-08-1 | 체크인 주기 만료 시점에 서버에서 미응답을 자동 감지한다 |
| AC-08-2 | 감지 후 1분 이내에 유예 푸시 알림이 사용자에게 발송된다 |
| AC-08-3 | 감지 정확도: 서버 시계 기준 ±1분 오차 이내 |

#### FR-09: 5분 유예 + 취소

| AC ID | 수용 기준 |
|-------|----------|
| AC-09-1 | 미응답 감지 후 5분간 "괜찮아요" 취소 버튼이 포함된 전체화면 알림이 표시된다 |
| AC-09-2 | 취소 버튼 탭 시 긴급 알림 발송이 중단되고 체크인이 완료 처리된다 |
| AC-09-3 | 5분 경과 시 자동으로 긴급 알림 발송 프로세스가 시작된다 |
| AC-09-4 | 유예 중 30초 간격으로 진동+소리 알림이 반복된다 |

#### FR-10: SMS 긴급 알림 발송

| AC ID | 수용 기준 |
|-------|----------|
| AC-10-1 | 유예 시간 종료 후 30초 이내에 모든 긴급연락처에 SMS가 발송된다 |
| AC-10-2 | SMS에는 사용자 닉네임, 마지막 체크인 시각, 안부 확인 요청 문구가 포함된다 |
| AC-10-3 | SMS 발송 실패 시 최대 3회 재시도한다 (30초 간격) |
| AC-10-4 | 발송 결과(성공/실패)가 사용자의 알림 이력에 기록된다 |

#### FR-11: 카카오톡 알림톡 발송 (프리미엄)

| AC ID | 수용 기준 |
|-------|----------|
| AC-11-1 | 유료 사용자의 미응답 시 SMS와 함께 카카오 알림톡이 동시 발송된다 |
| AC-11-2 | 알림톡에는 사용자 닉네임, 마지막 체크인 시각, 위치(허용 시)가 포함된다 |
| AC-11-3 | 알림톡 발송 실패 시 SMS로 폴백된다 |

#### FR-12: 안부 타임라인

| AC ID | 수용 기준 |
|-------|----------|
| AC-12-1 | 달력 뷰에서 각 날짜의 체크인 상태(성공=초록, 미체크인=빨강, 미래=회색)가 표시된다 |
| AC-12-2 | 날짜를 탭하면 해당일의 체크인 시각과 메모가 표시된다 |
| AC-12-3 | 무료 사용자는 최근 90일, 유료 사용자는 전체 이력을 조회할 수 있다 |
| AC-12-4 | 달력 데이터 로딩이 2초 이내에 완료된다 |

#### FR-13: 프리미엄 구독

| AC ID | 수용 기준 |
|-------|----------|
| AC-13-1 | 무료/프리미엄 비교 화면에서 차이점이 명확히 표시된다 |
| AC-13-2 | 인앱 결제(iOS App Store / Google Play)를 통해 월간/연간 구독이 가능하다 |
| AC-13-3 | 결제 완료 후 3초 이내에 프리미엄 기능이 활성화된다 |
| AC-13-4 | 구독 상태는 서버에 실시간 동기화된다 |

#### FR-14: 구독 관리

| AC ID | 수용 기준 |
|-------|----------|
| AC-14-1 | 설정 화면에서 현재 구독 상태(무료/프리미엄), 만료일, 결제 이력을 확인할 수 있다 |
| AC-14-2 | 해지 시 현재 결제 기간 만료까지 프리미엄 기능이 유지된다 |
| AC-14-3 | 해지 후 무료 전환 시 긴급연락처가 1명으로 제한되며, 초과분은 비활성화(삭제 아님)된다 |

---

## 6. Non-functional Requirements

### 6-1. 성능

| 항목 | 기준 |
|------|------|
| 체크인 응답 시간 | 버튼 탭 후 서버 저장 완료까지 1초 이내 |
| 미응답 감지 지연 | 체크인 주기 만료 후 1분 이내에 감지 |
| SMS 발송 지연 | 유예 종료 후 30초 이내에 전체 발송 |
| 앱 Cold Start | 3초 이내 |
| 달력 뷰 로딩 | 2초 이내 (90일 데이터) |
| 동시 접속 | 10,000 사용자 동시 체크인 처리 |

### 6-2. 보안

| 항목 | 기준 |
|------|------|
| 인증 | Supabase Auth + OAuth 2.0, JWT 토큰 |
| 데이터 암호화 | TLS 1.3 (전송 중), AES-256 (저장 시 — 전화번호, 위치) |
| 행 수준 보안 | Supabase RLS — 사용자는 자신의 데이터만 접근 |
| 긴급연락처 전화번호 | 서버에 암호화 저장, 앱에서는 마스킹 표시 (010-****-1234) |
| GDPR/PIPA 준수 | 개인정보 수집·이용 동의, 탈퇴 시 30일 내 데이터 삭제 |
| API Rate Limiting | 사용자당 분당 60회, IP당 분당 120회 |

### 6-3. 접근성

| 항목 | 기준 |
|------|------|
| 최소 글꼴 크기 | 14sp (체크인 버튼은 18sp 이상) |
| 색상 대비 | WCAG 2.1 AA 이상 (4.5:1) |
| 스크린 리더 | 핵심 CTA 버튼(체크인, 취소)에 접근성 라벨 필수 |
| 다크 모드 | 시스템 설정 따름 (React Native Paper 자동 지원) |

### 6-4. 확장성

| 항목 | 기준 |
|------|------|
| 사용자 규모 | 초기 1만 → 10만 사용자까지 Supabase Free/Pro 플랜으로 대응 |
| SMS 발송 | 알리고 API 일 발송 한도 확인, 급증 시 큐 기반 순차 처리 |
| 데이터 보관 | 체크인 기록 최대 3년 보관, 이후 아카이빙 |

---

## 7. Technical Architecture

### 7-1. 기술 스택

| 레이어 | 기술 | 버전/사양 | 선정 사유 |
|--------|------|----------|----------|
| **프레임워크** | Expo Managed Workflow | SDK 52+ | project-init 고정 스택. EAS Build/Submit으로 1인 개발 CI/CD 최적화 |
| **언어** | TypeScript | strict mode | project-init 고정 스택. 컴파일 타임 타입 안전성 |
| **라우팅** | Expo Router | v4+ (파일 기반) | project-init 고정 스택. 파일 기반 라우팅으로 화면 관리 단순화 |
| **UI** | React Native Paper | v5+ | project-init 고정 스택. Material Design 3 기반, 다크 모드 네이티브 지원 |
| **상태 관리** | Zustand | v5+ | project-init 고정 스택. 보일러플레이트 최소화, persist 미들웨어 지원 |
| **백엔드** | Supabase | PostgreSQL 15+ | project-init 고정 스택. Auth/RLS/Edge Functions/Realtime/pg_cron 통합 |
| **로컬 KV** | react-native-mmkv | v3+ | project-init 고정 스택. JSI 기반 초고속 KV 저장소 |
| **로컬 DB** | op-sqlite | 최신 안정 버전 | project-init 고정 스택. 오프라인 체크인 큐용 경량 SQLite |
| **인증** | Kakao OAuth, Google OAuth, Apple Auth | - | 조건부 의존성. 한국 시장 주요 3대 소셜 로그인 |
| **알림** | expo-notifications | - | 조건부 의존성. 체크인 리마인더 + 미응답 유예 푸시 |
| **분석** | Firebase Analytics | - | 조건부 의존성. MAU/DAU, 체크인 완료율, 유입 경로 추적 |
| **결제** | RevenueCat | - | 조건부 의존성. iOS/Android IAP 통합, 구독 상태·영수증 검증·무료 체험 관리 내장 |
| **캘린더** | react-native-calendars | - | 조건부 의존성. 안부 타임라인 달력 뷰 |
| **햅틱** | expo-haptics | - | 조건부 의존성. 체크인 버튼 탭, 유예 알림 진동 피드백 |
| **애니메이션** | Lottie | - | 조건부 의존성. 체크인 성공 애니메이션, 온보딩 일러스트 |
| **DB 확장 (pg_cron)** | pg_cron | Supabase 기본 확장 | 미응답 감지(F2), 유예 만료(F3), 알림 재시도(F9) 스케줄링. 1분/5분 주기 cron 실행 |
| **DB 확장 (pg_net)** | pg_net | Supabase 기본 확장 | DB Function에서 Edge Function HTTP 호출(net.http_post). cron → Edge Function 트리거 연동 |
| **빌드** | EAS Build + EAS Submit | - | Expo 공식 빌드/배포 파이프라인 |

> **project-init 조건부 매핑 미지원 — 수동 설치 필요**: 알리고 SMS API (npm 공식 패키지 없음, Edge Function에서 REST API 직접 호출), 카카오 비즈메시지 API (Edge Function에서 REST API 직접 호출)

### 7-2. 시스템 구조도

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Client (React Native / Expo)                     │
│                                                                      │
│  ┌──────────┐  ┌──────────┐  ┌───────────┐  ┌────────────────────┐  │
│  │  Expo    │  │  Zustand  │  │  op-sqlite │  │  react-native-    │  │
│  │  Router  │  │  Stores   │  │  (오프라인 │  │  mmkv (KV)        │  │
│  │  (라우팅)│  │  (상태)   │  │   체크인큐)│  │  (설정/토큰)      │  │
│  └────┬─────┘  └────┬─────┘  └─────┬─────┘  └───────┬────────────┘  │
│       │             │              │                  │               │
│  ┌────┴─────────────┴──────────────┴──────────────────┴────────────┐  │
│  │                     Service Layer                                │  │
│  │  ┌──────────────┐  ┌───────────────┐  ┌──────────────────────┐  │  │
│  │  │ Auth Service  │  │ Sync Service   │  │ Notification Svc     │  │  │
│  │  │ (OAuth)       │  │ (오프라인→     │  │ (expo-notifications  │  │  │
│  │  │               │  │  서버 동기화)  │  │  로컬 스케줄링)      │  │  │
│  │  └───────────────┘  └───────────────┘  └──────────────────────┘  │  │
│  │  ┌──────────────┐  ┌───────────────┐  ┌──────────────────────┐  │  │
│  │  │ IAP Service   │  │ Checkin Svc    │  │ Analytics Svc        │  │  │
│  │  │ (RevenueCat)  │  │ (체크인 로직)  │  │ (Firebase Analytics) │  │  │
│  │  └───────────────┘  └───────────────┘  └──────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
└───────────────────────────┬────────────────────────────────────────────┘
                            │ HTTPS (TLS 1.3)
                            ▼
┌────────────────────────────────────────────────────────────────────────┐
│                      Supabase Platform                                  │
│                                                                         │
│  ┌─────────────────┐  ┌──────────────────┐  ┌───────────────────────┐  │
│  │  Supabase Auth   │  │  PostgREST       │  │  Edge Functions       │  │
│  │  (OAuth 프록시)  │  │  (자동 REST API) │  │  (Deno Runtime)       │  │
│  │                  │  │                  │  │                       │  │
│  │  - Kakao OAuth   │  │  - checkins CRUD │  │  - check-overdue      │  │
│  │  - Google OAuth  │  │  - contacts CRUD │  │  - send-consent-sms   │  │
│  │  - Apple Auth    │  │  - settings CRUD │  │  - verify-consent     │  │
│  │                  │  │  - RLS 적용      │  │  - send-emergency-    │  │
│  │                  │  │                  │  │    alert              │  │
│  │                  │  │                  │  │  - cancel-grace        │  │
│  │                  │  │                  │  │  - retry-alert         │  │
│  │                  │  │                  │  │  - verify-subscription │  │
│  │                  │  │                  │  │  - delete-account      │  │
│  └────────┬─────────┘  └────────┬─────────┘  └───────────┬───────────┘  │
│           │                     │                         │              │
│  ┌────────┴─────────────────────┴─────────────────────────┴────────────┐ │
│  │                    PostgreSQL 15+                                    │ │
│  │                                                                     │ │
│  │  ┌───────────┐ ┌───────────┐ ┌────────────────┐ ┌───────────────┐  │ │
│  │  │ profiles  │ │ checkins  │ │ emergency_     │ │ user_settings │  │ │
│  │  │           │ │           │ │ contacts       │ │               │  │ │
│  │  └───────────┘ └───────────┘ └────────────────┘ └───────────────┘  │ │
│  │  ┌───────────┐ ┌───────────┐ ┌────────────────┐                    │ │
│  │  │ alert_    │ │ subscri-  │ │ grace_         │                    │ │
│  │  │ logs      │ │ ptions    │ │ periods        │                    │ │
│  │  └───────────┘ └───────────┘ └────────────────┘                    │ │
│  │                                                                     │ │
│  │  RLS: 모든 테이블에 user_id = auth.uid() 정책 적용                 │ │
│  └─────────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐ │
│  │  pg_cron (Supabase 확장)                                            │ │
│  │  - 매 1분: check_overdue_checkins() — 미응답 사용자 감지            │ │
│  │  - 매 5분: check_overdue_checkins() — catch-up 보조 감지            │ │
│  │  - 매 1분: process_expired_grace_periods() — 유예 만료 알림 발송    │ │
│  │  - 매 1분: retry_failed_alerts() — 실패한 알림 재발송               │ │
│  └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘

외부 서비스:
  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
  │  RevenueCat   │  │  Expo Push    │  │  알리고 API   │  │  카카오 비즈  │
  │  (구독 관리)  │  │  (푸시 알림)  │  │  (SMS 발송)  │  │  (알림톡)    │
  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘
  ┌──────────────┐
  │  Firebase     │
  │  Analytics    │
  └──────────────┘
```

### 7-3. 오프라인 우선 설계

#### 7-3-1. 로컬 저장소 선택 및 근거

| 저장소 | 역할 | 근거 |
|--------|------|------|
| **react-native-mmkv** | 사용자 설정, 인증 토큰, 온보딩 상태, 구독 상태 캐시, 마지막 체크인 시각, 다음 체크인 마감 시각 | JSI 기반 초고속(0.03ms read). key-value 데이터에 최적. 암호화 지원으로 토큰 안전 저장 |
| **op-sqlite** | 오프라인 체크인 큐(sync_queue), 체크인 기록 로컬 캐시(최근 90일) | 오프라인 체크인 저장 + FIFO 큐 관리에 SQL 적합. 달력 뷰 로컬 캐시로 2초 이내 로딩 달성 |

#### 7-3-2. 저장소별 역할 분담

| 데이터 | 저장소 | 동기화 방향 | 비고 |
|--------|--------|-----------|------|
| 인증 토큰 (access/refresh) | MMKV | 서버→로컬 | Supabase Auth 자동 관리, MMKV에 캐시 |
| 온보딩 완료 플래그 | MMKV | 서버→로컬 | 서버 profiles.has_completed_onboarding 동기화 |
| 체크인 주기/알림 시간 | MMKV | 양방향 | 서버에도 저장하여 재설치 시 복원 |
| 구독 상태 캐시 | MMKV | 서버→로컬 | RevenueCat SDK 자체 캐시 + MMKV 플래그 |
| 마지막 체크인 시각 | MMKV | 서버→로컬 | 홈 화면 카운트다운 즉시 표시용 |
| 다음 체크인 마감 시각 | MMKV | 서버→로컬 | 홈 화면 카운트다운 즉시 표시용 |
| 체크인 기록 (오프라인 큐) | op-sqlite | 로컬→서버 | 오프라인 생성 후 서버 동기화 |
| 체크인 기록 캐시 (90일) | op-sqlite | 서버→로컬 | 달력 뷰 로컬 캐시 |
| 긴급연락처 캐시 | op-sqlite | 서버→로컬 | 연락처 목록 오프라인 조회용 |

#### 7-3-3. 동기화 큐 로직

```
[오프라인 체크인 흐름]

1. 사용자가 "살았어" 버튼 탭
2. NetworkInfo 확인
   ├─ 온라인 → Supabase REST API 직접 저장
   │          → 성공 시 MMKV 마지막 체크인/다음 마감 업데이트
   │          → 로컬 캐시(op-sqlite) 업데이트
   └─ 오프라인 → op-sqlite sync_queue에 INSERT (status='pending')
               → MMKV 마지막 체크인/다음 마감 낙관적 업데이트
               → UI 즉시 반영 (낙관적 업데이트)
3. 네트워크 복구 감지 (NetInfo 리스너)
4. SyncService 트리거
   ├─ sync_queue에서 status='pending' 레코드를 created_at ASC 순서로 조회
   ├─ 건별 Supabase REST API 호출
   │   ├─ 성공 → sync_queue status='synced'
   │   └─ 실패 → retry_count++, 재시도 로직 진입
   └─ 전체 완료 후 로컬 캐시 갱신
5. [오알림 방지] 동기화 후 활성 유예 확인 및 자동 취소
   ├─ grace_periods에서 status='active'인 유예 조회
   ├─ 동기화된 체크인의 checked_in_at이 유예 started_at 이전인지 확인
   │   ├─ 이전 → cancel-grace Edge Function 호출 (유예 취소 + 체크인 처리)
   │   │         → 아직 발송되지 않은 alert_logs status='pending'도 'cancelled'로 변경
   │   └─ 이후 → 유예 유지 (정상적으로 미응답 상태)
   └─ 취소 성공 시 UI에 "체크인이 정상 반영되었습니다" 토스트 표시
```

**재시도 전략:**

| 재시도 횟수 | 대기 시간 | 전략 |
|------------|----------|------|
| 1회 | 2초 | 즉시 재시도 |
| 2회 | 4초 | 지수 백오프 (2^retry × 1초) |
| 3회 | 8초 | 지수 백오프 |
| 4회 | 16초 | 지수 백오프 |
| 5회 (최대) | 30초 | 최대 대기 시간 cap |
| 5회 실패 후 | - | status='failed', 다음 앱 포그라운드 전환 시 재시도 |

**최대 큐 크기**: 200건 (사용자당 일 평균 1건 × 200일분. 초과 시 가장 오래된 synced 레코드 삭제)

#### 7-3-4. 충돌 해결 정책

**Server Wins (서버 우선)** 정책을 채택한다.

| 시나리오 | 처리 |
|----------|------|
| 오프라인에서 체크인 → 서버에 해당 주기 기록 없음 | 서버에 INSERT (충돌 없음) |
| 오프라인에서 체크인 → 서버에 동일 주기 체크인 존재 | 서버 버전 우선 (updated_at 비교), 로컬 덮어쓰기 |
| 오프라인에서 설정 변경 → 서버에서도 변경됨 | 서버 버전 우선 |

**근거**: 안전 앱 특성상 서버의 미응답 감지 cron이 정확한 체크인 시각을 참조해야 하므로, 서버를 single source of truth로 유지한다. 오프라인 체크인은 동기화 시 서버 타임스탬프로 보정된다.

### 7-4. 핵심 설계 원칙

| # | 원칙 | 설명 |
|---|------|------|
| 1 | **Safety-Critical Server Authority** | 미응답 감지·알림 발송은 반드시 서버(pg_cron + Edge Function)에서 실행. 클라이언트 의존 금지. 사용자 기기가 꺼져 있어도 알림이 발송되어야 하므로 서버 주도 아키텍처 |
| 2 | **Offline-First Optimistic UI** | 체크인은 오프라인에서도 즉시 로컬 저장 + UI 반영. 네트워크 복구 시 서버 동기화. 체크인 버튼의 1초 이내 응답 보장 |
| 3 | **RLS-Only Security** | 모든 데이터 접근 제어를 PostgreSQL RLS로 구현. Supabase Auth + RLS만으로 보안 확보. 별도 미들웨어 없음 |
| 4 | **Edge Function for External I/O** | 단순 CRUD는 PostgREST, 외부 API 호출(SMS, 카카오, RevenueCat)이 필요한 로직은 Edge Function으로 분리 |
| 5 | **Graceful Degradation** | SMS 실패→재시도 3회, 카카오 실패→SMS 폴백, Supabase 장애→오프라인 체크인 로컬 저장. 단일 장애점 없음 |

### 7-5. DB 스키마

#### 7-5-1. 테이블 정의

```sql
-- ============================================================
-- 1. profiles: 사용자 프로필
-- ============================================================
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name TEXT NOT NULL DEFAULT '',
  avatar_url TEXT,
  has_completed_onboarding BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_profiles_created_at ON public.profiles(created_at);

-- ============================================================
-- 2. user_settings: 사용자 설정
-- ============================================================
CREATE TABLE public.user_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  check_in_interval_hours SMALLINT NOT NULL DEFAULT 24
    CHECK (check_in_interval_hours IN (12, 24, 48)),
  reminder_time TIME NOT NULL DEFAULT '09:00:00',
  timezone TEXT NOT NULL DEFAULT 'Asia/Seoul',
  location_sharing_enabled BOOLEAN NOT NULL DEFAULT FALSE,
  push_token TEXT,                            -- expo-notifications push token
  is_paused BOOLEAN NOT NULL DEFAULT FALSE,   -- 일시정지 모드 (P1)
  paused_until TIMESTAMPTZ,                   -- 일시정지 종료 시각 (P1)
  first_deadline_at TIMESTAMPTZ,             -- 온보딩 완료 시 첫 체크인 마감 설정
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 참고: user_id UNIQUE 제약이 유니크 인덱스를 자동 생성하므로 별도 인덱스 불필요
CREATE INDEX idx_user_settings_paused ON public.user_settings(is_paused) WHERE is_paused = TRUE;
-- 미응답 감지 cron 최적화: first_deadline_at 기반 신규 사용자 감지
CREATE INDEX idx_user_settings_first_deadline ON public.user_settings(first_deadline_at)
  WHERE first_deadline_at IS NOT NULL;

-- ============================================================
-- 3. emergency_contacts: 긴급연락처
-- ============================================================
CREATE TABLE public.emergency_contacts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  phone_number TEXT NOT NULL,                 -- 암호화 저장 (pgcrypto)
  relationship TEXT NOT NULL DEFAULT '기타'
    CHECK (relationship IN ('부모', '자녀', '배우자', '형제자매', '친구', '이웃', '기타')),
  consent_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (consent_status IN ('pending', 'accepted', 'declined')),
  consent_token UUID DEFAULT gen_random_uuid(),  -- 동의 확인용 일회성 토큰
  consent_requested_at TIMESTAMPTZ,
  consent_responded_at TIMESTAMPTZ,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,    -- 유료→무료 전환 시 비활성화용
  sort_order SMALLINT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_emergency_contacts_user ON public.emergency_contacts(user_id);
CREATE INDEX idx_emergency_contacts_consent ON public.emergency_contacts(consent_token)
  WHERE consent_status = 'pending';

-- 사용자당 최대 3명 제한 (트리거로 구현)
CREATE OR REPLACE FUNCTION check_max_contacts()
RETURNS TRIGGER AS $$
BEGIN
  IF (SELECT COUNT(*) FROM public.emergency_contacts
      WHERE user_id = NEW.user_id AND is_active = TRUE) >= 3 THEN
    RAISE EXCEPTION 'Maximum 3 active emergency contacts allowed per user';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_max_contacts
  BEFORE INSERT ON public.emergency_contacts
  FOR EACH ROW EXECUTE FUNCTION check_max_contacts();

-- ============================================================
-- 4. checkins: 체크인 기록 (핵심 테이블)
-- ============================================================
CREATE TABLE public.checkins (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  checked_in_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  memo TEXT CHECK (char_length(memo) <= 100),
  latitude DOUBLE PRECISION,                  -- 위치 (P1, 선택)
  longitude DOUBLE PRECISION,                 -- 위치 (P1, 선택)
  source TEXT NOT NULL DEFAULT 'app'
    CHECK (source IN ('app', 'push', 'grace_cancel')),  -- 체크인 경로
  next_deadline_at TIMESTAMPTZ NOT NULL,      -- 다음 체크인 마감 시각
  is_offline_sync BOOLEAN NOT NULL DEFAULT FALSE,  -- 오프라인 동기화 여부
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_checkins_user_deadline ON public.checkins(user_id, next_deadline_at DESC);
CREATE INDEX idx_checkins_user_date ON public.checkins(user_id, checked_in_at DESC);
-- 미응답 감지 cron용 인덱스 (next_deadline_at 범위 스캔)
CREATE INDEX idx_checkins_deadline_asc ON public.checkins(next_deadline_at ASC, user_id);

-- ============================================================
-- 5. grace_periods: 유예 기간 관리
-- ============================================================
CREATE TABLE public.grace_periods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  checkin_id UUID REFERENCES public.checkins(id),       -- 유예 취소 시 생성된 체크인
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,                      -- started_at + 5분
  status TEXT NOT NULL DEFAULT 'active'
    CHECK (status IN ('active', 'cancelled', 'expired')),
  cancelled_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_grace_periods_active ON public.grace_periods(expires_at)
  WHERE status = 'active';
CREATE INDEX idx_grace_periods_user ON public.grace_periods(user_id, created_at DESC);

-- ============================================================
-- 6. alert_logs: 긴급 알림 발송 이력
-- ============================================================
CREATE TABLE public.alert_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  grace_period_id UUID REFERENCES public.grace_periods(id),
  contact_id UUID NOT NULL REFERENCES public.emergency_contacts(id),
  channel TEXT NOT NULL
    CHECK (channel IN ('sms', 'kakao', 'push')),
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'sent', 'failed', 'cancelled')),
  external_message_id TEXT,                   -- 알리고/카카오 API 응답 ID
  retry_count SMALLINT NOT NULL DEFAULT 0,
  error_message TEXT,
  sent_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_alert_logs_user ON public.alert_logs(user_id, created_at DESC);
CREATE INDEX idx_alert_logs_pending ON public.alert_logs(status, retry_count)
  WHERE status IN ('pending', 'failed');
CREATE INDEX idx_alert_logs_grace ON public.alert_logs(grace_period_id);

-- ============================================================
-- 7. subscriptions: 구독 정보
-- ============================================================
CREATE TABLE public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  plan TEXT NOT NULL DEFAULT 'free'
    CHECK (plan IN ('free', 'premium_monthly', 'premium_yearly')),
  status TEXT NOT NULL DEFAULT 'active'
    CHECK (status IN ('active', 'expired', 'cancelled', 'trial')),
  provider TEXT
    CHECK (provider IN ('apple', 'google', 'manual')),
  provider_subscription_id TEXT,              -- RevenueCat subscription ID
  trial_started_at TIMESTAMPTZ,
  trial_ends_at TIMESTAMPTZ,
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 참고: user_id UNIQUE 제약이 유니크 인덱스를 자동 생성하므로 별도 인덱스 불필요
CREATE INDEX idx_subscriptions_status ON public.subscriptions(status)
  WHERE status IN ('active', 'trial');
```

#### 7-5-2. RLS 정책 (CRUD 권한 매트릭스)

| 테이블 | SELECT | INSERT | UPDATE | DELETE | 정책 |
|--------|--------|--------|--------|--------|------|
| profiles | 본인만 | 자동(트리거) | 본인만 | 본인만 | `auth.uid() = id` |
| user_settings | 본인만 | 본인만 | 본인만 | - | `auth.uid() = user_id` |
| emergency_contacts | 본인만 | 본인만 | 본인만 | 본인만 | `auth.uid() = user_id` |
| checkins | 본인만 | 본인만 | 본인만 | - | `auth.uid() = user_id` |
| grace_periods | 본인만 | 서버만 | 본인(취소)+서버 | - | SELECT: `auth.uid() = user_id`, INSERT/UPDATE: `service_role` |
| alert_logs | 본인만 | 서버만 | 서버만 | - | SELECT: `auth.uid() = user_id`, INSERT/UPDATE: `service_role` |
| subscriptions | 본인만 | 서버만 | 서버만 | - | SELECT: `auth.uid() = user_id`, INSERT/UPDATE: `service_role` |

```sql
-- RLS 활성화
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.emergency_contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.checkins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.grace_periods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.alert_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

-- profiles
CREATE POLICY "profiles_select_own" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "profiles_update_own" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "profiles_delete_own" ON public.profiles FOR DELETE USING (auth.uid() = id);

-- user_settings
CREATE POLICY "settings_select_own" ON public.user_settings FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "settings_insert_own" ON public.user_settings FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "settings_update_own" ON public.user_settings FOR UPDATE USING (auth.uid() = user_id);

-- emergency_contacts
CREATE POLICY "contacts_select_own" ON public.emergency_contacts FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "contacts_insert_own" ON public.emergency_contacts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "contacts_update_own" ON public.emergency_contacts FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "contacts_delete_own" ON public.emergency_contacts FOR DELETE USING (auth.uid() = user_id);

-- checkins
CREATE POLICY "checkins_select_own" ON public.checkins FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "checkins_insert_own" ON public.checkins FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "checkins_update_own" ON public.checkins FOR UPDATE USING (auth.uid() = user_id);

-- grace_periods (SELECT: 본인, INSERT/UPDATE: service_role via Edge Function)
CREATE POLICY "grace_select_own" ON public.grace_periods FOR SELECT USING (auth.uid() = user_id);

-- alert_logs (SELECT: 본인만)
CREATE POLICY "alerts_select_own" ON public.alert_logs FOR SELECT USING (auth.uid() = user_id);

-- subscriptions (SELECT: 본인만)
CREATE POLICY "subs_select_own" ON public.subscriptions FOR SELECT USING (auth.uid() = user_id);
```

#### 7-5-3. 핵심 DB Function (SQL 본문)

```sql
-- ============================================================
-- F1. handle_new_user: 신규 사용자 생성 시 자동 프로필/설정/구독 생성
-- ============================================================
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- 프로필 생성
  INSERT INTO public.profiles (id, display_name)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name', '')
  );

  -- 기본 설정 생성
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id);

  -- 무료 구독 생성
  INSERT INTO public.subscriptions (user_id, plan, status)
  VALUES (NEW.id, 'free', 'active');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ============================================================
-- F2. check_overdue_checkins: 미응답 사용자 감지
-- pg_cron에서 매 1분 실행
-- [성능 주의] DISTINCT ON + 이중 NOT EXISTS 조합.
--   사용자 10만+, 체크인 수십만 건 시 성능 저하 가능.
--   운영 시 EXPLAIN ANALYZE로 쿼리 플랜 확인 권장.
--   statement_timeout을 설정하여 cron 중첩 실행 방지.
-- ============================================================
CREATE OR REPLACE FUNCTION public.check_overdue_checkins()
RETURNS void
SECURITY DEFINER
SET search_path = public
SET statement_timeout = '50s'  -- 1분 cron 주기 내 완료 보장, 중첩 실행 방지
AS $$
DECLARE
  overdue_user RECORD;
BEGIN
  -- [Case 1] 기존 사용자: 마지막 체크인의 마감 시각이 지난 경우
  FOR overdue_user IN
    SELECT DISTINCT ON (c.user_id)
      c.user_id,
      c.id AS checkin_id,
      c.next_deadline_at,
      c.checked_in_at,
      us.push_token,
      us.is_paused
    FROM public.checkins c
    INNER JOIN public.user_settings us ON us.user_id = c.user_id
    WHERE c.next_deadline_at <= NOW()
      AND us.is_paused = FALSE
      AND NOT EXISTS (
        -- 마감 이후에 새로운 체크인이 없는 경우만
        SELECT 1 FROM public.checkins c2
        WHERE c2.user_id = c.user_id
          AND c2.checked_in_at > c.next_deadline_at
      )
      AND NOT EXISTS (
        -- 이미 활성 유예 기간이 없는 경우만
        SELECT 1 FROM public.grace_periods gp
        WHERE gp.user_id = c.user_id
          AND gp.status = 'active'
      )
    ORDER BY c.user_id, c.next_deadline_at DESC
  LOOP
    -- 유예 기간 생성 (5분)
    INSERT INTO public.grace_periods (user_id, expires_at)
    VALUES (overdue_user.user_id, NOW() + INTERVAL '5 minutes');

    -- Edge Function 호출을 위한 알림 큐 등록
    -- (pg_net 확장 또는 Supabase Database Webhook으로 Edge Function 트리거)
    PERFORM net.http_post(
      url := current_setting('app.edge_function_url') || '/check-overdue',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || current_setting('app.service_role_key')
      ),
      body := jsonb_build_object(
        'user_id', overdue_user.user_id,
        'push_token', overdue_user.push_token
      )
    );
  END LOOP;

  -- [Case 2] 신규 사용자: 온보딩 후 첫 체크인 없이 first_deadline_at 경과
  FOR overdue_user IN
    SELECT us.user_id, us.push_token
    FROM public.user_settings us
    WHERE us.first_deadline_at IS NOT NULL
      AND us.first_deadline_at <= NOW()
      AND us.is_paused = FALSE
      AND NOT EXISTS (
        SELECT 1 FROM public.checkins c WHERE c.user_id = us.user_id
      )
      AND NOT EXISTS (
        SELECT 1 FROM public.grace_periods gp
        WHERE gp.user_id = us.user_id AND gp.status = 'active'
      )
  LOOP
    INSERT INTO public.grace_periods (user_id, expires_at)
    VALUES (overdue_user.user_id, NOW() + INTERVAL '5 minutes');

    PERFORM net.http_post(
      url := current_setting('app.edge_function_url') || '/check-overdue',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || current_setting('app.service_role_key')
      ),
      body := jsonb_build_object(
        'user_id', overdue_user.user_id,
        'push_token', overdue_user.push_token
      )
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- pg_cron 등록 (매 1분)
SELECT cron.schedule(
  'check-overdue-checkins',
  '* * * * *',
  $$SELECT public.check_overdue_checkins()$$
);

-- ============================================================
-- F3. process_expired_grace_periods: 유예 만료 후 알림 발송 트리거
-- pg_cron에서 매 1분 실행
-- ============================================================
CREATE OR REPLACE FUNCTION public.process_expired_grace_periods()
RETURNS void
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  expired_grace RECORD;
BEGIN
  FOR expired_grace IN
    SELECT
      gp.id AS grace_period_id,
      gp.user_id,
      p.display_name AS user_name
    FROM public.grace_periods gp
    INNER JOIN public.profiles p ON p.id = gp.user_id
    WHERE gp.status = 'active'
      AND gp.expires_at <= NOW()
  LOOP
    -- 유예 상태를 expired로 변경
    UPDATE public.grace_periods
    SET status = 'expired'
    WHERE id = expired_grace.grace_period_id;

    -- Edge Function 호출하여 SMS/카카오 알림 발송
    PERFORM net.http_post(
      url := current_setting('app.edge_function_url') || '/send-emergency-alert',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || current_setting('app.service_role_key')
      ),
      body := jsonb_build_object(
        'user_id', expired_grace.user_id,
        'grace_period_id', expired_grace.grace_period_id,
        'user_name', expired_grace.user_name
      )
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT cron.schedule(
  'process-expired-grace',
  '* * * * *',
  $$SELECT public.process_expired_grace_periods()$$
);

-- ============================================================
-- F4. get_checkins_by_month: 월별 체크인 조회 (달력 뷰용)
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_checkins_by_month(
  p_user_id UUID,
  p_year INTEGER,
  p_month INTEGER
)
RETURNS TABLE (
  checkin_date DATE,
  checked_in_at TIMESTAMPTZ,
  memo TEXT,
  source TEXT,
  has_alert BOOLEAN
)
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    DATE(c.checked_in_at AT TIME ZONE 'Asia/Seoul') AS checkin_date,
    c.checked_in_at,
    c.memo,
    c.source,
    EXISTS (
      SELECT 1 FROM public.alert_logs al
      WHERE al.user_id = c.user_id
        AND al.status = 'sent'
        AND DATE(al.created_at AT TIME ZONE 'Asia/Seoul') = DATE(c.checked_in_at AT TIME ZONE 'Asia/Seoul')
    ) AS has_alert
  FROM public.checkins c
  WHERE c.user_id = p_user_id
    AND EXTRACT(YEAR FROM c.checked_in_at AT TIME ZONE 'Asia/Seoul') = p_year
    AND EXTRACT(MONTH FROM c.checked_in_at AT TIME ZONE 'Asia/Seoul') = p_month
  ORDER BY c.checked_in_at ASC;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- F5. get_user_checkin_status: 현재 체크인 상태 조회 (홈 화면용)
-- [성능 주의] 스트릭 계산이 ROW_NUMBER 기반 서브쿼리 2중첩 구조.
--   체크인 수천 건 이상 시 성능 이슈 가능.
--   사용자 규모 1만+ 도달 후 별도 streak 칼럼 또는
--   materialized view로 최적화 검토 권장.
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_user_checkin_status(p_user_id UUID)
RETURNS TABLE (
  last_checkin_at TIMESTAMPTZ,
  next_deadline_at TIMESTAMPTZ,
  check_in_interval_hours SMALLINT,
  current_streak INTEGER,
  is_overdue BOOLEAN,
  active_grace_id UUID,
  grace_expires_at TIMESTAMPTZ
)
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.checked_in_at AS last_checkin_at,
    c.next_deadline_at,
    us.check_in_interval_hours,
    -- 연속 체크인 스트릭 계산 (연속된 날짜 기준)
    (
      SELECT COUNT(*)::INTEGER
      FROM (
        SELECT DATE(c2.checked_in_at AT TIME ZONE 'Asia/Seoul') AS d,
               DATE(c2.checked_in_at AT TIME ZONE 'Asia/Seoul') -
               ROW_NUMBER() OVER (ORDER BY DATE(c2.checked_in_at AT TIME ZONE 'Asia/Seoul'))::INTEGER AS grp
        FROM public.checkins c2
        WHERE c2.user_id = p_user_id
        GROUP BY DATE(c2.checked_in_at AT TIME ZONE 'Asia/Seoul')
      ) streak
      WHERE grp = (
        SELECT DATE(c3.checked_in_at AT TIME ZONE 'Asia/Seoul') -
               ROW_NUMBER() OVER (ORDER BY DATE(c3.checked_in_at AT TIME ZONE 'Asia/Seoul'))::INTEGER
        FROM public.checkins c3
        WHERE c3.user_id = p_user_id
        GROUP BY DATE(c3.checked_in_at AT TIME ZONE 'Asia/Seoul')
        ORDER BY DATE(c3.checked_in_at AT TIME ZONE 'Asia/Seoul') DESC
        LIMIT 1
      )
    ) AS current_streak,
    (c.next_deadline_at <= NOW()) AS is_overdue,
    gp.id AS active_grace_id,
    gp.expires_at AS grace_expires_at
  FROM public.checkins c
  INNER JOIN public.user_settings us ON us.user_id = c.user_id
  LEFT JOIN public.grace_periods gp ON gp.user_id = c.user_id AND gp.status = 'active'
  WHERE c.user_id = p_user_id
  ORDER BY c.checked_in_at DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- F6. delete_user_account: 계정 완전 삭제 (PIPA 준수)
-- ============================================================
CREATE OR REPLACE FUNCTION public.delete_user_account(p_user_id UUID)
RETURNS void
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- CASCADE 설정으로 모든 관련 데이터 자동 삭제
  -- 명시적으로 순서대로 삭제 (감사 로그 목적)
  DELETE FROM public.alert_logs WHERE user_id = p_user_id;
  DELETE FROM public.grace_periods WHERE user_id = p_user_id;
  DELETE FROM public.checkins WHERE user_id = p_user_id;
  DELETE FROM public.emergency_contacts WHERE user_id = p_user_id;
  DELETE FROM public.subscriptions WHERE user_id = p_user_id;
  DELETE FROM public.user_settings WHERE user_id = p_user_id;
  DELETE FROM public.profiles WHERE id = p_user_id;

  -- Supabase Auth에서 사용자 삭제
  DELETE FROM auth.users WHERE id = p_user_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- F7. set_updated_at: 범용 updated_at 자동 갱신 트리거
-- ============================================================
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER trg_settings_updated_at
  BEFORE UPDATE ON public.user_settings
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER trg_contacts_updated_at
  BEFORE UPDATE ON public.emergency_contacts
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER trg_subscriptions_updated_at
  BEFORE UPDATE ON public.subscriptions
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- ============================================================
-- F8. 체크인 후 user_settings.first_deadline_at 초기화 (신규 사용자 대응)
-- 온보딩 완료 시 첫 체크인 마감 시각 설정. 이후 첫 체크인이 생기면 NULL로 리셋.
-- ============================================================
-- 온보딩 완료 시: 클라이언트가 PATCH user_settings에서 first_deadline_at = NOW() + interval 설정
-- 첫 체크인 INSERT 시 자동 해제:
CREATE OR REPLACE FUNCTION public.clear_first_deadline()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.user_settings
  SET first_deadline_at = NULL
  WHERE user_id = NEW.user_id
    AND first_deadline_at IS NOT NULL;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_clear_first_deadline_after_checkin
  AFTER INSERT ON public.checkins
  FOR EACH ROW EXECUTE FUNCTION public.clear_first_deadline();

-- ============================================================
-- F9. retry_failed_alerts: 실패한 알림 재시도
-- pg_cron에서 매 1분 실행. Edge Function 타임아웃 방지를 위해 분리.
-- ============================================================
CREATE OR REPLACE FUNCTION public.retry_failed_alerts()
RETURNS void
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  failed_alert RECORD;
BEGIN
  FOR failed_alert IN
    SELECT al.id, al.user_id, al.contact_id, al.channel, al.retry_count
    FROM public.alert_logs al
    WHERE al.status = 'failed'
      AND al.retry_count < 3
      AND al.created_at > NOW() - INTERVAL '30 minutes'
  LOOP
    PERFORM net.http_post(
      url := current_setting('app.edge_function_url') || '/retry-alert',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || current_setting('app.service_role_key')
      ),
      body := jsonb_build_object(
        'alert_log_id', failed_alert.id,
        'contact_id', failed_alert.contact_id,
        'channel', failed_alert.channel
      )
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT cron.schedule(
  'retry-failed-alerts',
  '* * * * *',
  $$SELECT public.retry_failed_alerts()$$
);

-- ============================================================
-- F10. calculate_next_deadline: 체크인 INSERT 시 next_deadline_at 자동 계산
-- 클라이언트가 next_deadline_at을 전송하지 않아도 서버에서 자동 설정.
-- 클라이언트가 값을 전송한 경우에도 서버 기준으로 재계산하여 정합성 보장.
-- ============================================================
CREATE OR REPLACE FUNCTION public.calculate_next_deadline()
RETURNS TRIGGER AS $$
DECLARE
  v_interval_hours SMALLINT;
BEGIN
  -- 사용자 설정에서 체크인 주기 조회
  SELECT check_in_interval_hours INTO v_interval_hours
  FROM public.user_settings
  WHERE user_id = NEW.user_id;

  -- 기본값 24시간 (설정 미존재 시 방어)
  IF v_interval_hours IS NULL THEN
    v_interval_hours := 24;
  END IF;

  -- next_deadline_at을 checked_in_at + 사용자 주기로 계산
  NEW.next_deadline_at := NEW.checked_in_at + (v_interval_hours || ' hours')::INTERVAL;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calculate_next_deadline
  BEFORE INSERT ON public.checkins
  FOR EACH ROW EXECUTE FUNCTION public.calculate_next_deadline();

-- ============================================================
-- F11. enforce_free_interval: 무료 사용자의 체크인 주기를 24시간으로 강제
-- UI 우회 방지를 위한 DB 레벨 검증.
-- ============================================================
CREATE OR REPLACE FUNCTION public.enforce_free_interval()
RETURNS TRIGGER AS $$
DECLARE
  v_plan TEXT;
BEGIN
  -- 체크인 주기가 변경되지 않았으면 통과
  IF OLD.check_in_interval_hours = NEW.check_in_interval_hours THEN
    RETURN NEW;
  END IF;

  -- 사용자 구독 플랜 조회
  SELECT plan INTO v_plan
  FROM public.subscriptions
  WHERE user_id = NEW.user_id
    AND status IN ('active', 'trial');

  -- 무료 사용자가 24시간 외의 주기로 변경 시도 시 차단
  IF (v_plan IS NULL OR v_plan = 'free') AND NEW.check_in_interval_hours != 24 THEN
    RAISE EXCEPTION 'Free plan users can only use 24-hour check-in interval. Upgrade to premium for 12h/48h options.';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_enforce_free_interval
  BEFORE UPDATE ON public.user_settings
  FOR EACH ROW EXECUTE FUNCTION public.enforce_free_interval();

-- ============================================================
-- 보조 안전장치: 5분 주기 catch-up cron
-- check_overdue_checkins()는 멱등하므로 중복 실행 안전.
-- 1분 cron이 누락되어도 최대 5분 내에 미응답 재감지.
-- ============================================================
SELECT cron.schedule(
  'catch-up-overdue',
  '*/5 * * * *',
  $$SELECT public.check_overdue_checkins()$$
);
```

### 7-6. API 설계

#### 7-6-1. Supabase REST vs Edge Function 선택 기준

| 기준 | Supabase REST (PostgREST) | Edge Function |
|------|--------------------------|---------------|
| 사용 조건 | 단순 CRUD, RLS로 권한 제어 가능 | 외부 API 호출, 복합 비즈니스 로직, service_role 필요 |
| 인증 | JWT 자동 검증 + RLS | JWT 수동 검증 또는 service_role |
| 장점 | 코드 작성 없이 자동 API | 유연한 로직, 외부 연동 |
| 단점 | 복잡한 로직 표현 한계 | 배포·유지보수 필요 |

#### 7-6-2. 엔드포인트 목록

**A. Supabase REST API (PostgREST 자동 생성)**

| 경로 | 메서드 | 설명 | 구현 방식 |
|------|--------|------|----------|
| `/rest/v1/profiles` | GET | 내 프로필 조회 | PostgREST + RLS |
| `/rest/v1/profiles` | PATCH | 프로필 수정 | PostgREST + RLS |
| `/rest/v1/user_settings` | GET | 내 설정 조회 | PostgREST + RLS |
| `/rest/v1/user_settings` | PATCH | 설정 수정 (주기, 알림 시간 등) | PostgREST + RLS |
| `/rest/v1/emergency_contacts` | GET | 긴급연락처 목록 | PostgREST + RLS |
| `/rest/v1/emergency_contacts` | POST | 긴급연락처 추가 | PostgREST + RLS |
| `/rest/v1/emergency_contacts` | PATCH | 긴급연락처 수정 | PostgREST + RLS |
| `/rest/v1/emergency_contacts` | DELETE | 긴급연락처 삭제 | PostgREST + RLS |
| `/rest/v1/checkins` | GET | 체크인 기록 조회 | PostgREST + RLS |
| `/rest/v1/checkins` | POST | 체크인 생성 | PostgREST + RLS |
| `/rest/v1/alert_logs` | GET | 알림 이력 조회 | PostgREST + RLS |
| `/rest/v1/subscriptions` | GET | 구독 상태 조회 | PostgREST + RLS |
| `/rest/v1/rpc/get_checkins_by_month` | POST | 월별 체크인 조회 (RPC) | PostgREST + DB Function |
| `/rest/v1/rpc/get_user_checkin_status` | POST | 현재 체크인 상태 (RPC) | PostgREST + DB Function |

**B. Edge Functions**

| 경로 | 메서드 | 설명 | 트리거 |
|------|--------|------|--------|
| `/functions/v1/send-consent-sms` | POST | 긴급연락처 동의 요청 SMS 발송 | 클라이언트 |
| `/functions/v1/verify-consent` | GET | 동의 확인 URL 처리 | 외부 링크 (SMS 내 URL) |
| `/functions/v1/check-overdue` | POST | 미응답 감지 후 유예 푸시 발송 | pg_cron (F2) |
| `/functions/v1/send-emergency-alert` | POST | 유예 만료 후 SMS/카카오 긴급 알림 | pg_cron (F3) |
| `/functions/v1/cancel-grace` | POST | 유예 취소 (체크인 처리) | 클라이언트 |
| `/functions/v1/verify-subscription` | POST | RevenueCat 웹훅 수신, 구독 상태 동기화 | RevenueCat Webhook |
| `/functions/v1/retry-alert` | POST | 실패한 알림 재발송 | pg_cron (F9) |
| `/functions/v1/delete-account` | POST | 계정 완전 삭제 | 클라이언트 |

#### 7-6-3. 핵심 TypeScript 인터페이스

```typescript
// ============================================================
// 공통 타입
// ============================================================
type CheckInInterval = 12 | 24 | 48;
type ConsentStatus = 'pending' | 'accepted' | 'declined';
type AlertChannel = 'sms' | 'kakao' | 'push';
type AlertStatus = 'pending' | 'sent' | 'failed' | 'cancelled';
type SubscriptionPlan = 'free' | 'premium_monthly' | 'premium_yearly';
type SubscriptionStatus = 'active' | 'expired' | 'cancelled' | 'trial';
type GraceStatus = 'active' | 'cancelled' | 'expired';
type CheckinSource = 'app' | 'push' | 'grace_cancel';
type Relationship = '부모' | '자녀' | '배우자' | '형제자매' | '친구' | '이웃' | '기타';

// ============================================================
// 체크인
// ============================================================
interface CreateCheckinRequest {
  memo?: string;          // 최대 100자
  latitude?: number;      // P1: 위치
  longitude?: number;     // P1: 위치
  source?: CheckinSource;
}

interface CreateCheckinResponse {
  id: string;
  checked_in_at: string;  // ISO 8601
  next_deadline_at: string;
  memo: string | null;
}

interface CheckinStatusResponse {
  last_checkin_at: string | null;
  next_deadline_at: string | null;
  check_in_interval_hours: CheckInInterval;
  current_streak: number;
  is_overdue: boolean;
  active_grace_id: string | null;
  grace_expires_at: string | null;
}

interface MonthlyCheckinsRequest {
  p_user_id: string;
  p_year: number;
  p_month: number;
}

interface MonthlyCheckinItem {
  checkin_date: string;     // YYYY-MM-DD
  checked_in_at: string;
  memo: string | null;
  source: CheckinSource;
  has_alert: boolean;
}

// ============================================================
// 긴급연락처
// ============================================================
interface CreateContactRequest {
  name: string;
  phone_number: string;   // 010-XXXX-XXXX 형식
  relationship: Relationship;
}

interface ContactResponse {
  id: string;
  name: string;
  phone_number: string;   // 마스킹: 010-****-1234
  relationship: Relationship;
  consent_status: ConsentStatus;
  is_active: boolean;
  sort_order: number;
}

interface UpdateContactRequest {
  name?: string;
  phone_number?: string;
  relationship?: Relationship;
  sort_order?: number;
}

// ============================================================
// Edge Function: 동의 요청 SMS
// ============================================================
interface SendConsentSmsRequest {
  contact_id: string;
}

interface SendConsentSmsResponse {
  success: boolean;
  message: string;
}

// ============================================================
// Edge Function: 유예 취소
// ============================================================
interface CancelGraceRequest {
  grace_period_id: string;
}

interface CancelGraceResponse {
  success: boolean;
  checkin_id: string;     // 취소로 생성된 체크인 ID
  next_deadline_at: string;
}

// ============================================================
// Edge Function: 긴급 알림 발송 (서버 전용)
// ============================================================
interface SendEmergencyAlertRequest {
  user_id: string;
  grace_period_id: string;
  user_name: string;
}

interface SendEmergencyAlertResponse {
  success: boolean;
  alerts_sent: number;
  alerts_failed: number;
  results: Array<{
    contact_id: string;
    channel: AlertChannel;
    status: AlertStatus;
    error?: string;
  }>;
}

// ============================================================
// Edge Function: 구독 검증 (RevenueCat Webhook)
// ============================================================
interface VerifySubscriptionRequest {
  api_version: string;
  event: {
    type: string;         // 'INITIAL_PURCHASE' | 'RENEWAL' | 'CANCELLATION' | 'EXPIRATION'
    app_user_id: string;
    product_id: string;
    entitlement_id: string;
    period_type: string;
    purchased_at_ms: number;
    expiration_at_ms: number;
  };
}

// ============================================================
// Edge Function: 알림 재시도 (서버 전용)
// ============================================================
interface RetryAlertRequest {
  alert_log_id: string;
  contact_id: string;
  channel: AlertChannel;
}

interface RetryAlertResponse {
  success: boolean;
  new_status: AlertStatus;
  retry_count: number;
}

// ============================================================
// Edge Function: 동의 확인 (GET 파라미터)
// ============================================================
interface VerifyConsentParams {
  token: string;              // consent_token UUID
}

interface VerifyConsentResponse {
  success: boolean;
  contact_name: string;
  user_display_name: string;
}

// ============================================================
// Edge Function: 계정 삭제
// ============================================================
interface DeleteAccountResponse {
  success: boolean;
  message: string;
}

// ============================================================
// 설정
// ============================================================
interface UpdateSettingsRequest {
  check_in_interval_hours?: CheckInInterval;
  reminder_time?: string;    // HH:MM:SS
  location_sharing_enabled?: boolean;
  push_token?: string;
}

interface UserSettingsResponse {
  check_in_interval_hours: CheckInInterval;
  reminder_time: string;
  timezone: string;
  location_sharing_enabled: boolean;
  is_paused: boolean;
  paused_until: string | null;
}

// ============================================================
// 구독
// ============================================================
interface SubscriptionResponse {
  plan: SubscriptionPlan;
  status: SubscriptionStatus;
  trial_ends_at: string | null;
  current_period_end: string | null;
  is_premium: boolean;     // computed: plan !== 'free' && status in ['active', 'trial']
}
```

#### 7-6-4. Edge Function 비즈니스 로직

**EF-1: send-consent-sms (동의 요청 SMS 발송)**

```
1. JWT에서 user_id 추출, 요청 본문에서 contact_id 추출
2. emergency_contacts에서 contact_id 조회 (user_id 일치 검증)
3. consent_token 갱신 (gen_random_uuid)
4. 동의 확인 URL 생성: {APP_URL}/consent/{consent_token}
5. 알리고 SMS API 호출:
   - 수신번호: contact.phone_number (복호화)
   - 발신번호: 사전 등록된 발신번호
   - 메시지: "[살았니] {user_name}님이 귀하를 긴급연락처로 등록했습니다.
             동의하려면 아래 링크를 클릭해주세요: {consent_url}"
6. consent_requested_at 업데이트
7. 결과 반환
```

**EF-2: send-emergency-alert (긴급 알림 발송)**

```
1. service_role 인증 확인 (pg_cron에서만 호출)
2. user_id로 활성 긴급연락처(is_active=TRUE) 전체 조회
3. 사용자의 구독 상태 확인 (프리미엄 여부)
4. 사용자의 마지막 체크인 정보 조회 (시각, 위치)
5. 각 긴급연락처에 대해:
   a. SMS 발송 (알리고 API) — 즉시 1회 시도:
      - 메시지: "[살았니 긴급알림] {user_name}님이 {interval}시간 동안 체크인하지 않았습니다.
                마지막 체크인: {last_checkin_time}. 안부를 확인해주세요."
      - 결과를 alert_logs에 INSERT (status='sent' 또는 'failed')
      - ※ 재시도는 이 함수에서 하지 않음 → retry_failed_alerts cron(F9)이 1분 주기로 재처리
        (Edge Function 타임아웃 60초 제한 대응)
   b. 프리미엄 사용자인 경우 카카오 알림톡 추가 발송:
      - 카카오 비즈메시지 API 호출 — 즉시 1회 시도
      - 템플릿: 사전 승인된 알림톡 템플릿 사용
      - 위치 정보 포함 (location_sharing_enabled인 경우)
      - 발송 실패 시 alert_logs에 status='failed' 기록
        → 다음 retry_failed_alerts 주기에서 SMS 채널로 폴백 재시도
   c. alert_logs에 발송 결과 기록 (채널별 각 1건)
6. 전체 발송 결과 반환
```

**EF-3: cancel-grace (유예 취소)**

```
1. JWT에서 user_id 추출
2. grace_period_id로 유예 기간 조회 (user_id 일치 + status='active' 검증)
3. grace_periods.status를 'cancelled'로, cancelled_at를 NOW()로 업데이트
4. 해당 grace_period_id의 alert_logs 중 status='pending'인 건을
   'cancelled'로 변경 (아직 발송되지 않은 알림 사전 차단)
5. 새 체크인 생성 (source='grace_cancel', next_deadline_at = NOW() + interval)
6. 결과 반환 (새 체크인 ID, 다음 마감 시각)
```

**EF-4: verify-subscription (RevenueCat Webhook)**

```
1. RevenueCat 시크릿 키로 요청 서명 검증
2. event.type에 따라 분기:
   - INITIAL_PURCHASE / RENEWAL:
     a. subscriptions 테이블 upsert (plan, status='active', 기간 정보)
     b. 무료 사용자였다면 emergency_contacts 활성 개수 제한 해제
   - CANCELLATION:
     a. subscriptions.status를 'cancelled'로 업데이트
     b. current_period_end까지는 프리미엄 유지
   - EXPIRATION:
     a. subscriptions.status를 'expired'로, plan을 'free'로 업데이트
     b. emergency_contacts에서 sort_order가 가장 낮은 1명만 활성 유지,
        나머지를 is_active=FALSE로 비활성화:
        ```sql
        UPDATE emergency_contacts SET is_active = FALSE
        WHERE user_id = p_user_id
          AND id NOT IN (
            SELECT id FROM emergency_contacts
            WHERE user_id = p_user_id AND is_active = TRUE
            ORDER BY sort_order ASC, created_at ASC LIMIT 1
          );
        ```
     c. check_in_interval_hours를 24로 강제 리셋 (무료 기본값)
     d. 마지막 체크인의 next_deadline_at을 MAX(NOW() + 24h, 기존 next_deadline_at)로
        갱신하여 무료 전환 즉시 미응답 오탐 방지
3. 200 OK 반환
```

**EF-5: verify-consent (동의 확인 URL 처리)**

```
1. GET 파라미터에서 consent_token(UUID) 추출
2. emergency_contacts에서 consent_token 조회
3. consent_status가 'pending'인지 확인
   └─ 'pending'이 아닌 경우: "이미 처리된 요청입니다" 안내 페이지 반환
4. consent_status를 'accepted'로 업데이트
5. consent_responded_at를 NOW()로 기록
6. consent_token을 NULL로 무효화 (일회성 토큰)
7. HTML 결과 페이지 반환:
   - "동의가 완료되었습니다. {user_name}님의 긴급연락처로 등록되었습니다."
   - 앱 설치 유도 링크 포함 (Deep Link)
```

**EF-6: delete-account (계정 완전 삭제)**

```
1. JWT에서 user_id 추출 (본인 확인)
2. 활성 유예 기간(grace_periods status='active')이 있으면 'cancelled'로 처리
3. 활성 구독(subscriptions status in ['active','trial'])이 있으면
   RevenueCat API에 구독 해지 요청 → 실패해도 계정 삭제는 진행
4. DB Function delete_user_account(user_id) 호출
   → 모든 관련 테이블 데이터 순차 삭제 + auth.users 삭제
5. 성공 응답 반환: { success: true, message: "계정이 삭제되었습니다" }
```

**EF-7: retry-alert (실패한 알림 재발송)**

```
1. service_role 인증 확인 (pg_cron F9에서만 호출)
2. alert_log_id로 alert_logs 조회
3. 채널(channel)에 따라 재발송:
   a. 'sms': 알리고 API 재호출
   b. 'kakao': 카카오 비즈메시지 API 재호출
      └─ 재실패 시: channel을 'sms'로 변경하여 SMS 폴백 시도
4. 결과에 따라 alert_logs 업데이트:
   - 성공: status='sent', sent_at=NOW()
   - 실패: retry_count++, error_message 기록
   - 최대 3회 실패 시: status='failed' 확정 (더 이상 재시도 안 함)
5. 결과 반환
```

### 7-7. 상태 관리 구조

#### Zustand Store 목록

| Store | 역할 | 주요 상태 필드 |
|-------|------|---------------|
| **useAuthStore** | 인증 상태 관리 | `session: Session \| null`, `user: User \| null`, `isLoading: boolean`, `isAuthenticated: boolean` |
| **useCheckinStore** | 체크인 상태 관리 | `lastCheckinAt: string \| null`, `nextDeadlineAt: string \| null`, `currentStreak: number`, `isOverdue: boolean`, `isCheckinLoading: boolean`, `activeGraceId: string \| null`, `graceExpiresAt: string \| null` |
| **useContactStore** | 긴급연락처 관리 | `contacts: ContactResponse[]`, `isLoading: boolean`, `maxContacts: number` (무료 1/유료 3) |
| **useSettingsStore** | 사용자 설정 | `settings: UserSettingsResponse \| null`, `isOnboardingComplete: boolean` |
| **useSubscriptionStore** | 구독 상태 | `subscription: SubscriptionResponse \| null`, `isPremium: boolean`, `isTrialActive: boolean` |
| **useTimelineStore** | 타임라인 데이터 | `monthlyCheckins: Map<string, MonthlyCheckinItem[]>`, `selectedMonth: { year: number, month: number }`, `isLoading: boolean` |
| **useGraceStore** | 유예 상태 관리 | `isGraceActive: boolean`, `graceExpiresAt: string \| null`, `graceId: string \| null`, `remainingSeconds: number` |

#### Store 상세 설명

**useAuthStore**
- 역할: Supabase Auth 세션 관리, 소셜 로그인/로그아웃
- persist: MMKV에 세션 토큰 캐시
- actions: `signInWithKakao()`, `signInWithGoogle()`, `signInWithApple()`, `signOut()`, `restoreSession()`

**useCheckinStore**
- 역할: 체크인 실행, 상태 조회, 오프라인 체크인 큐 관리
- persist: MMKV에 lastCheckinAt, nextDeadlineAt 캐시 (앱 시작 시 즉시 표시용)
- actions: `performCheckin(memo?)`, `fetchCheckinStatus()`, `syncOfflineCheckins()`

**useContactStore**
- 역할: 긴급연락처 CRUD, 동의 요청 SMS 발송
- persist: op-sqlite에 연락처 캐시
- actions: `fetchContacts()`, `addContact(data)`, `updateContact(id, data)`, `deleteContact(id)`, `sendConsentSms(contactId)`

**useSettingsStore**
- 역할: 체크인 주기, 알림 시간, 프라이버시 설정 관리
- persist: MMKV에 설정 캐시
- actions: `fetchSettings()`, `updateSettings(data)`, `updatePushToken(token)`

**useSubscriptionStore**
- 역할: 구독 상태 관리, RevenueCat SDK 연동
- persist: MMKV에 isPremium 캐시 (빠른 UI 분기용)
- actions: `fetchSubscription()`, `purchaseMonthly()`, `purchaseYearly()`, `restorePurchases()`

**useTimelineStore**
- 역할: 달력 뷰 데이터 관리, 월별 체크인 조회
- persist: op-sqlite에 월별 체크인 캐시
- actions: `fetchMonthCheckins(year, month)`, `selectMonth(year, month)`

**useGraceStore**
- 역할: 5분 유예 상태 관리, 카운트다운 타이머
- persist: 없음 (실시간 상태만)
- actions: `startGrace(graceId, expiresAt)`, `cancelGrace(graceId)`, `tick()` (1초 카운트다운)

### 7-8. 기능-테이블-API 매핑표

| FR ID | 기능 | 테이블 | API (REST) | API (Edge Function) |
|-------|------|--------|-----------|-------------------|
| FR-01 | 소셜 로그인 | auth.users, profiles, user_settings, subscriptions | Supabase Auth SDK | - |
| FR-02 | 온보딩 플로우 | profiles, user_settings, emergency_contacts | PATCH profiles, PATCH user_settings, POST emergency_contacts | send-consent-sms |
| FR-03 | 체크인 | checkins | POST checkins, RPC get_user_checkin_status | - |
| FR-04 | 체크인 주기 설정 | user_settings | PATCH user_settings | - |
| FR-05 | 리마인더 푸시 | user_settings | GET user_settings (push_token) | check-overdue (푸시 발송) |
| FR-06 | 긴급연락처 관리 | emergency_contacts | GET/POST/PATCH/DELETE emergency_contacts | - |
| FR-07 | 동의 요청 SMS | emergency_contacts | - | send-consent-sms |
| FR-08 | 미응답 감지 | checkins, grace_periods | - | check-overdue (pg_cron 트리거) |
| FR-09 | 5분 유예 + 취소 | grace_periods, checkins | GET grace_periods | cancel-grace |
| FR-10 | SMS 긴급 알림 | alert_logs, emergency_contacts | GET alert_logs | send-emergency-alert, retry-alert |
| FR-11 | 카카오 알림톡 | alert_logs, emergency_contacts, subscriptions | GET alert_logs | send-emergency-alert, retry-alert |
| FR-12 | 안부 타임라인 | checkins, alert_logs | RPC get_checkins_by_month | - |
| FR-13 | 프리미엄 구독 | subscriptions | GET subscriptions | verify-subscription |
| FR-14 | 구독 관리 | subscriptions | GET subscriptions | verify-subscription |
| — | 계정 삭제 (PIPA §6-2 준수) | profiles, user_settings, emergency_contacts, checkins, grace_periods, alert_logs, subscriptions, auth.users | — | delete-account |

### 7-9. 자체 점검 결과

> v1.4: v5 리뷰 Minor 2건(C-M1, D-M1) 반영 완료
> - C-M1: §8-2 ContactListScreen, SettingsScreen, GraceAlertModal, OnboardingScreen의 API 경로를 §7-6-2 정식 엔드포인트로 통일
> - D-M1: §8-2 SubscriptionScreen의 라이브러리 표기를 react-native-iap → RevenueCat SDK로 수정, 엔드포인트를 `/functions/v1/verify-subscription`으로 정식화
>
> v1.3: v4 리뷰 Minor 5건(A-M1, C-M1, C-M2, C-M3, D-M1) 반영 완료
> - A-M1: §2-2, §9-2에 Demumu 중국 앱스토어 제거(2026.01.15) 사실 및 바이럴 소멸 가능성·마케팅 전략 방향 반영
> - C-M1: F2 check_overdue_checkins에 성능 주의 주석 + statement_timeout 50s 설정 추가
> - C-M2: F5 get_user_checkin_status에 스트릭 계산 최적화 방향 주석 추가
> - C-M3: §7-8 기능-테이블-API 매핑표에 계정 삭제(PIPA §6-2 준수) 행 추가
> - D-M1: §8-2 TimelineScreen API를 올바른 RPC 경로(POST /rest/v1/rpc/get_checkins_by_month)로 수정
> - 추가: §16 Glossary(용어 사전) 17개 항목 신규 작성

| # | 점검 항목 | 결과 | 비고 |
|---|----------|------|------|
| 1 | 모든 P0 기능에 번호 형식(AC-XX-X)의 수용 기준이 존재하는가 | ✅ 충족 | FR-01~FR-14 전체 AC 작성 완료 (섹션 5-2) |
| 2 | P0 기능별 DB 테이블·API 매핑이 매핑표에 존재하는가 | ✅ 충족 | 14개 P0 기능 모두 매핑 완료 (섹션 7-8) |
| 3 | DB 스키마의 FK 관계가 기능 간 데이터 흐름과 일치하는가 | ✅ 충족 | 7개 테이블 FK 일관. F10 트리거로 next_deadline_at 자동 계산 보장 |
| 4 | API 엔드포인트가 각 P0 수용 기준을 충족할 수 있는가 | ✅ 충족 | 체크인 1초(PostgREST), SMS 즉시 발송+cron 재시도, 유예 5분 |
| 5 | 핵심 API의 TypeScript 인터페이스(요청/응답)가 존재하는가 | ✅ 충족 | 전체 Edge Function 인터페이스 완비 (섹션 7-6-3) |
| 6 | 핵심 DB Function의 SQL 본문이 완성되었는가 (스텁이 아닌지) | ✅ 충족 | F1~F11 전체 SQL 본문 작성. v1.2에서 F10(calculate_next_deadline), F11(enforce_free_interval) 추가 |
| 7 | 오프라인 저장소·동기화·충돌 해결 정책이 명시되었는가 | ✅ 충족 | MMKV/op-sqlite 역할 분담, 동기화 큐 5단계, Server Wins 정책 (섹션 7-3) |
| 8 | 네비게이션 구조 트리 + 핵심 화면 UI 설명이 존재하는가 | ✅ 충족 | Auth Stack/Main Tab/Modal Stack 트리 + **8개** 핵심 화면 상세. v1.2에서 LoginScreen 추가 (섹션 8) |
| 9 | User Story가 모든 기능 영역(온보딩·인증·핵심·설정·결제)을 커버하는가 | ✅ 충족 | 7개 Epic, 27개 User Story (섹션 4) |

---

## 8. Screen Map & UI 명세

### 8-1. 네비게이션 구조 트리

```
Root
├── Auth Stack (미인증)
│   ├── SplashScreen
│   ├── LoginScreen (카카오/구글/애플 소셜 로그인)
│   └── OnboardingScreen
│       ├── Step1: 앱 소개 (스와이프)
│       ├── Step2: 체크인 주기 선택 (12h/24h/48h)
│       └── Step3: 긴급연락처 등록 (이름/전화번호/관계)
│
├── Main Tab Navigator (인증 완료)
│   ├── HomeTab — 체크인 홈
│   │   └── HomeScreen
│   ├── TimelineTab — 안부 타임라인
│   │   └── TimelineScreen (달력 뷰)
│   │       └── DayDetailSheet (바텀시트: 해당일 체크인 상세)
│   ├── ContactsTab — 긴급연락처
│   │   ├── ContactListScreen
│   │   └── ContactEditScreen
│   └── SettingsTab — 설정
│       ├── SettingsScreen
│       ├── SubscriptionScreen (구독 관리)
│       ├── CheckinSettingsScreen (주기/알림 시간)
│       ├── PrivacyScreen (위치 공유, 데이터 삭제)
│       └── ProfileScreen (닉네임, 프로필)
│
└── Modal Stack
    ├── GraceAlertModal (5분 유예 — 전체화면)
    ├── PaywallModal (프리미엄 업그레이드)
    └── ConsentRequestModal (긴급연락처 동의 확인)
```

### 8-2. 핵심 화면별 UI 구성

#### LoginScreen (소셜 로그인) — `Auth Stack`

| 영역 | UI 구성 |
|------|---------|
| 상단 | 앱 로고 (살았니 아이콘) + 슬로건 "혼자 살아도 안심" |
| 중앙 | 소셜 로그인 3버튼 (세로 배치): 카카오 로그인 (노란색), Google 로그인 (흰색), Apple 로그인 (검정색). 각 버튼은 해당 브랜드 가이드라인 준수 |
| 하단 | 이용약관 · 개인정보처리방침 링크 (텍스트 버튼), "로그인 시 약관에 동의한 것으로 간주합니다" 안내 문구 |
| 데이터 | 없음 (인증 전) |
| API | Supabase Auth SDK (`signInWithOAuth`) |

#### HomeScreen (체크인 홈) — `HomeTab`

| 영역 | UI 구성 |
|------|---------|
| 상단 | 상태 배너: "다음 체크인까지 XX시간 XX분" 카운트다운 타이머. 연속 스트릭 배지 |
| 중앙 | 대형 원형 "살았어" 버튼 (직경 160dp). 버튼 하단: 선택적 메모 입력 필드 (접이식) |
| 하단 | 간략 상태: "마지막 체크인: 오늘 09:32" / "긴급연락처: 3명 등록됨" |
| 데이터 | `checkins` 테이블 최신 기록, `user_settings`.check_in_interval |
| API | `POST /rest/v1/checkins` (체크인), `POST /rest/v1/rpc/get_user_checkin_status` (현재 상태 조회) |

#### TimelineScreen (안부 타임라인) — `TimelineTab`

| 영역 | UI 구성 |
|------|---------|
| 상단 | 월 선택 네비게이션 (좌우 화살표) |
| 중앙 | 달력 그리드 — 각 날짜 셀에 상태 도트 (초록=체크인, 빨강=미체크인, 회색=미래) |
| 하단 | 선택한 날짜의 상세 정보 (바텀시트): 체크인 시각, 메모, 미응답 알림 여부 |
| 데이터 | `checkins` 테이블 월별 조회, `alert_logs` 미응답 이력 |
| API | `POST /rest/v1/rpc/get_checkins_by_month` (월별 체크인 RPC), `GET /rest/v1/alert_logs?created_at=gte.YYYY-MM-01&created_at=lt.YYYY-MM+1-01` (알림 이력) |

#### ContactListScreen (긴급연락처) — `ContactsTab`

| 영역 | UI 구성 |
|------|---------|
| 상단 | "긴급연락처" 타이틀, 추가 버튼 (무료 1명/유료 3명 표시) |
| 중앙 | 연락처 카드 리스트: 이름, 관계, 전화번호(마스킹), 동의 상태 뱃지 |
| 하단 | "프리미엄으로 업그레이드" CTA (무료 사용자, 1명 초과 시) |
| 데이터 | `emergency_contacts` 테이블 |
| API | `GET /rest/v1/emergency_contacts`, `POST /rest/v1/emergency_contacts`, `PATCH /rest/v1/emergency_contacts?id=eq.{id}`, `DELETE /rest/v1/emergency_contacts?id=eq.{id}`, `POST /functions/v1/send-consent-sms` (동의 요청) |

#### SettingsScreen (설정) — `SettingsTab`

| 영역 | UI 구성 |
|------|---------|
| 메뉴 목록 | 체크인 설정 → CheckinSettingsScreen |
|  | 구독 관리 → SubscriptionScreen |
|  | 프로필 → ProfileScreen |
|  | 프라이버시 → PrivacyScreen |
|  | 앱 정보, 고객센터, 이용약관, 개인정보 처리방침 |
|  | 로그아웃 / 회원탈퇴 |
| 데이터 | `user_settings`, `subscriptions` 테이블 |
| API | `GET /rest/v1/user_settings`, `PATCH /rest/v1/user_settings`, `GET /rest/v1/subscriptions` |

#### OnboardingScreen (온보딩) — `Auth Stack`

| 영역 | UI 구성 |
|------|---------|
| Step 1 | 풀스크린 일러스트 + "혼자 살아도 안심" 카피. 스와이프 또는 "다음" 버튼 |
| Step 2 | 체크인 주기 선택 카드 3장 (12h/24h/48h). 각 카드에 설명 텍스트 |
| Step 3 | 긴급연락처 입력 폼: 이름, 전화번호, 관계. "동의 요청 SMS 보내기" CTA |
| 데이터 | `user_settings`, `emergency_contacts` 생성 |
| API | `PATCH /rest/v1/user_settings` (주기 설정), `POST /rest/v1/emergency_contacts` (연락처 등록), `POST /functions/v1/send-consent-sms` (동의 요청) |

#### GraceAlertModal (5분 유예) — `Modal Stack`

| 영역 | UI 구성 |
|------|---------|
| 전체화면 | 빨간 배경, 카운트다운 타이머 (5:00 → 0:00) |
| 중앙 | "체크인을 놓쳤어요!\n긴급연락처에 알림이 발송됩니다" 텍스트 |
| CTA | 대형 "괜찮아요 — 알림 취소" 버튼 |
| 하단 | "XX분 후 [긴급연락처 이름]에게 알림이 발송됩니다" |
| 데이터 | `checkins` 최신 상태, `emergency_contacts` |
| API | `POST /rest/v1/checkins` (취소=체크인 처리), `POST /functions/v1/cancel-grace` (유예 취소) |

#### SubscriptionScreen (구독 관리) — `SettingsTab`

| 영역 | UI 구성 |
|------|---------|
| 상단 | 현재 플랜 뱃지 (무료/프리미엄) |
| 중앙 | 무료 vs 프리미엄 비교 테이블 (기능별 O/X) |
| 하단 | 월간(₩3,900)/연간(₩39,000) 구독 CTA, 7일 무료 체험 표시 |
| 데이터 | `subscriptions` 테이블 |
| API | RevenueCat SDK (구매/복원), `POST /functions/v1/verify-subscription` (RevenueCat Webhook) |

---

## 9. Competitive Differentiation

### 9-1. 차별화 포지셔닝

| 차별점 | 경쟁사 현황 | 살았니의 접근 |
|--------|-----------|-------------|
| **한국어 네이티브** | Demumu(중국어), Snug Safety(영어) — 한국 시장 직접 경쟁자 전무 | 한국 유일의 청장년 대상 B2C 안부확인 앱 (경쟁분석 §4) |
| **카카오톡 알림** | Demumu는 이메일 전용, Snug Safety는 영어 SMS | 카카오 알림톡 + SMS 이중 발송. 한국 사용자 95%+ 카카오톡 사용 (경쟁분석 §4) |
| **체크인 주기 커스터마이징** | Demumu 48시간 고정 | 12h/24h/48h 선택 가능 (경쟁분석 §1-1) |
| **20~50대 타겟** | 정부 서비스는 고령층 한정, Snug Safety는 미국 시니어 중심 | 기존 서비스 사각지대인 청장년 1인가구에 집중 (시장분석 §2) |
| **5분 유예 + 취소** | Demumu는 유예 없이 즉시 발송 | 오알림 방지로 사용자/수신자 모두 신뢰 확보 |
| **안부 타임라인** | Demumu는 체크인 기록 조회 미지원 | 달력 뷰, 스트릭, 한줄 메모로 습관화 및 정서적 기록 |

### 9-2. 핵심 방어 전략

1. **선점 우위**: 한국 시장 최초 청장년 안부확인 앱으로 브랜드 인지도 확보. Demumu가 2026년 1월 15일 중국 앱스토어에서 제거되어 바이럴 소멸 가능성이 있으나, 글로벌 보도로 "안부확인 앱" 카테고리 인지도가 높아진 상태에서 한국 시장 공백을 선점. 마케팅 전략은 Demumu 바이럴 의존도를 낮추고, 한국 고독사 이슈·1인가구 안전 니즈 자체를 중심으로 구성
2. **카카오톡 연동 해자**: 외국 경쟁자가 쉽게 따라올 수 없는 한국 고유 채널
3. **빠른 실행**: Demumu 3인 팀 1개월 개발 사례. 1인 개발로도 6~8주 MVP 가능

---

## 10. Monetization Strategy

### 10-1. 수익 모델

| 모델 | 내용 | 가격 |
|------|------|------|
| **무료 (Free)** | 체크인(24h 주기 고정, 변경 불가), 긴급연락처 1명, SMS 알림, 90일 타임라인 | ₩0 |
| **프리미엄 구독 (월간)** | 체크인 주기 선택(12h/24h/48h), 긴급연락처 3명, 카카오톡+SMS 이중 알림, 위치 공유, 전체 타임라인, 체크인 리포트 | ₩3,900/월 |
| **프리미엄 구독 (연간)** | 월간과 동일, 연 할인 | ₩39,000/년 (월 ₩3,250) |

### 10-2. 수익 추정 (1년 차)

| 시나리오 | 총 다운로드 | 유료 전환율 | 유료 사용자 | 월 ARPU | 연 매출 |
|---------|-----------|-----------|-----------|---------|--------|
| **보수적** | 10만 | 5% | 5,000명 | ₩3,500 | ₩2.1억 |
| **기본** | 15만 | 7% | 10,500명 | ₩3,500 | ₩4.4억 |
| **낙관적** | 20만+ | 10%+ | 20,000~60,000명 | ₩3,500 | ₩8.4억~₩25.2억 |

> **SOM과의 관계**: 아이디어 문서 SOM "1년 차 3~6만 유료 사용자"는 낙관적 시나리오의 상한에 해당한다. 보수적/기본 시나리오가 현실적 기대치이며, SOM 상한은 Demumu 바이럴 효과가 한국까지 강하게 파급되는 최적 조건 하에서의 목표이다.

| 비용 항목 | 추정 |
|----------|------|
| SMS 비용 | 건당 8.4~25원 × 미응답 발동률(추정 월 2%) = 월 수십만 원 |

### 10-3. 가격 정당성

- Demumu 유료 다운로드(8위안, ~₩1,500)로 중국 1위 달성 → 안전 서비스 소액 결제 의향 검증 (시장분석 §4)
- 월 ₩3,900은 커피 한 잔 수준, "혼자 쓰러지면 아무도 모른다"는 불안 대비 저렴한 안전 보험
- 정부 무료 서비스와 차별: 즉시 사용 가능, 카카오톡 알림, 커스터마이징, 청장년 특화

---

## 11. Risk Matrix

| # | 리스크 유형 | 리스크 | 심각도 | 발생 확률 | 대응 방안 |
|---|-----------|--------|--------|----------|----------|
| R1 | 사업 | Demumu 한국 진출 | 높음 | 중간 | 선점 우위 확보, 카카오톡 연동 차별화, 한국 커뮤니티 바이럴 선행 |
| R2 | 사업 | 카카오/네이버 유사 기능 출시 | 높음 | 낮음 | 안부확인은 메신저 핵심 기능 아님. 전문 앱 브랜딩으로 대응 |
| R3 | 사업 | 유료 전환율 저조 | 중간 | 중간 | 7일 무료 체험, 무료→유료 기능 격차 최적화, 카카오톡 알림을 킬러 유료 기능으로 |
| R4 | 기술 | SMS 발송 실패/지연 | 높음 | 낮음 | 알리고 API 재시도 3회, 카카오 알림톡 폴백, 발송 실패 로그 모니터링 |
| R5 | 기술 | 미응답 감지 cron 장애 | 높음 | 낮음 | pg_cron 헬스체크, 감지 누락 시 10분 내 재실행, Supabase Webhook 이중화 |
| R6 | 법률 | 개인정보(전화번호·위치) 수집 관련 PIPA 이슈 | 중간 | 낮음 | 최소 수집 원칙, 개인정보 처리방침 법률 검토, 위치는 선택 동의 |
| R7 | 법률 | 긴급연락처 동의 없는 알림 발송 | 중간 | 낮음 | 등록 시 동의 요청 SMS 발송, 동의 미완료 시에도 안전 우선 발송. **법적 논거**: (1) 개인정보보호법 제15조 제1항 제5호 "정보주체 또는 제3자의 급박한 생명·신체·재산의 이익을 위하여 필요하다고 인정되는 경우" — 체크인 미응답은 급박한 신체 이익 보호 목적에 해당할 수 있음. (2) 정보통신망법 제50조 단서 "비영리 목적의 긴급 알림"으로 분류 가능. 다만 법적 확정성을 위해 **MVP 출시 전(W10~W11) 법률 자문을 받아 확인하고, 약관에 면책 조항을 포함**한다 |
| R8 | 운영 | 오알림(False Positive) 다발 | 중간 | 중간 | 5분 유예 시간, 리마인더 2회(1시간/30분 전), 사용자 피드백 반영 |
| R9 | 의존성 | 알리고/카카오 API 장애 | 높음 | 낮음 | SMS API 2차 백업(NHN Cloud), 알림톡 실패 시 SMS 폴백 |
| R10 | 의존성 | Supabase 서비스 장애 | 높음 | 낮음 | 오프라인 체크인 로컬 저장, 복구 후 자동 동기화 |

---

## 12. Assumptions & Constraints

### 12-1. 사업적 가정

| # | 가정 | 검증 방법 |
|---|------|----------|
| A1 | 한국 20~59세 1인가구 중 5~10%가 "안부확인 앱"에 지불 의향이 있다 | Demumu 유료 모델 검증, 출시 후 전환율 측정 |
| A2 | 카카오톡 알림톡이 SMS 대비 압도적으로 높은 알림 도달률과 사용자 선호도를 보인다 | A/B 테스트 (카카오톡 vs SMS only) |
| A3 | Demumu 바이럴이 한국 내 "안부확인 앱" 카테고리 인지도 상승에 기여한다 | 출시 시점 뉴스 보도 및 검색 트렌드 모니터링 |
| A4 | 체크인 오알림(False Positive) 비율이 5% 이하로 유지된다 | 5분 유예 + 리마인더 2회 효과 측정 |

### 12-2. 외부 의존성

| # | 의존성 | 리스크 | 대안 |
|---|--------|--------|------|
| D1 | 알리고 SMS API | 서비스 장애, 요금 변경 | NHN Cloud 문자 API 백업 |
| D2 | 카카오 비즈메시지 API (알림톡) | 승인 필요, 템플릿 심사 | SMS 폴백, 카카오 비즈 계정 사전 등록 |
| D3 | FCM (Firebase Cloud Messaging) | 구글 정책 변경 | expo-notifications 추상화 레이어 활용 |
| D4 | App Store / Google Play IAP | 수수료 30% | RevenueCat으로 관리 편의성 확보 |
| D5 | Supabase | 서비스 장애, 과금 정책 변경 | 오프라인 우선 설계로 일시 장애 대응 |

### 12-3. 기술 제약

- React Native + TypeScript + Supabase 전용 (CLAUDE.md 기술 스택 제약)
- 1인 개발 규모 — 복잡한 마이크로서비스 아키텍처 불가
- 3개월 MVP — P0 기능만 구현, P1은 출시 후 1~2개월 내 추가
- **project-init 조건부 매핑 미지원 — 수동 설치 필요**: 알리고 SMS SDK (npm 공식 패키지 없음, REST API 직접 호출), 카카오 비즈메시지 SDK (REST API 직접 호출)

---

## 13. Out of Scope (MVP 제외)

| # | 제외 항목 | 사유 |
|---|----------|------|
| OS-01 | 양방향 체크인 (긴급연락처도 체크인) | P2 — 초기 복잡도 증가, 사용자 기반 확보 후 |
| OS-02 | 건강 데이터 연동 (Apple Health/Google Fit) | P2 — 데이터 동의 및 분석 로직 추가 개발 필요 |
| OS-03 | B2G 지자체 대시보드 | P2 — 기업 영업 및 커스터마이징 필요 |
| OS-04 | 커뮤니티 기능 | P2 — 소셜 기능은 핵심 가치와 무관 |
| OS-05 | 다국어 지원 | MVP는 한국어 전용 |
| OS-06 | 웨어러블 연동 (Apple Watch 등) | P2 — 별도 앱 개발 필요 |
| OS-07 | 112/119 자동 신고 연동 | 법적 인허가 및 책임 이슈, 향후 검토 |
| OS-08 | 자동 낙상 감지 (가속도 센서) | 기술 정확도 및 배터리 소모 이슈, 향후 검토 |

---

## 14. MVP Roadmap (12주)

### Phase 1: 기반 구축 (1~3주)

| 주 | 마일스톤 |
|----|---------|
| W1 | 프로젝트 세팅 (Expo, Supabase), DB 스키마 생성, Auth 플로우 (카카오/구글/애플 소셜 로그인) |
| W2 | 온보딩 플로우 UI, 긴급연락처 CRUD, 동의 요청 SMS 발송 연동 |
| W3 | 체크인 핵심 로직 (버튼 탭 → 서버 저장 → 타이머 리셋), 오프라인 체크인 로컬 저장 |

### Phase 2: 핵심 기능 (4~7주)

| 주 | 마일스톤 |
|----|---------|
| W4 | 미응답 감지 cron (pg_cron), 5분 유예 모달, 취소 로직 |
| W5 | SMS 긴급 알림 발송 (알리고 API 연동), 발송 재시도 로직 |
| W6 | 카카오 알림톡 연동, SMS+카카오 이중 발송, 안부 타임라인 (달력 뷰) |
| W7 | 푸시 알림 리마인더 (1시간 전, 30분 전), 체크인 주기 설정 UI |

### Phase 3: 수익화 & 마감 (8~10주)

| 주 | 마일스톤 |
|----|---------|
| W8 | 인앱 결제 연동 (RevenueCat), 구독 관리 화면, 무료/유료 기능 분기 |
| W9 | 설정 화면 (프로필, 프라이버시), UI 폴리싱, 다크 모드 |
| W10 | 전체 기능 통합 테스트, 에러 핸들링 강화, 성능 최적화, **긴급연락처 무동의 알림 발송 관련 법률 자문 착수** |

### Phase 4: QA & 출시 (11~12주)

| 주 | 마일스톤 |
|----|---------|
| W11 | 내부 QA, 베타 테스트 (10~20명), 크래시 수정, SMS/카카오 알림 실제 발송 테스트, **법률 자문 결과 반영(약관 면책 조항 추가, 필요 시 AC-07-4 발송 정책 조정)** |
| W12 | App Store / Google Play 심사 제출, 랜딩 페이지, 출시 |

---

## 15. Success Metrics

### 15-1. 사용자 지표

| 지표 | 정의 | 목표 (6개월) | 측정 방법 |
|------|------|-------------|----------|
| MAU | 월간 활성 사용자 | 50,000 | Firebase Analytics |
| DAU/MAU | 일간/월간 활성 비율 | 60%+ (체크인 특성상 높은 리텐션 기대) | Firebase Analytics |
| D7 Retention | 7일 잔존율 | 50%+ | Firebase Analytics |
| D30 Retention | 30일 잔존율 | 35%+ | Firebase Analytics |
| 체크인 완료율 | 일별 체크인 완료 / 활성 사용자 | 85%+ | Supabase 쿼리 |

### 15-2. 비즈니스 지표

| 지표 | 정의 | 목표 (6개월) | 측정 방법 |
|------|------|-------------|----------|
| 유료 전환율 | 유료 사용자 / 전체 사용자 | 5~10% | RevenueCat |
| MRR | 월간 반복 매출 | ₩1,000만+ | RevenueCat |
| ARPU | 사용자당 평균 매출 | ₩200+ (전체), ₩3,500 (유료) | RevenueCat |
| Churn Rate | 월간 구독 해지율 | < 8% | RevenueCat |
| LTV | 유료 사용자 평생 가치 | ₩40,000+ (구독 기간 12개월+) | RevenueCat |

### 15-3. 제품 지표

| 지표 | 정의 | 목표 | 측정 방법 |
|------|------|------|----------|
| 체크인 응답 시간 | 알림 수신 → 체크인 완료 | 평균 5분 이내 | Supabase 쿼리 |
| 오알림 비율 | 실제 위험이 아닌 알림 발송 비율 | < 5% | 사용자 피드백 + 취소율 |
| 알림 도달률 | SMS+카카오 발송 성공률 | 99%+ | 알리고/카카오 API 로그 |
| NPS | 순 추천 지수 | 40+ | 인앱 설문 (월 1회) |
| App Store 평점 | 스토어 평균 평점 | 4.5+ | 스토어 대시보드 |

---

## 16. Glossary (용어 사전)

| 용어 | 정의 |
|------|------|
| 체크인 (Check-in) | 사용자가 "살았어" 버튼을 탭하여 자신의 안전을 확인하는 행위. 서버에 체크인 기록이 저장되고 다음 마감 타이머가 리셋된다 |
| 체크인 주기 (Check-in Interval) | 연속 체크인 사이의 시간 간격. 12시간/24시간/48시간 중 선택 가능 (무료는 24시간 고정) |
| 미응답 (Overdue) | 사용자가 설정된 체크인 주기 내에 체크인하지 않은 상태. 서버 pg_cron이 감지하여 유예 기간을 시작한다 |
| 유예 기간 (Grace Period) | 미응답 감지 후 긴급 알림 발송 전에 부여되는 5분간의 취소 가능 시간. 사용자가 "괜찮아요" 버튼을 눌러 알림을 취소할 수 있다 |
| 긴급연락처 (Emergency Contact) | 사용자가 지정한 가족·친구·이웃 등으로, 미응답 시 SMS/카카오 알림톡을 수신하는 대상. 무료 1명, 유료 최대 3명 |
| 동의 (Consent) | 긴급연락처로 등록된 상대방이 SMS 링크를 통해 자신의 역할을 인지하고 수락하는 절차 |
| 오알림 (False Positive) | 실제로 사용자에게 위험 상황이 없음에도 긴급연락처에 알림이 발송되는 경우. 5분 유예와 리마인더로 최소화한다 |
| 스트릭 (Streak) | 연속으로 체크인에 성공한 일수. 습관화 동기부여 요소로 활용된다 |
| 알림톡 (Alimtalk) | 카카오 비즈메시지 API를 통해 발송되는 카카오톡 알림 메시지. 사전 승인된 템플릿 기반으로 발송된다 |
| 고독사 (Lonely Death / Kodoksa) | 혼자 사는 사람이 사회적 고립 속에서 사망 후 장시간 발견되지 않는 사망 유형. 한국에서 연간 3,924명(2024년 기준) 발생 |
| RLS (Row Level Security) | PostgreSQL의 행 수준 보안 기능. 사용자가 자신의 데이터만 접근할 수 있도록 테이블별 정책을 설정한다 |
| pg_cron | PostgreSQL 확장으로, 데이터베이스 내에서 cron 스케줄 작업을 실행한다. 미응답 감지·유예 만료·알림 재시도에 사용 |
| pg_net | PostgreSQL 확장으로, DB Function 내에서 HTTP 요청을 비동기로 발송한다. pg_cron에서 Edge Function을 트리거하는 데 사용 |
| Edge Function | Supabase에서 제공하는 Deno 런타임 기반 서버리스 함수. 외부 API 호출이나 복합 비즈니스 로직 처리에 사용 |
| Server Wins | 오프라인 동기화 시 서버 데이터를 우선하는 충돌 해결 정책. 안전 앱 특성상 서버가 single source of truth 역할을 한다 |
| SOM (Serviceable Obtainable Market) | 서비스 가능한 획득 시장. 1년 차 현실적으로 확보 가능한 유료 사용자 규모 (3~6만 명 목표) |
| PIPA (Personal Information Protection Act) | 개인정보보호법. 한국의 개인정보 수집·이용·제공에 관한 기본법. 전화번호·위치 등 수집 시 준수 필요 |
