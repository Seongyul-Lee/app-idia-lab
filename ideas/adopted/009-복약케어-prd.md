# 009-복약케어 PRD (Product Requirements Document)

> **문서 버전**: v1.2
> **작성일**: 2026-02-02
> **상태**: 수정 (4단계 v1.1 리뷰: Major 1건 + Minor 2건 반영)

---

## 1. Executive Summary

복약케어는 **떨어져 사는 부모님의 약 복용을 자녀가 원격으로 확인하고 관리할 수 있는 가족 연동 복약관리 앱**이다. 65세 이상 만성질환자의 약 50%가 처방대로 약을 복용하지 않는 현실에서, 기존 한국 복약 앱(파프리카케어, 네이버 헬스케어)은 가족 원격 모니터링을 지원하지 않고, 글로벌 앱(Medisafe)은 한국어와 한국 의약품 DB를 지원하지 않는다. 복약케어는 **한국 식약처 의약품 DB + 어르신 전용 대형 UI + 가족 연동 미복용 알림**의 조합으로 이 공백을 채우며, 30~50대 자녀가 설정·관리하고 60~80대 어르신이 큰 버튼 하나로 복용을 확인하는 **이중 사용자 구조**로 설계한다. 프리미엄(Freemium) 모델로 기본 복약 알림은 무료 제공하고, 가족 연동 확장·상세 리포트·PDF 내보내기를 유료화하여 수익을 창출한다.

---

## 2. Problem Statement

### 2-1. 어르신 복약 미순응

한국은 2025년 초고령사회에 진입했으며(65세+ 1,084만 명, 전체 인구의 21.21%), 만성질환 유병률이 80%를 상회한다(시장분석 §1). 65세 이상 만성질환자의 약 50%가 처방대로 약을 복용하지 않으며, 다제약물(polypharmacy) 복용 고령자의 입원 위험은 OR 1.52, 사망 위험은 OR 3.17에 달한다(시장분석 §6). 매년 고령 인구가 50~60만 명씩 증가하면서 이 문제는 구조적으로 심화되고 있다.

### 2-2. 기존 앱의 가족 원격 모니터링 부재

- **파프리카케어**: "가족 추가"는 동일 기기 내 프로필 전환이며, 원격 모니터링이 아니다. 앱스토어 평점 3.6, 알림 오류 반복 보고(경쟁분석 §1).
- **네이버 헬스케어**: 2025.11 출시 후 3개월간 가족 연동 기능 미추가. B2B 생태계에 집중(경쟁분석 §2).
- **Medisafe**: Medfriend(가족 알림)를 지원하나 한국어 미지원, 한국 의약품 DB 미연동. 2026.1 유료 전환으로 무료 시 약 2개만 등록 가능(경쟁분석 §3).

### 2-3. 자녀의 원격 돌봄 니즈

네이버 블로그·지식iN·카페에서 "혼자 계신 부모님 약 관리", "갤럭시 헬스에서 원격 확인 어렵다", "뇌졸중 약 복용 누락 시 앱 활용 권고" 등 자녀 세대의 구체적 고충이 확인된다(아이디어 문서 §Pain Point 3). 2026.3 지역사회 통합돌봄법 시행으로 가족 돌봄 지원에 대한 정책적 정당성도 강화되고 있다(시장분석 §6).

---

## 3. Target Users & Personas

### 페르소나 1: 김설정 (자녀 — 주요 타겟)
| 항목 | 내용 |
|------|------|
| 연령 | 38세, 직장인 여성 |
| 상황 | 서울 거주, 부산에 사시는 68세 아버지(고혈압·당뇨)와 66세 어머니(골다공증) |
| Pain Point | 매일 전화하기 어렵고, 부모님이 "약 먹었다" 해도 실제 확인 불가. 병원 방문 시 복약 이력 설명이 어려움 |
| 목표 | 부모님의 매일 복약 여부를 앱으로 확인, 미복용 시 즉시 알림 수신 |
| 디지털 역량 | 높음 — 앱 설치·설정·결제 모두 자유롭게 수행 |

### 페르소나 2: 박어르신 (어르신 — 보조 타겟)
| 항목 | 내용 |
|------|------|
| 연령 | 72세, 남성, 독거 |
| 상황 | 고혈압·고지혈증으로 매일 4가지 약 복용, 가끔 깜빡하고 중복 복용하기도 함 |
| Pain Point | 알림이 다른 앱에 묻혀 놓침, 글씨가 작아 조작 어려움, 먹었는지 안 먹었는지 헷갈림 |
| 목표 | 제때 알림을 받고, 큰 버튼 한 번으로 복용 기록 완료 |
| 디지털 역량 | 낮음 — 카카오톡·전화 위주, 새 앱 설치는 자녀 도움 필요 |

### 페르소나 3: 이관리 (자녀 — 다중 관리형)
| 항목 | 내용 |
|------|------|
| 연령 | 45세, 자영업 남성 |
| 상황 | 대전 거주, 시골에 사시는 78세 어머니(심장질환·관절염)와 아내의 70세 부모님도 관리 |
| Pain Point | 3명의 부모님 약을 동시에 관리해야 하며, 복약 기록을 의사에게 보여주고 싶음 |
| 목표 | 여러 가족의 복약 현황을 한 대시보드에서 확인, 리포트 PDF로 병원에 제출 |
| 디지털 역량 | 중간 — 기본 앱 사용 능숙, 복잡한 설정은 시행착오 |

---

## 4. User Stories

### Epic 1: 인증 및 온보딩
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-01-1 | As a 자녀, I want 카카오/구글/애플 계정으로 간편 로그인, so that 별도 회원가입 없이 빠르게 시작할 수 있다 | P0 |
| US-01-2 | As a 어르신, I want 자녀가 보내준 초대 링크로 가입, so that 복잡한 가입 절차 없이 가족 그룹에 참여할 수 있다 | P0 |
| US-01-3 | As a 자녀, I want 온보딩에서 부모님의 약 정보를 등록, so that 설치 직후 핵심 기능을 바로 사용할 수 있다 | P0 |
| US-01-4 | As a 어르신, I want 첫 실행 시 큰 글씨 모드 선택, so that 나에게 맞는 화면으로 사용할 수 있다 | P1 |

### Epic 2: 약 등록 및 관리
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-02-1 | As a 자녀/어르신, I want 약 이름을 검색하여 등록, so that 정확한 약 정보와 함께 복약 일정을 설정할 수 있다 | P0 |
| US-02-2 | As a 자녀, I want 약 이름을 직접 입력하여 등록, so that DB에 없는 약(영양제 등)도 관리할 수 있다 | P0 |
| US-02-3 | As a 자녀, I want 복용 시간·횟수·기간을 설정, so that 처방에 맞는 알림이 자동으로 생성된다 | P0 |
| US-02-4 | As a 자녀, I want 등록된 약 목록을 수정/삭제, so that 처방 변경 시 즉시 반영할 수 있다 | P0 |
| US-02-5 | As a 자녀, I want 부모님의 약을 원격으로 등록/수정, so that 부모님이 직접 조작하지 않아도 된다 | P0 |

### Epic 3: 복약 알림 및 확인
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-03-1 | As a 어르신, I want 설정된 시간에 푸시 알림을 받기, so that 약 먹을 시간을 놓치지 않는다 | P0 |
| US-03-2 | As a 어르신, I want 큰 버튼 한 번으로 "복용 완료" 기록, so that 복잡한 조작 없이 확인할 수 있다 | P0 |
| US-03-3 | As a 어르신, I want "나중에 먹기" 버튼으로 알림을 연기, so that 식사 후 복용 등 상황에 맞출 수 있다 | P1 |
| US-03-4 | As a 어르신, I want 오프라인 상태에서도 복용 완료를 기록, so that 인터넷이 없어도 사용할 수 있다 | P0 |

### Epic 4: 가족 연동 및 모니터링
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-04-1 | As a 자녀, I want 초대 코드/링크로 가족 그룹을 생성, so that 부모님과 연결될 수 있다 | P0 |
| US-04-2 | As a 자녀, I want 어르신이 미복용 시 푸시 알림을 받기, so that 즉시 확인하고 연락할 수 있다 | P0 |
| US-04-3 | As a 자녀, I want 부모님의 오늘/주간 복약 현황 대시보드를 보기, so that 한눈에 복약 상태를 파악할 수 있다 | P0 |
| US-04-4 | As a 자녀, I want 여러 가족 구성원의 복약을 관리, so that 양가 부모님 등 복수의 어르신을 돌볼 수 있다 | P1 |

### Epic 5: 복약 기록 및 리포트
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-05-1 | As a 자녀/어르신, I want 일별/주별/월별 복약 이력을 캘린더로 보기, so that 복약 패턴을 파악할 수 있다 | P0 |
| US-05-2 | As a 자녀, I want 복약 순응도(%)와 트렌드 그래프를 보기, so that 시간에 따른 변화를 추적할 수 있다 | P1 |
| US-05-3 | As a 자녀, I want 복약 리포트를 PDF로 내보내기, so that 병원 방문 시 의사에게 보여줄 수 있다 | P2 |

### Epic 6: 설정 및 프로필
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-06-1 | As a 어르신, I want 큰 글씨/대형 UI 모드를 켜거나 끄기, so that 내 시력에 맞게 조정할 수 있다 | P1 |
| US-06-2 | As a 자녀/어르신, I want 알림 시간과 사운드를 설정, so that 생활 패턴에 맞출 수 있다 | P1 |
| US-06-3 | As a 자녀, I want 가족 그룹에서 구성원을 추가/제거, so that 가족 구조 변화에 대응할 수 있다 | P1 |
| US-06-4 | As a 자녀/어르신, I want 계정 탈퇴와 데이터 삭제를 요청, so that 개인정보를 관리할 수 있다 | P1 |

### Epic 7: 구독 및 결제
| ID | User Story | 우선순위 |
|----|-----------|---------|
| US-07-1 | As a 자녀, I want 무료/프리미엄 플랜 차이를 확인, so that 업그레이드 여부를 결정할 수 있다 | P1 |
| US-07-2 | As a 자녀, I want 인앱 결제로 프리미엄 구독, so that 추가 기능(다중 가족, 리포트)을 이용할 수 있다 | P2 |
| US-07-3 | As a 자녀, I want 구독을 해지하고 무료로 전환, so that 언제든 비용을 중단할 수 있다 | P2 |

---

## 5. Functional Requirements

### FR-01: 사용자 인증

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-01-1 | 소셜 로그인 (카카오, 구글, 애플) | P0 | OAuth 토큰 | 세션 생성, 사용자 프로필 | 각 플랫폼 정책 준수 | 무료 |
| FR-01-2 | 초대 링크 기반 가입 | P0 | 초대 코드 + OAuth | 가족 그룹 자동 참여 | 초대 코드 24시간 만료 | 무료 |

**수용 기준:**
- AC-01-1: 카카오/구글/애플 중 하나를 선택하여 로그인 시 3초 이내에 홈 화면으로 진입한다
- AC-01-2: 유효한 초대 코드로 가입 시 자동으로 해당 가족 그룹에 참여되고, 그룹 구성원 목록에 표시된다
- AC-01-3: 만료된 초대 코드로 가입 시도 시 "초대 코드가 만료되었습니다" 메시지를 표시한다

### FR-02: 약 등록 및 관리

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-02-1 | 약 이름 검색 (식약처 API) | P0 | 검색어 (2글자 이상) | 의약품 목록 (이름, 성분, 용량) | 일 10,000건 API 한도 | 무료 |
| FR-02-2 | 약 직접 입력 | P0 | 약 이름, 메모 | 약 등록 | - | 무료 |
| FR-02-3 | 복용 스케줄 설정 | P0 | 복용 시간, 횟수/일, 기간 | 알림 스케줄 생성 | 1일 최대 10회 | 무료 |
| FR-02-4 | 약 수정/삭제 | P0 | 약 ID, 수정 내용 | 업데이트된 약 정보 및 알림 | - | 무료 |
| FR-02-5 | 원격 약 관리 (가족) | P0 | 대상 가족원 ID, 약 정보 | 대상 가족원의 약 등록/수정 | 가족 그룹 내에서만 | 무료 (2인까지) |

**수용 기준:**
- AC-02-1: 약 이름 2글자 이상 입력 시 500ms 이내 검색 결과(최대 20건)를 표시한다
- AC-02-2: 검색 결과에서 약을 선택하면 성분명, 용량, 효능이 자동 표시된다
- AC-02-3: 직접 입력 시 약 이름(필수)과 메모(선택)를 입력하여 1초 이내에 저장 완료된다
- AC-02-4: 등록된 약의 이름·스케줄을 수정하면 1초 이내에 반영되고, 관련 알림이 자동 재예약된다. 약 삭제 시 연관 스케줄과 향후 알림이 함께 비활성화된다
- AC-02-5: 복용 스케줄 설정 후 저장 시 해당 시간에 로컬 알림이 예약된다
- AC-02-6: 자녀가 원격으로 어르신의 약을 등록하면 어르신 기기에 1분 이내 동기화된다

### FR-03: 복약 알림 및 확인

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-03-1 | 푸시 알림 (로컬 + 원격) | P0 | 알림 스케줄 | 푸시 알림 표시 | OS 알림 권한 필요 | 무료 |
| FR-03-2 | 복용 완료 기록 | P0 | "복용 완료" 탭 | 복용 기록 저장, 서버 동기화 | - | 무료 |
| FR-03-3 | 알림 연기 ("나중에 먹기") | P1 | 연기 시간 선택 (15/30/60분) | 재알림 예약 | 최대 2회 연기 | 무료 |

**수용 기준:**
- AC-03-1: 설정된 복용 시간에 푸시 알림이 ±1분 이내 정확도로 발송된다
- AC-03-2: 알림에서 "복용 완료" 탭 시 1초 이내에 기록이 저장되고, 어르신 모드에서 버튼 크기가 최소 60×60dp이다
- AC-03-3: 오프라인 상태에서 "복용 완료" 탭 시 로컬에 저장되고, 온라인 복귀 시 30초 이내에 서버 동기화된다

### FR-04: 가족 연동 및 모니터링

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-04-1 | 가족 그룹 생성/초대 | P0 | 초대 대상 지정 | 초대 코드/링크 생성 | 그룹당 최대 5명 | 무료 (2인), 유료 (3인+) |
| FR-04-2 | 미복용 알림 전송 | P0 | 미복용 이벤트 (일정 시간 경과) | 자녀에게 푸시 알림 | 알림 시간 경과 30분 후 | 무료 |
| FR-04-3 | 복약 현황 대시보드 | P0 | 가족원 ID | 오늘/주간 복약률, 미복용 이력 | - | 무료 (기본), 유료 (상세) |

**수용 기준:**
- AC-04-1: 초대 코드/링크 생성 후 공유 시 수신자가 코드를 입력하거나 링크를 탭하면 5초 이내에 가족 그룹에 참여된다
- AC-04-2: 어르신이 복용 시간으로부터 30분 이내에 "복용 완료"를 누르지 않으면, 연결된 모든 자녀에게 미복용 푸시 알림이 전송된다
- AC-04-3: 자녀 대시보드에서 어르신의 오늘 복약 현황(복용/미복용/예정)을 실시간으로 확인할 수 있다
- AC-04-4: 주간 복약률이 0~100% 사이의 백분율로 표시되며, 약별·시간대별 미복용 이력을 확인할 수 있다

### FR-05: 복약 기록 및 리포트

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-05-1 | 복약 이력 캘린더 | P0 | 기간 선택 | 일별/주별/월별 복약 현황 | 최대 12개월 조회 | 무료 |
| FR-05-2 | 복약 순응도 그래프 | P1 | 기간 선택 | 트렌드 차트 (주간/월간) | - | 유료 |
| FR-05-3 | PDF 리포트 내보내기 | P2 | 기간·대상 선택 | PDF 파일 생성·공유 | - | 유료 |

**수용 기준:**
- AC-05-1: 캘린더 뷰에서 날짜별로 복용 완료(초록), 미복용(빨강), 예정(회색) 상태가 색상으로 구분 표시된다
- AC-05-2: 특정 날짜 탭 시 해당 일의 약별 복용 시간과 상태를 리스트로 확인할 수 있다

### FR-06: 의약품 정보 조회

| ID | 기능 | 우선순위 | 입력 | 출력 | 제한사항 | 무료/유료 |
|----|------|---------|------|------|---------|----------|
| FR-06-1 | 의약품 상세 정보 | P1 | 약 선택 | 성분, 효능, 용법, 주의사항 | 식약처 API 데이터 | 무료 |
| FR-06-2 | 병용금기 경고 | P1 | 등록된 약 목록 | 병용 주의 알림 | DUR 데이터 기반 | 무료 |

---

## 6. Non-functional Requirements

### 6-1. 성능
| 항목 | 기준 |
|------|------|
| 앱 초기 로딩 | Cold start 3초 이내 |
| 화면 전환 | 300ms 이내 |
| API 응답 시간 | 95 percentile 기준 1초 이내 |
| 푸시 알림 정확도 | 설정 시간 대비 ±1분 이내 |
| 오프라인 → 온라인 동기화 | 네트워크 복구 후 30초 이내 |

### 6-2. 보안
| 항목 | 기준 |
|------|------|
| 인증 | Supabase Auth + OAuth 2.0 (카카오, 구글, 애플) |
| 데이터 전송 | HTTPS (TLS 1.2+) |
| 데이터 저장 | Supabase RLS로 가족 그룹 내 데이터 격리 |
| 개인정보 | 건강정보 최소 수집 원칙, 개인정보보호법 준수 |
| 로컬 저장소 | MMKV 암호화 저장 |
| 계정 탈퇴 | 요청 후 30일 이내 전체 데이터 삭제 |

### 6-3. 접근성
| 항목 | 기준 |
|------|------|
| 어르신 모드 | 큰 글씨(최소 18sp), 높은 대비(WCAG AA), 최소 탭 영역(60×60dp) |
| 터치 영역 | 모든 인터랙티브 요소 최소 48×48dp, 어르신 모드 60×60dp |
| 글씨 크기 | 시스템 폰트 스케일링 지원 (최대 200%) |
| 색상 | 색각 이상자를 위한 아이콘+텍스트 이중 표시 |

### 6-4. 확장성
| 항목 | 기준 |
|------|------|
| 동시 사용자 | 초기 MAU 1만 기준 설계, 3만까지 Supabase Free/Pro 플랜으로 대응 |
| DB | PostgreSQL 파티셔닝 불필요 (초기 규모), 인덱스 최적화로 대응 |
| 알림 | Expo Push Notification 서비스 (무료 tier 충분) |

---

## 7. Technical Architecture

### 7-1. 기술 스택

| 레이어 | 기술 | 선정 사유 |
|--------|------|-----------|
| 프레임워크 | Expo Managed Workflow (SDK 52) | OTA 업데이트, EAS Build로 Windows에서 iOS 빌드 가능. 1인 개발에 최적 |
| 언어 | TypeScript (strict mode) | 컴파일 타임 타입 안전성, 코드 자동완성으로 개발 생산성 향상 |
| 라우팅 | Expo Router (파일 기반) | 파일 시스템 기반 라우팅으로 직관적 구조, Deep Link 자동 지원 |
| UI | React Native Paper | Material Design 3 기반, 어르신 모드 대형 컴포넌트 커스터마이징 용이, 접근성 내장 |
| 상태 관리 | Zustand | 보일러플레이트 최소, 미들웨어(persist, devtools)로 오프라인 상태 유지 |
| 백엔드 | Supabase (PostgreSQL + Auth + Edge Functions + Storage) | RLS로 가족 그룹 격리, Realtime으로 복약 상태 즉시 반영, Edge Functions로 미복용 체크 |
| 로컬 KV | react-native-mmkv | 암호화 지원, AsyncStorage 대비 30배 빠른 성능, 사용자 설정·토큰 저장 |
| 로컬 DB | op-sqlite | 오프라인 복약 기록 저장, 동기화 큐 관리, SQLite 기반 경량 DB |
| 인증 | Kakao OAuth, Google OAuth, Apple Auth | 한국 시장 카카오 필수, 글로벌 표준 구글, iOS 정책상 애플 필수 |
| 알림 | expo-notifications | 로컬 알림 스케줄링 + 원격 푸시(FCM/APNs), Expo 서버 무료 |
| 분석 | Aptabase | 프라이버시 중심, 오픈소스, 건강 앱에 적합한 최소 수집 |
| 결제 (P2) | RevenueCat | 구독 관리 자동화, iOS/Android 통합, 1인 개발에 운영 부담 최소 |
| 차트 (P1) | Gifted Charts | SVG 기반으로 가볍고 커스터마이징 용이, 복약 순응도 그래프에 적합 |
| 캘린더 | react-native-calendars | 복약 이력 캘린더 뷰, 날짜별 마킹·상태 표시 지원 |
| 날짜 선택 | DateTimePicker | 복용 시간 설정에 사용, Expo 호환 |
| 햅틱 | expo-haptics | 복용 완료 탭 시 촉각 피드백, 어르신 확인감 제공 |
| 빌드 | EAS Build (클라우드) | Windows 11에서 iOS/Android 모두 빌드, OTA 업데이트 |

### 7-2. 시스템 구조도

```
┌─────────────────────────────────────────────────────────────────┐
│                        클라이언트 (React Native + Expo)           │
│                                                                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────────┐ │
│  │ Auth     │  │ 약 관리   │  │ 알림     │  │ 가족 대시보드     │ │
│  │ Screen   │  │ Screen   │  │ Handler  │  │ Screen           │ │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────────────┘ │
│       │              │              │              │               │
│  ┌────┴──────────────┴──────────────┴──────────────┴────────────┐ │
│  │                    Zustand Stores                             │ │
│  │  AuthStore │ MedicationStore │ ScheduleStore │ FamilyStore   │ │
│  └──────────────────────┬───────────────────────────────────────┘ │
│                         │                                         │
│  ┌──────────────────────┴───────────────────────────────────────┐ │
│  │              오프라인 레이어 (Sync Manager)                    │ │
│  │  ┌─────────┐  ┌──────────┐  ┌──────────────────────────────┐ │ │
│  │  │ MMKV    │  │ op-sqlite│  │ SyncQueue (op-sqlite)        │ │ │
│  │  │ (설정,  │  │ (복약기록,│  │ (미동기화 작업 큐)             │ │ │
│  │  │  토큰)  │  │  약 캐시) │  │                              │ │ │
│  │  └─────────┘  └──────────┘  └──────────────────────────────┘ │ │
│  └──────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬───────────────────────────────────────┘
                          │ HTTPS
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Supabase Backend                            │
│                                                                  │
│  ┌──────────┐  ┌──────────────┐  ┌───────────────────────────┐  │
│  │ Auth     │  │ PostgREST    │  │ Edge Functions             │  │
│  │ (OAuth)  │  │ (CRUD API)   │  │                            │  │
│  │          │  │              │  │ • check-missed-dose        │  │
│  │ Kakao    │  │ medications  │  │ • send-family-notification │  │
│  │ Google   │  │ dose_logs    │  │ • search-medication        │  │
│  │ Apple    │  │ families     │  │ • generate-invite          │  │
│  └──────────┘  └──────┬───────┘  └──────────┬────────────────┘  │
│                       │                      │                    │
│  ┌────────────────────┴──────────────────────┴────────────────┐  │
│  │              PostgreSQL + RLS                               │  │
│  │  profiles │ families │ family_members │ medications         │  │
│  │  schedules │ dose_logs │ invitations │ subscriptions        │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────┐  ┌──────────────────────────────────────────┐  │
│  │ Realtime     │  │ pg_cron (Supabase 확장)                  │  │
│  │ (복약 상태   │  │ • 매분: 미복용 체크 → Edge Function 호출  │  │
│  │  실시간 반영) │  │ • 매일: 일별 복약 통계 집계               │  │
│  └──────────────┘  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                      외부 서비스                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐   │
│  │ 식약처 API   │  │ Expo Push    │  │ RevenueCat (P2)      │   │
│  │ (의약품 검색) │  │ Notification │  │ (구독 관리)           │   │
│  └──────────────┘  │ Service      │  └──────────────────────┘   │
│                    └──────────────┘                               │
└─────────────────────────────────────────────────────────────────┘
```

**데이터 흐름:**
1. **약 등록**: 클라이언트 → Edge Function(search-medication) → 식약처 API → 응답 → PostgREST(medications INSERT) → Realtime → 가족 기기 동기화
2. **복약 알림**: pg_cron(매분) → 스케줄 체크 → expo-notifications(로컬 알림 예약은 클라이언트, 원격 푸시는 Edge Function)
3. **복용 완료**: 클라이언트(오프라인 저장) → 온라인 시 SyncQueue → PostgREST(dose_logs INSERT) → Realtime → 자녀 대시보드 갱신
4. **미복용 알림**: pg_cron(매분) → check-missed-dose Edge Function → 30분 경과 미확인 → send-family-notification → Expo Push → 자녀 기기

### 7-3. 오프라인 우선 설계

#### 저장소별 역할 분담

| 저장소 | 용도 | 저장 데이터 |
|--------|------|------------|
| MMKV | Key-Value 설정 | 인증 토큰, 사용자 설정(어르신 모드, 알림 사운드), 푸시 토큰, 마지막 동기화 시각, 온보딩 완료 플래그 |
| op-sqlite | 구조화 데이터 | 약 목록 캐시, 복약 기록(dose_logs), 스케줄 캐시, 동기화 큐(sync_queue) |

#### 동기화 큐 로직

```
sync_queue 테이블 (op-sqlite 로컬):
- id: INTEGER PRIMARY KEY AUTOINCREMENT
- table_name: TEXT (대상 테이블명)
- operation: TEXT (INSERT | UPDATE | DELETE)
- payload: TEXT (JSON)
- created_at: TEXT (ISO 8601)
- retry_count: INTEGER DEFAULT 0
- status: TEXT (pending | processing | failed | completed)
```

**동기화 프로세스:**
1. 오프라인 작업 발생 → sync_queue에 INSERT
2. 네트워크 복구 감지 (NetInfo) → SyncManager 시작
3. sync_queue에서 status='pending' 항목을 created_at 순서로 처리
4. 각 항목 → Supabase API 호출
5. 성공 → status='completed', 로컬 DB 갱신
6. 실패 → retry_count 증가, 지수 백오프 적용

**재시도 전략:**
- 최대 재시도: 5회
- 백오프: 지수 백오프 (1초 → 2초 → 4초 → 8초 → 16초)
- 5회 실패 시 status='failed', 다음 앱 실행 시 재시도

#### 충돌 해결 정책: Server Wins

- **원칙**: 서버 데이터가 항상 최종 진실(source of truth)
- **동기화 시**: 서버 데이터를 로컬 DB에 덮어쓰기
- **충돌 시나리오**: 자녀가 원격으로 약을 수정한 동시에 어르신이 오프라인에서 같은 약을 수정 → 온라인 복귀 시 서버(자녀 수정)가 우선
- **복약 기록(dose_logs)**: 충돌 가능성 낮음 (각 사용자가 자신의 기록만 생성). updated_at 타임스탬프로 최신 기록 판단
- **동기화 완료 후**: Realtime 채널 구독으로 실시간 서버 변경 반영

### 7-4. 핵심 설계 원칙

1. **오프라인 우선 (Offline-First)**: 어르신의 인터넷 환경이 불안정할 수 있으므로, 복용 기록은 항상 로컬에 먼저 저장하고 이후 동기화한다. 핵심 기능(알림 수신, 복용 확인)은 오프라인에서도 완전히 동작한다.

2. **이중 사용자 구조 (Dual-User Architecture)**: 자녀(관리자)와 어르신(사용자)의 역할이 명확히 분리된다. 같은 데이터에 대해 자녀는 설정·모니터링 뷰를, 어르신은 최소 인터랙션 뷰를 제공한다. RLS 정책으로 가족 그룹 내에서만 데이터 공유를 허용한다.

3. **최소 인터랙션 (Minimum Interaction)**: 어르신의 일상 사용은 "알림 수신 → 복용 완료 탭" 단 2단계로 완결된다. 설정·등록·관리는 자녀가 원격으로 수행하여 어르신의 조작 부담을 제거한다.

4. **서버 사이드 스케줄링 (Server-Side Scheduling)**: 미복용 체크와 가족 알림 전송은 pg_cron + Edge Function으로 서버에서 처리한다. 클라이언트 앱이 꺼져 있어도 가족 알림이 동작하는 것을 보장한다.

5. **점진적 유료화 (Progressive Monetization)**: 핵심 기능(1인 복약 + 1명 가족 연동)은 무료로 제공하여 사용자 기반을 확보한 후, 추가 가족·상세 리포트·PDF를 유료화한다. 무료 → 유료 전환 시 기존 데이터 손실 없이 기능만 잠금/해제한다.

### 7-5. DB 스키마

#### CREATE TABLE SQL

```sql
-- 1. profiles: 사용자 프로필 (Supabase Auth와 1:1)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name TEXT NOT NULL DEFAULT '',
  role TEXT NOT NULL DEFAULT 'caregiver' CHECK (role IN ('caregiver', 'senior')),
  is_senior_mode BOOLEAN NOT NULL DEFAULT false,
  push_token TEXT,
  timezone TEXT NOT NULL DEFAULT 'Asia/Seoul',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_profiles_role ON profiles(role);

-- 2. families: 가족 그룹
-- max_members: 기본값 5 (프리미엄 기준). 무료 사용자의 인원 제한(2명)은
-- generate-invite Edge Function + accept_invitation RPC에서 이중 방어로 처리한다.
-- 프리미엄 전환 시 max_members 변경은 불필요 (방어 로직이 구독 상태를 실시간 확인).
CREATE TABLE families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL DEFAULT '우리 가족',
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  max_members INTEGER NOT NULL DEFAULT 5,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_families_owner ON families(owner_id);

-- 3. family_members: 가족 구성원 (다대다)
CREATE TABLE family_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL REFERENCES families(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'caregiver' CHECK (role IN ('caregiver', 'senior')),
  joined_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(family_id, user_id)
);

CREATE INDEX idx_family_members_family ON family_members(family_id);
CREATE INDEX idx_family_members_user ON family_members(user_id);

-- 4. invitations: 가족 초대
CREATE TABLE invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL REFERENCES families(id) ON DELETE CASCADE,
  invite_code TEXT NOT NULL UNIQUE,
  inviter_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  target_role TEXT NOT NULL DEFAULT 'senior' CHECK (target_role IN ('caregiver', 'senior')),
  expires_at TIMESTAMPTZ NOT NULL,
  used_by UUID REFERENCES profiles(id),
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_invitations_code ON invitations(invite_code);
CREATE INDEX idx_invitations_family ON invitations(family_id);

-- 5. medications: 약 정보
CREATE TABLE medications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  ingredient TEXT,
  dosage TEXT,
  efficacy TEXT,
  precaution TEXT,
  is_custom BOOLEAN NOT NULL DEFAULT false,
  kfda_item_seq TEXT,  -- 식약처 품목기준코드
  memo TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_by UUID NOT NULL REFERENCES profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_medications_user ON medications(user_id);
CREATE INDEX idx_medications_user_active ON medications(user_id, is_active);

-- 6. schedules: 복용 스케줄
CREATE TABLE schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  medication_id UUID NOT NULL REFERENCES medications(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  time_of_day TIME NOT NULL,
  days_of_week INTEGER[] NOT NULL DEFAULT '{0,1,2,3,4,5,6}',  -- 0=일, 6=토
  start_date DATE NOT NULL DEFAULT CURRENT_DATE,
  end_date DATE,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_schedules_medication ON schedules(medication_id);
CREATE INDEX idx_schedules_user_active ON schedules(user_id, is_active);
CREATE INDEX idx_schedules_time ON schedules(time_of_day);

-- 7. dose_logs: 복약 기록
CREATE TABLE dose_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  schedule_id UUID NOT NULL REFERENCES schedules(id) ON DELETE CASCADE,
  medication_id UUID NOT NULL REFERENCES medications(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  scheduled_at TIMESTAMPTZ NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'taken', 'missed', 'snoozed')),
  taken_at TIMESTAMPTZ,
  snoozed_until TIMESTAMPTZ,
  snooze_count INTEGER NOT NULL DEFAULT 0,
  missed_notified BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_dose_logs_user_date ON dose_logs(user_id, scheduled_at);
CREATE INDEX idx_dose_logs_schedule ON dose_logs(schedule_id);
CREATE INDEX idx_dose_logs_status ON dose_logs(status) WHERE status IN ('pending', 'snoozed');
CREATE INDEX idx_dose_logs_missed ON dose_logs(status, missed_notified)
  WHERE status = 'pending' AND missed_notified = false;

-- 8. subscriptions: 구독 정보
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  plan TEXT NOT NULL DEFAULT 'free' CHECK (plan IN ('free', 'premium')),
  store_product_id TEXT,
  store_transaction_id TEXT,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX idx_subscriptions_user_active ON subscriptions(user_id) WHERE is_active = true;

-- 9. notification_settings: 알림 설정
CREATE TABLE notification_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  notify_missed_dose BOOLEAN NOT NULL DEFAULT true,
  missed_dose_delay_min INTEGER NOT NULL DEFAULT 30,
  sound_enabled BOOLEAN NOT NULL DEFAULT true,
  vibration_enabled BOOLEAN NOT NULL DEFAULT true,
  quiet_hours_start TIME,
  quiet_hours_end TIME,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX idx_notification_settings_user ON notification_settings(user_id);
```

#### RLS 정책 — 테이블별 CRUD 권한 매트릭스

| 테이블 | SELECT | INSERT | UPDATE | DELETE |
|--------|--------|--------|--------|--------|
| profiles | 본인 또는 같은 가족 그룹 | 트리거 자동 생성 | 본인만 | 본인만 (CASCADE) |
| families | 소속 구성원 | 인증 사용자 | owner만 | owner만 |
| family_members | 소속 구성원 | 그룹 owner/caregiver | - | 그룹 owner 또는 본인(탈퇴) |
| invitations | 초대자 본인 | 그룹 caregiver | 코드 사용 시 (used_by 업데이트) | 초대자 본인 |
| medications | 본인 또는 같은 가족 그룹 | 본인 또는 같은 가족의 caregiver | 본인 또는 같은 가족의 caregiver | 본인 또는 같은 가족의 caregiver |
| schedules | 본인 또는 같은 가족 그룹 | 본인 또는 같은 가족의 caregiver | 본인 또는 같은 가족의 caregiver | 본인 또는 같은 가족의 caregiver |
| dose_logs | 본인 또는 같은 가족 그룹 | 해당 user_id 본인만 | 해당 user_id 본인만 | - (삭제 불가) |
| subscriptions | 본인만 | 서비스 역할만 | 서비스 역할만 | - |
| notification_settings | 본인만 | 본인만 | 본인만 | 본인만 |

**RLS 정책 SQL (핵심):**

```sql
-- profiles: 본인 또는 같은 가족 그룹 구성원 조회
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "profiles_select" ON profiles FOR SELECT USING (
  id = auth.uid()
  OR id IN (
    SELECT fm2.user_id FROM family_members fm1
    JOIN family_members fm2 ON fm1.family_id = fm2.family_id
    WHERE fm1.user_id = auth.uid()
  )
);

CREATE POLICY "profiles_update" ON profiles FOR UPDATE USING (id = auth.uid());
CREATE POLICY "profiles_delete" ON profiles FOR DELETE USING (id = auth.uid());

-- medications: 본인 또는 같은 가족 그룹
ALTER TABLE medications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "medications_select" ON medications FOR SELECT USING (
  user_id = auth.uid()
  OR user_id IN (
    SELECT fm2.user_id FROM family_members fm1
    JOIN family_members fm2 ON fm1.family_id = fm2.family_id
    WHERE fm1.user_id = auth.uid()
  )
);

CREATE POLICY "medications_insert" ON medications FOR INSERT WITH CHECK (
  user_id = auth.uid()
  OR (
    user_id IN (
      SELECT fm2.user_id FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = auth.uid() AND fm1.role = 'caregiver'
    )
  )
);

CREATE POLICY "medications_update" ON medications FOR UPDATE USING (
  user_id = auth.uid()
  OR (
    user_id IN (
      SELECT fm2.user_id FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = auth.uid() AND fm1.role = 'caregiver'
    )
  )
);

CREATE POLICY "medications_delete" ON medications FOR DELETE USING (
  user_id = auth.uid()
  OR (
    user_id IN (
      SELECT fm2.user_id FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = auth.uid() AND fm1.role = 'caregiver'
    )
  )
);

-- dose_logs: 본인 기록만 생성/수정, 가족은 조회만
ALTER TABLE dose_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "dose_logs_select" ON dose_logs FOR SELECT USING (
  user_id = auth.uid()
  OR user_id IN (
    SELECT fm2.user_id FROM family_members fm1
    JOIN family_members fm2 ON fm1.family_id = fm2.family_id
    WHERE fm1.user_id = auth.uid()
  )
);

CREATE POLICY "dose_logs_insert" ON dose_logs FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "dose_logs_update" ON dose_logs FOR UPDATE USING (user_id = auth.uid());

-- families: 소속 구성원만
ALTER TABLE families ENABLE ROW LEVEL SECURITY;

CREATE POLICY "families_select" ON families FOR SELECT USING (
  id IN (SELECT family_id FROM family_members WHERE user_id = auth.uid())
);

CREATE POLICY "families_insert" ON families FOR INSERT WITH CHECK (owner_id = auth.uid());
CREATE POLICY "families_update" ON families FOR UPDATE USING (owner_id = auth.uid());
CREATE POLICY "families_delete" ON families FOR DELETE USING (owner_id = auth.uid());

-- family_members
ALTER TABLE family_members ENABLE ROW LEVEL SECURITY;

CREATE POLICY "family_members_select" ON family_members FOR SELECT USING (
  family_id IN (SELECT family_id FROM family_members WHERE user_id = auth.uid())
);

CREATE POLICY "family_members_insert" ON family_members FOR INSERT WITH CHECK (
  family_id IN (
    SELECT fm.family_id FROM family_members fm
    WHERE fm.user_id = auth.uid() AND fm.role = 'caregiver'
  )
  OR user_id = auth.uid()  -- 자기 자신 참여 (초대 수락)
);

CREATE POLICY "family_members_delete" ON family_members FOR DELETE USING (
  user_id = auth.uid()  -- 자기 탈퇴
  OR family_id IN (
    SELECT f.id FROM families f WHERE f.owner_id = auth.uid()
  )
);

-- invitations
ALTER TABLE invitations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "invitations_select" ON invitations FOR SELECT USING (
  inviter_id = auth.uid()
  OR used_by = auth.uid()
);
-- 초대 코드 유효성 검증은 accept_invitation RPC (SECURITY DEFINER)에서 처리하므로
-- SELECT 정책에서는 본인이 생성했거나 사용한 초대만 조회 가능하도록 제한

CREATE POLICY "invitations_insert" ON invitations FOR INSERT WITH CHECK (
  inviter_id = auth.uid()
);

-- schedules
ALTER TABLE schedules ENABLE ROW LEVEL SECURITY;

CREATE POLICY "schedules_select" ON schedules FOR SELECT USING (
  user_id = auth.uid()
  OR user_id IN (
    SELECT fm2.user_id FROM family_members fm1
    JOIN family_members fm2 ON fm1.family_id = fm2.family_id
    WHERE fm1.user_id = auth.uid()
  )
);

CREATE POLICY "schedules_insert" ON schedules FOR INSERT WITH CHECK (
  user_id = auth.uid()
  OR (
    user_id IN (
      SELECT fm2.user_id FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = auth.uid() AND fm1.role = 'caregiver'
    )
  )
);

CREATE POLICY "schedules_update" ON schedules FOR UPDATE USING (
  user_id = auth.uid()
  OR (
    user_id IN (
      SELECT fm2.user_id FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = auth.uid() AND fm1.role = 'caregiver'
    )
  )
);

CREATE POLICY "schedules_delete" ON schedules FOR DELETE USING (
  user_id = auth.uid()
  OR (
    user_id IN (
      SELECT fm2.user_id FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = auth.uid() AND fm1.role = 'caregiver'
    )
  )
);

-- notification_settings
ALTER TABLE notification_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "notification_settings_all" ON notification_settings
  FOR ALL USING (user_id = auth.uid());

-- subscriptions
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "subscriptions_select" ON subscriptions FOR SELECT USING (user_id = auth.uid());
```

#### 핵심 DB Function (RPC) — SQL 본문

```sql
-- 1. generate_daily_dose_logs: 매일 자정에 당일 dose_logs 생성 (CURRENT_DATE 기준)
CREATE OR REPLACE FUNCTION generate_daily_dose_logs(target_date DATE DEFAULT CURRENT_DATE)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  inserted_count INTEGER := 0;
  day_of_week INTEGER;
BEGIN
  -- 요일 계산 (0=일, 6=토)
  day_of_week := EXTRACT(DOW FROM target_date)::INTEGER;

  INSERT INTO dose_logs (schedule_id, medication_id, user_id, scheduled_at, status)
  SELECT
    s.id,
    s.medication_id,
    s.user_id,
    (target_date + s.time_of_day) AT TIME ZONE p.timezone AS scheduled_at,
    'pending'
  FROM schedules s
  JOIN profiles p ON p.id = s.user_id
  JOIN medications m ON m.id = s.medication_id
  WHERE s.is_active = true
    AND m.is_active = true
    AND day_of_week = ANY(s.days_of_week)
    AND s.start_date <= target_date
    AND (s.end_date IS NULL OR s.end_date >= target_date)
    AND NOT EXISTS (
      SELECT 1 FROM dose_logs dl
      WHERE dl.schedule_id = s.id
        AND dl.scheduled_at::DATE = target_date
    );

  GET DIAGNOSTICS inserted_count = ROW_COUNT;
  RETURN inserted_count;
END;
$$;

-- 2. resolve_expired_snoozes: snoozed 상태의 dose_log 처리 (매분 실행)
-- snooze 최대 2회까지 허용. snoozed_until 경과 시:
--   - snooze_count < 2 → pending으로 복귀 (재알림 가능)
--   - snooze_count >= 2 → missed로 전환 (더 이상 snooze 불가)
CREATE OR REPLACE FUNCTION resolve_expired_snoozes()
RETURNS TABLE (restored_count INTEGER, force_missed_count INTEGER)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_restored INTEGER;
  v_force_missed INTEGER;
BEGIN
  -- Case 1: snooze_count < 2 → pending 복귀 (get_missed_doses에서 다시 감지 가능)
  UPDATE dose_logs
  SET
    status = 'pending',
    snoozed_until = NULL,
    updated_at = now()
  WHERE status = 'snoozed'
    AND snoozed_until <= now()
    AND snooze_count < 2;
  GET DIAGNOSTICS v_restored = ROW_COUNT;

  -- Case 2: snooze_count >= 2 → missed 강제 전환 (최대 snooze 도달 후 미복용)
  UPDATE dose_logs
  SET
    status = 'missed',
    snoozed_until = NULL,
    updated_at = now()
  WHERE status = 'snoozed'
    AND snoozed_until <= now()
    AND snooze_count >= 2;
  GET DIAGNOSTICS v_force_missed = ROW_COUNT;

  RETURN QUERY SELECT v_restored, v_force_missed;
END;
$$;

-- 3. get_missed_doses: 미복용 체크 (30분 경과, 미알림)
-- pending 상태의 dose_log만 대상. snoozed 상태는 resolve_expired_snoozes()에서
-- pending 복귀 또는 missed 전환 후 이 함수에서 감지됨.
CREATE OR REPLACE FUNCTION get_missed_doses()
RETURNS TABLE (
  dose_log_id UUID,
  user_id UUID,
  medication_name TEXT,
  scheduled_at TIMESTAMPTZ,
  family_caregiver_ids UUID[],
  caregiver_push_tokens TEXT[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    dl.id AS dose_log_id,
    dl.user_id,
    m.name AS medication_name,
    dl.scheduled_at,
    ARRAY(
      SELECT fm2.user_id
      FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      WHERE fm1.user_id = dl.user_id
        AND fm1.role = 'senior'
        AND fm2.role = 'caregiver'
    ) AS family_caregiver_ids,
    ARRAY(
      SELECT p.push_token
      FROM family_members fm1
      JOIN family_members fm2 ON fm1.family_id = fm2.family_id
      JOIN profiles p ON p.id = fm2.user_id
      JOIN notification_settings ns ON ns.user_id = fm2.user_id
      WHERE fm1.user_id = dl.user_id
        AND fm1.role = 'senior'
        AND fm2.role = 'caregiver'
        AND p.push_token IS NOT NULL
        AND ns.notify_missed_dose = true
    ) AS caregiver_push_tokens
  FROM dose_logs dl
  JOIN medications m ON m.id = dl.medication_id
  JOIN notification_settings ns ON ns.user_id = dl.user_id
  WHERE dl.status = 'pending'
    AND dl.missed_notified = false
    AND dl.scheduled_at <= now() - (ns.missed_dose_delay_min || ' minutes')::INTERVAL
    AND dl.scheduled_at > now() - INTERVAL '24 hours';
END;
$$;

-- 4. mark_doses_missed: 미복용 알림 전송 후 상태 업데이트
CREATE OR REPLACE FUNCTION mark_doses_missed(dose_log_ids UUID[])
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE dose_logs
  SET
    status = 'missed',
    missed_notified = true,
    updated_at = now()
  WHERE id = ANY(dose_log_ids)
    AND status IN ('pending', 'missed');
    -- pending: 정상 미복용 전환
    -- missed: resolve_expired_snoozes()에서 이미 missed로 전환된 건에 missed_notified 플래그 추가

  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;

-- 5. get_adherence_stats: 복약 순응도 통계
CREATE OR REPLACE FUNCTION get_adherence_stats(
  target_user_id UUID,
  period_start DATE,
  period_end DATE
)
RETURNS TABLE (
  total_doses BIGINT,
  taken_doses BIGINT,
  missed_doses BIGINT,
  adherence_rate NUMERIC(5,2),
  daily_stats JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH stats AS (
    SELECT
      COUNT(*) AS total,
      COUNT(*) FILTER (WHERE dl.status = 'taken') AS taken,
      COUNT(*) FILTER (WHERE dl.status = 'missed') AS missed
    FROM dose_logs dl
    WHERE dl.user_id = target_user_id
      AND dl.scheduled_at::DATE BETWEEN period_start AND period_end
      AND dl.status IN ('taken', 'missed')
  ),
  daily AS (
    SELECT jsonb_agg(
      jsonb_build_object(
        'date', d.day::TEXT,
        'total', d.total,
        'taken', d.taken,
        'rate', CASE WHEN d.total > 0
          THEN ROUND((d.taken::NUMERIC / d.total) * 100, 1)
          ELSE 0 END
      ) ORDER BY d.day
    ) AS daily_data
    FROM (
      SELECT
        dl.scheduled_at::DATE AS day,
        COUNT(*) AS total,
        COUNT(*) FILTER (WHERE dl.status = 'taken') AS taken
      FROM dose_logs dl
      WHERE dl.user_id = target_user_id
        AND dl.scheduled_at::DATE BETWEEN period_start AND period_end
        AND dl.status IN ('taken', 'missed')
      GROUP BY dl.scheduled_at::DATE
    ) d
  )
  SELECT
    s.total,
    s.taken,
    s.missed,
    CASE WHEN s.total > 0
      THEN ROUND((s.taken::NUMERIC / s.total) * 100, 2)
      ELSE 0 END,
    COALESCE(daily.daily_data, '[]'::JSONB)
  FROM stats s, daily;
END;
$$;

-- 6. accept_invitation: 초대 수락 처리
-- 이중 방어: families.max_members + owner 구독 상태 기반 인원 제한
CREATE OR REPLACE FUNCTION accept_invitation(p_invite_code TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_invitation RECORD;
  v_member_count INTEGER;
  v_owner_plan TEXT;
  v_effective_max INTEGER;
  v_result JSONB;
BEGIN
  -- 초대 조회 및 유효성 검증
  SELECT i.*, f.max_members, f.owner_id, f.name AS family_name
  INTO v_invitation
  FROM invitations i
  JOIN families f ON f.id = i.family_id
  WHERE i.invite_code = p_invite_code
    AND i.used_by IS NULL
    AND i.expires_at > now();

  IF v_invitation IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'INVALID_OR_EXPIRED_CODE');
  END IF;

  -- 이미 가족 구성원인지 확인
  IF EXISTS (
    SELECT 1 FROM family_members
    WHERE family_id = v_invitation.family_id AND user_id = auth.uid()
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'ALREADY_MEMBER');
  END IF;

  -- 이중 방어: owner의 구독 상태 기반 인원 제한 확인
  SELECT s.plan INTO v_owner_plan
  FROM subscriptions s
  WHERE s.user_id = v_invitation.owner_id AND s.is_active = true
  ORDER BY s.created_at DESC LIMIT 1;

  -- 구독 상태에 따른 실효 최대 인원 결정
  -- 무료: 2명, 프리미엄: families.max_members (기본 5명)
  v_effective_max := CASE
    WHEN COALESCE(v_owner_plan, 'free') = 'premium' THEN v_invitation.max_members
    ELSE LEAST(v_invitation.max_members, 2)
  END;

  -- 정원 확인 (구독 기반 실효 최대 인원으로 체크)
  SELECT COUNT(*) INTO v_member_count
  FROM family_members WHERE family_id = v_invitation.family_id;

  IF v_member_count >= v_effective_max THEN
    -- 무료 한도 초과인지 구분하여 에러 메시지 반환
    IF COALESCE(v_owner_plan, 'free') = 'free' AND v_member_count < v_invitation.max_members THEN
      RETURN jsonb_build_object('success', false, 'error', 'PREMIUM_REQUIRED', 'message', '무료 플랜은 가족 2인까지만 가능합니다');
    ELSE
      RETURN jsonb_build_object('success', false, 'error', 'FAMILY_FULL');
    END IF;
  END IF;

  -- 가족 구성원 추가
  INSERT INTO family_members (family_id, user_id, role)
  VALUES (v_invitation.family_id, auth.uid(), v_invitation.target_role);

  -- 초대 사용 처리
  UPDATE invitations
  SET used_by = auth.uid(), used_at = now()
  WHERE id = v_invitation.id;

  -- 사용자 role 업데이트 (senior 초대인 경우)
  IF v_invitation.target_role = 'senior' THEN
    UPDATE profiles SET role = 'senior' WHERE id = auth.uid();
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'family_id', v_invitation.family_id,
    'family_name', v_invitation.family_name,
    'role', v_invitation.target_role
  );
END;
$$;

-- 자동 프로필 생성 트리거
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO profiles (id, display_name)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.raw_user_meta_data->>'full_name', '')
  );

  INSERT INTO notification_settings (user_id)
  VALUES (NEW.id);

  INSERT INTO subscriptions (user_id, plan)
  VALUES (NEW.id, 'free');

  RETURN NEW;
END;
$$;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- pg_cron 스케줄 설정
-- 주의: Supabase pg_cron은 기본 UTC 기준. 한국 시간(KST, UTC+9) 기준으로 실행하려면
-- cron.schedule_in_timezone()을 사용하거나 UTC 기준 cron expression으로 보정해야 한다.

-- 매일 KST 자정 (00:00): 당일 dose_logs 생성
-- cron.schedule_in_timezone 사용 — 'Asia/Seoul' 타임존 기준 00:00에 실행
-- CURRENT_DATE는 pg_cron 실행 시점의 서버 타임존(UTC)이므로,
-- 'Asia/Seoul' 기준 날짜를 정확히 계산하기 위해 now() AT TIME ZONE 사용
SELECT cron.schedule_in_timezone(
  'generate-daily-doses',
  '0 0 * * *',
  'Asia/Seoul',
  $$SELECT generate_daily_dose_logs((now() AT TIME ZONE 'Asia/Seoul')::DATE)$$
);

-- 매분: 미복용 체크 + snooze 만료 처리 Edge Function 트리거
-- 옵션 A (권장): pg_net 확장 사용 (Supabase Pro 이상에서 지원 확인 필요)
-- 타임존 무관 (매분 실행이므로 UTC/KST 구분 불필요)
SELECT cron.schedule('check-missed-doses', '* * * * *', $$
  SELECT net.http_post(
    url := 'https://<project-ref>.supabase.co/functions/v1/check-missed-dose',
    headers := jsonb_build_object('Authorization', 'Bearer <service-role-key>', 'Content-Type', 'application/json'),
    body := '{}'
  );
$$);
-- 옵션 B (대안): pg_net 미지원 시 GitHub Actions cron으로 대체
--   .github/workflows/check-missed-dose.yml에서 '*/5 * * * *' 스케줄로
--   curl -X POST https://<project-ref>.supabase.co/functions/v1/check-missed-dose 호출
--   GitHub Actions 최소 간격이 5분이므로, Edge Function 내에서
--   현재 시각 기준 ±5분 범위의 미복용을 일괄 체크하도록 로직 조정 필요
-- 옵션 C (대안): Supabase Webhooks (Database Webhooks)
--   dose_logs INSERT 트리거 → 30분 후 해당 dose_log의 status가 여전히 'pending'이면
--   Edge Function 호출. 단, 타이머 기반이 아닌 이벤트 기반이므로 별도 스케줄러 불필요
```

### 7-6. API 설계

#### Supabase REST vs Edge Function 선택 기준

| 기준 | Supabase REST (PostgREST) | Edge Function |
|------|---------------------------|---------------|
| 단순 CRUD | O | - |
| 복합 비즈니스 로직 | - | O |
| 외부 API 호출 필요 | - | O |
| 푸시 알림 발송 | - | O |
| 트랜잭션 (다중 테이블) | RPC로 처리 | O |
| 인증/권한 검증만 필요 | O (RLS) | - |

#### 전체 엔드포인트 목록

**Supabase REST (PostgREST 자동 생성)**

| 경로 | 메서드 | 설명 | 구현방식 |
|------|--------|------|----------|
| /rest/v1/profiles | GET | 프로필 조회 | REST + RLS |
| /rest/v1/profiles | PATCH | 프로필 수정 | REST + RLS |
| /rest/v1/medications | GET | 약 목록 조회 | REST + RLS |
| /rest/v1/medications | POST | 약 등록 | REST + RLS |
| /rest/v1/medications | PATCH | 약 수정 | REST + RLS |
| /rest/v1/medications | DELETE | 약 삭제 (is_active=false) | REST + RLS |
| /rest/v1/schedules | GET | 스케줄 조회 | REST + RLS |
| /rest/v1/schedules | POST | 스케줄 생성 | REST + RLS |
| /rest/v1/schedules | PATCH | 스케줄 수정 | REST + RLS |
| /rest/v1/schedules | DELETE | 스케줄 삭제 | REST + RLS |
| /rest/v1/dose_logs | GET | 복약 기록 조회 | REST + RLS |
| /rest/v1/dose_logs | PATCH | 복용 완료 기록 | REST + RLS |
| /rest/v1/families | GET | 가족 그룹 조회 | REST + RLS |
| /rest/v1/family_members | GET | 가족 구성원 조회 | REST + RLS |
| /rest/v1/notification_settings | GET | 알림 설정 조회 | REST + RLS |
| /rest/v1/notification_settings | PATCH | 알림 설정 수정 | REST + RLS |
| /rest/v1/subscriptions | GET | 구독 정보 조회 | REST + RLS |

**Supabase RPC (DB Function 호출)**

| 경로 | 메서드 | 설명 | 구현방식 |
|------|--------|------|----------|
| /rest/v1/rpc/accept_invitation | POST | 초대 수락 | RPC |
| /rest/v1/rpc/get_adherence_stats | POST | 복약 순응도 통계 | RPC |
| /rest/v1/rpc/generate_daily_dose_logs | POST | 일별 dose_logs 생성 | RPC (cron) |

**Edge Functions**

| 경로 | 메서드 | 설명 | 구현방식 |
|------|--------|------|----------|
| /functions/v1/search-medication | POST | 식약처 API 의약품 검색 | Edge Function |
| /functions/v1/generate-invite | POST | 초대 코드/링크 생성 | Edge Function |
| /functions/v1/check-missed-dose | POST | 미복용 체크 + 알림 전송 | Edge Function (cron) |
| /functions/v1/register-push-token | POST | 푸시 토큰 등록/갱신 | Edge Function |
| /functions/v1/delete-account | POST | 계정 탈퇴 처리 | Edge Function |

#### TypeScript 인터페이스 (핵심 요청/응답)

```typescript
// ===== 공통 타입 =====
type UserRole = 'caregiver' | 'senior';
type DoseStatus = 'pending' | 'taken' | 'missed' | 'snoozed';
type SubscriptionPlan = 'free' | 'premium';

interface Profile {
  id: string;
  display_name: string;
  role: UserRole;
  is_senior_mode: boolean;
  push_token: string | null;
  timezone: string;
  created_at: string;
  updated_at: string;
}

// ===== 약 관리 =====
interface Medication {
  id: string;
  user_id: string;
  name: string;
  ingredient: string | null;
  dosage: string | null;
  efficacy: string | null;
  precaution: string | null;
  is_custom: boolean;
  kfda_item_seq: string | null;
  memo: string | null;
  is_active: boolean;
  created_by: string;
  created_at: string;
  updated_at: string;
}

interface CreateMedicationRequest {
  user_id: string;
  name: string;
  ingredient?: string;
  dosage?: string;
  efficacy?: string;
  precaution?: string;
  is_custom: boolean;
  kfda_item_seq?: string;
  memo?: string;
}

// ===== 스케줄 =====
interface Schedule {
  id: string;
  medication_id: string;
  user_id: string;
  time_of_day: string;  // "HH:mm:ss"
  days_of_week: number[];
  start_date: string;
  end_date: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

interface CreateScheduleRequest {
  medication_id: string;
  user_id: string;
  time_of_day: string;
  days_of_week: number[];
  start_date: string;
  end_date?: string;
}

// ===== 복약 기록 =====
interface DoseLog {
  id: string;
  schedule_id: string;
  medication_id: string;
  user_id: string;
  scheduled_at: string;
  status: DoseStatus;
  taken_at: string | null;
  snoozed_until: string | null;
  snooze_count: number;
  missed_notified: boolean;
  created_at: string;
  updated_at: string;
}

interface TakeDoseRequest {
  id: string;
  status: 'taken';
  taken_at: string;  // ISO 8601
}

interface SnoozeDoseRequest {
  id: string;
  status: 'snoozed';
  snoozed_until: string;  // ISO 8601
  snooze_count: number;
}

// ===== 가족 =====
interface Family {
  id: string;
  name: string;
  owner_id: string;
  max_members: number;
  created_at: string;
  updated_at: string;
}

interface FamilyMember {
  id: string;
  family_id: string;
  user_id: string;
  role: UserRole;
  joined_at: string;
  profile?: Profile;  // JOIN 시
}

// ===== Edge Function: 의약품 검색 =====
interface SearchMedicationRequest {
  query: string;  // 2글자 이상
  page?: number;
  limit?: number;  // 기본 20
}

interface MedicationSearchResult {
  item_seq: string;       // 품목기준코드
  item_name: string;      // 의약품 이름
  entp_name: string;      // 제조사
  ingredient: string;     // 성분
  dosage: string;         // 용량
  efficacy: string;       // 효능
  precaution: string;     // 주의사항
}

interface SearchMedicationResponse {
  results: MedicationSearchResult[];
  total_count: number;
  page: number;
}

// ===== Edge Function: 초대 생성 =====
interface GenerateInviteRequest {
  family_id: string;
  target_role: UserRole;
}

interface GenerateInviteResponse {
  invite_code: string;
  invite_link: string;
  expires_at: string;
}

// ===== RPC: 초대 수락 =====
interface AcceptInvitationRequest {
  p_invite_code: string;
}

interface AcceptInvitationResponse {
  success: boolean;
  family_id?: string;
  family_name?: string;
  role?: UserRole;
  error?: 'INVALID_OR_EXPIRED_CODE' | 'ALREADY_MEMBER' | 'FAMILY_FULL';
}

// ===== RPC: 복약 순응도 =====
interface GetAdherenceStatsRequest {
  target_user_id: string;
  period_start: string;  // YYYY-MM-DD
  period_end: string;
}

interface AdherenceStats {
  total_doses: number;
  taken_doses: number;
  missed_doses: number;
  adherence_rate: number;  // 0~100
  daily_stats: Array<{
    date: string;
    total: number;
    taken: number;
    rate: number;
  }>;
}

// ===== Edge Function: 푸시 토큰 등록 =====
interface RegisterPushTokenRequest {
  token: string;
  platform: 'ios' | 'android';
}

// ===== 대시보드 복합 뷰 (클라이언트 조합) =====
interface DashboardData {
  family_member: Profile;
  today_doses: DoseLog[];
  today_adherence_rate: number;
  weekly_adherence_rate: number;
  medications: Medication[];
}
```

#### Edge Function 비즈니스 로직 서술

**1. search-medication (식약처 API 의약품 검색)**

```
입력: { query: string, page?: number, limit?: number }
처리:
  1. 요청 인증 확인 (JWT)
  2. query 길이 2글자 이상 검증
  3. 식약처 의약품 정보 API 호출
     - URL: https://apis.data.go.kr/1471000/DrbEasyDrugInfoService/getDrbEasyDrugList
     - 파라미터: itemName={query}, pageNo={page}, numOfRows={limit}, type=json
     - ServiceKey: 환경변수에서 로드
  4. 응답 XML/JSON 파싱 → MedicationSearchResult[] 매핑
  5. 결과 반환 (캐시: 동일 쿼리 24시간)
에러:
  - 400: query가 2글자 미만
  - 502: 식약처 API 응답 실패 (재시도 1회)
```

**2. generate-invite (초대 코드/링크 생성)**

```
입력: { family_id: string, target_role: UserRole }
처리:
  1. 요청 인증 확인 (JWT)
  2. 요청자가 해당 가족의 caregiver인지 확인
  3. 가족 owner의 구독 상태 확인 (subscriptions 테이블 조회)
  4. 가족 구성원 수 확인 — 구독 기반 인원 제한 적용:
     - 무료: 2명 제한 (현재 구성원 >= 2이면 차단)
     - 프리미엄: families.max_members 제한 (기본 5명)
     - 무료 사용자가 한도 초과 시 402 에러 반환
     (accept_invitation RPC에서도 동일 로직으로 이중 방어)
  5. 6자리 영숫자 초대 코드 생성 (crypto.randomUUID 기반)
  6. invitations 테이블에 INSERT (24시간 만료)
  7. 딥링크 생성: medcare://invite/{invite_code}
  8. 응답 반환
에러:
  - 403: 권한 없음 (caregiver 아님)
  - 402: 프리미엄 필요 (무료 한도 초과)
```

**3. check-missed-dose (미복용 체크 + 가족 알림)**

```
입력: {} (pg_cron에서 매분 호출)
처리:
  1. 서비스 역할 키 인증 확인
  2. resolve_expired_snoozes() RPC 호출 → snoozed 상태 정리
     - snooze_count < 2: pending 복귀 (이후 get_missed_doses에서 감지)
     - snooze_count >= 2: missed 강제 전환 (snooze 최대 초과, 복용 포기 간주)
     - 반환값 로깅: { restored_count, force_missed_count }
  3. get_missed_doses() RPC 호출 → 미복용 목록 조회
     - pending 상태 + 알림 지연 시간 경과 + 미알림 건 조회
     - 2단계에서 pending 복귀된 snoozed 건도 여기서 감지됨
  4. 각 미복용 항목에 대해:
     a. caregiver_push_tokens가 비어있으면 스킵
     b. Expo Push API 호출:
        - to: caregiver_push_tokens[]
        - title: "복약 미확인 알림"
        - body: "{사용자명}님이 {약 이름}을 아직 복용하지 않았습니다"
        - data: { type: 'missed_dose', dose_log_id, user_id }
     c. 발송 성공 시 mark_doses_missed() 호출
  5. 2단계에서 force_missed 된 건(snooze 2회 초과)에 대해:
     - 해당 dose_log의 caregiver에게 미복용 알림 발송
     - mark_doses_missed() 호출로 missed_notified = true 설정
  6. 처리 건수 로깅 (restored, force_missed, push_sent)
에러:
  - Expo Push 실패 시 다음 분에 재시도 (missed_notified=false 유지)

전체 흐름 (snooze → 미복용 전환 시나리오):
  1. 어르신이 "나중에 먹기" → dose_log.status='snoozed', snooze_count++, snoozed_until 설정
  2. snoozed_until 경과 시 (매분 check-missed-dose에서):
     a. snooze_count < 2 → pending 복귀 → 재알림 가능 → "나중에 먹기" 재선택 가능
     b. snooze_count >= 2 → missed 강제 전환 + 가족 미복용 알림 발송
  3. 최종 결과: snooze 최대 2회까지 허용, 이후 미복용 처리 + 가족 알림 보장
```

**4. register-push-token (푸시 토큰 등록)**

```
입력: { token: string, platform: 'ios' | 'android' }
처리:
  1. 요청 인증 확인 (JWT)
  2. auth.uid()로 profiles 테이블 push_token 업데이트
  3. 성공 응답
```

**5. delete-account (계정 탈퇴)**

```
입력: {}
처리:
  1. 요청 인증 확인 (JWT)
  2. 사용자가 가족 그룹의 owner인 경우:
     a. 다른 caregiver가 있으면 owner 이전
     b. 없으면 가족 그룹 삭제 (CASCADE)
  3. profiles 삭제 (CASCADE로 연관 데이터 자동 삭제)
  4. auth.users 삭제 (Supabase Admin API)
  5. 성공 응답
```

### 7-7. 상태 관리 구조

#### Zustand Store 목록

**1. AuthStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| session | Session \| null | Supabase 인증 세션 |
| profile | Profile \| null | 사용자 프로필 |
| isLoading | boolean | 인증 상태 로딩 중 |
| signIn | (provider) => void | 소셜 로그인 |
| signOut | () => void | 로그아웃 |
| updateProfile | (data) => void | 프로필 수정 |

**2. MedicationStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| medications | Map<string, Medication> | 약 목록 (userId별 캐시) |
| isLoading | boolean | 로딩 상태 |
| fetchMedications | (userId) => void | 약 목록 조회 |
| addMedication | (data) => void | 약 추가 (로컬 + 서버) |
| updateMedication | (id, data) => void | 약 수정 |
| deleteMedication | (id) => void | 약 비활성화 |
| searchMedication | (query) => MedicationSearchResult[] | 식약처 검색 |

**3. ScheduleStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| schedules | Schedule[] | 현재 사용자의 활성 스케줄 |
| addSchedule | (data) => void | 스케줄 생성 + 로컬 알림 예약 |
| updateSchedule | (id, data) => void | 스케줄 수정 + 알림 재예약 |
| deleteSchedule | (id) => void | 스케줄 삭제 + 알림 취소 |
| syncLocalNotifications | () => void | 로컬 알림과 스케줄 동기화 |

**4. DoseLogStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| todayLogs | DoseLog[] | 오늘의 복약 기록 |
| calendarLogs | Map<string, DoseLog[]> | 날짜별 복약 기록 (캘린더용) |
| takeDose | (logId) => void | 복용 완료 (오프라인 큐 포함) |
| snoozeDose | (logId, minutes) => void | 알림 연기 |
| fetchTodayLogs | (userId) => void | 오늘 기록 조회 |
| fetchCalendarLogs | (userId, month) => void | 월별 기록 조회 |

**5. FamilyStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| families | Family[] | 가족 그룹 목록 |
| members | Map<string, FamilyMember[]> | 가족별 구성원 |
| dashboardData | Map<string, DashboardData> | 구성원별 대시보드 |
| createFamily | (name) => void | 가족 그룹 생성 |
| generateInvite | (familyId, role) => InviteResponse | 초대 생성 |
| acceptInvite | (code) => void | 초대 수락 |
| fetchDashboard | (userId) => void | 대시보드 데이터 조회 |

**6. SyncStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| isOnline | boolean | 네트워크 상태 |
| pendingCount | number | 동기화 대기 작업 수 |
| lastSyncAt | string \| null | 마지막 동기화 시각 |
| syncAll | () => void | 전체 동기화 실행 |
| addToQueue | (item) => void | 동기화 큐에 추가 |

**7. SettingsStore**
| 필드 | 타입 | 역할 |
|------|------|------|
| isSeniorMode | boolean | 어르신 모드 활성 상태 |
| notificationSettings | NotificationSettings | 알림 설정 |
| subscription | Subscription | 구독 정보 |
| toggleSeniorMode | () => void | 어르신 모드 전환 |
| updateNotificationSettings | (data) => void | 알림 설정 수정 |

### 7-8. 기능-테이블-API 매핑표

| P0 기능 | 테이블 | API | 비고 |
|---------|--------|-----|------|
| FR-01-1 소셜 로그인 | profiles, notification_settings, subscriptions | Supabase Auth + handle_new_user 트리거 | OAuth 콜백 후 자동 프로필 생성 |
| FR-01-2 초대 링크 기반 가입 | invitations, family_members, profiles | RPC/accept_invitation | 코드 유효성 검증 + 그룹 참여 |
| FR-02-1 약 이름 검색 | - (외부 API) | Edge/search-medication | 식약처 API 프록시, 결과 캐시 |
| FR-02-2 약 직접 입력 | medications | REST/medications POST | is_custom=true |
| FR-02-3 복용 스케줄 설정 | schedules | REST/schedules POST | 로컬 알림 예약 연동 |
| FR-02-4 약 수정/삭제 | medications, schedules | REST/medications PATCH, REST/schedules PATCH | is_active 플래그로 소프트 삭제 |
| FR-02-5 원격 약 관리 | medications, schedules | REST/medications POST·PATCH | RLS로 가족 caregiver 권한 확인 |
| FR-03-1 푸시 알림 | schedules, dose_logs | 로컬: expo-notifications, 원격: Edge/check-missed-dose | 로컬 알림은 클라이언트 스케줄링 |
| FR-03-2 복용 완료 기록 | dose_logs | REST/dose_logs PATCH | 오프라인 시 로컬 큐 저장 |
| FR-04-1 가족 그룹 생성/초대 | families, family_members, invitations | REST/families POST, Edge/generate-invite | 무료 2인/유료 5인 제한 |
| FR-04-2 미복용 알림 전송 | dose_logs, profiles | Edge/check-missed-dose + RPC/get_missed_doses | pg_cron 매분 트리거 |
| FR-04-3 복약 현황 대시보드 | dose_logs, medications, profiles | REST/dose_logs GET + RPC/get_adherence_stats | 클라이언트에서 조합 |
| FR-05-1 복약 이력 캘린더 | dose_logs | REST/dose_logs GET (날짜 필터) | react-native-calendars 마킹 |

### 7-9. 자체 점검 결과

| # | 점검 항목 | 결과 | 비고 |
|---|----------|------|------|
| 1 | 모든 P0 기능에 AC-XX-X 수용 기준 존재 | ✅ | FR-01~05 모든 P0에 AC 부여 |
| 2 | P0 기능별 DB 테이블·API 매핑 존재 | ✅ | 7-8 매핑표에 전체 P0 포함 |
| 3 | DB 스키마 FK 관계가 데이터 흐름과 일치 | ✅ | medications→schedules→dose_logs 체인, family_members로 그룹 관계 |
| 4 | API 엔드포인트가 P0 수용 기준 충족 가능 | ✅ | 각 AC의 시간 제약은 인덱스+RLS로 대응 |
| 5 | 핵심 API TypeScript 인터페이스 존재 | ✅ | 7-6에 전체 인터페이스 정의 |
| 6 | 핵심 DB Function SQL 본문 완성 | ✅ | 6개 RPC + 1개 트리거 완전 SQL (v1.2: resolve_expired_snoozes 추가) |
| 7 | 오프라인 저장소·동기화·충돌 해결 정책 명시 | ✅ | 7-3에 상세 기술 |
| 8 | 네비게이션 구조 트리 + 핵심 화면 UI 설명 존재 | ✅ | 섹션 8에 전체 화면 구조 기술 |
| 9 | User Story가 모든 기능 영역 커버 | ✅ | Epic 1~7로 온보딩·인증·핵심·설정·결제 포함 |

**v1.2 수정 이력** (4단계 v1.1 리뷰 반영):
| # | 미달 사항 | 심각도 | 수정 내용 |
|---|-----------|--------|-----------|
| 1 | snooze 후 미복용 전환 로직 누락 | Major | `resolve_expired_snoozes()` RPC 신규 추가 (snooze_count < 2 → pending 복귀, >= 2 → missed 전환). check-missed-dose Edge Function에서 매분 호출하여 snoozed 상태 정리 후 get_missed_doses() 실행. 전체 흐름(snooze → pending 복귀/missed 전환 → 가족 알림) 명세 완성. |
| 2 | pg_cron 타임존 미명시 | Minor | generate-daily-doses를 `cron.schedule_in_timezone('Asia/Seoul')` 방식으로 변경. `(now() AT TIME ZONE 'Asia/Seoul')::DATE`로 KST 날짜 정확히 계산. |
| 3 | 무료/유료 가족 인원 제한 DB 정합성 | Minor | accept_invitation RPC에 owner 구독 상태 기반 이중 방어 추가 (무료: 2명, 프리미엄: max_members). generate-invite Edge Function의 기존 방어와 합쳐 2중 차단. families.max_members 주석으로 설계 의도 명시. |

---

## 8. Screen Map & UI 명세

### 8-1. 네비게이션 구조 트리

```
app/
├── _layout.tsx                    (Root Layout — 인증 상태 분기)
│
├── (auth)/                        [Auth Stack — 미인증 사용자]
│   ├── _layout.tsx
│   ├── login.tsx                  로그인 화면 (카카오/구글/애플)
│   ├── invite.tsx                 초대 코드 입력 화면
│   └── onboarding.tsx             온보딩 (역할 선택 + 첫 약 등록)
│
├── (tabs)/                        [Main Tab Navigator — 인증 완료]
│   ├── _layout.tsx                (Bottom Tab: 홈, 기록, 가족, 설정)
│   │
│   ├── index.tsx                  홈 탭 (오늘의 복약)
│   ├── calendar.tsx               기록 탭 (복약 캘린더)
│   ├── family.tsx                 가족 탭 (대시보드)
│   └── settings.tsx               설정 탭
│
├── medication/
│   ├── search.tsx                 약 검색 화면
│   ├── add.tsx                    약 등록 화면 (검색 결과 or 직접 입력)
│   ├── [id].tsx                   약 상세/수정 화면
│   └── schedule.tsx               복용 스케줄 설정
│
├── family/
│   ├── create.tsx                 가족 그룹 생성
│   ├── invite.tsx                 초대 코드/링크 생성·공유
│   ├── [memberId].tsx             가족원 상세 (복약 현황)
│   └── members.tsx                가족 구성원 관리
│
├── report/
│   ├── adherence.tsx              복약 순응도 상세 (그래프)
│   └── export.tsx                 PDF 내보내기 (P2)
│
├── subscription/
│   ├── plans.tsx                  플랜 비교
│   └── manage.tsx                 구독 관리
│
└── modal/
    ├── dose-confirm.tsx           복용 확인 모달 (알림 탭 시)
    ├── snooze.tsx                 알림 연기 선택 모달
    └── medication-detail.tsx      의약품 상세 정보 모달
```

### 8-2. 핵심 화면별 UI 구성

#### 로그인 화면 (auth/login)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 앱 로고 + "복약케어" 타이틀 + 한 줄 소개 ("부모님 약 복용, 안심하고 챙기세요") |
| 중앙 | 로그인 버튼 3개 (카카오 노랑, 구글 흰색, 애플 검정) — 각 60dp 높이 |
| 하단 | "초대 코드가 있으신가요?" 텍스트 링크 → invite 화면 이동 |
| 데이터 | 없음 |
| API | Supabase Auth (OAuth) |

#### 온보딩 화면 (auth/onboarding)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 스텝 인디케이터 (1/3, 2/3, 3/3) |
| 스텝 1 | 역할 선택: "약을 드시는 분" (어르신) / "약을 챙겨드리는 분" (자녀) — 카드 2개 |
| 스텝 2 | (자녀) 가족 그룹 생성 + 부모님 초대 / (어르신) 큰 글씨 모드 안내 |
| 스텝 3 | 첫 약 등록 (검색 or 직접 입력) + 복용 스케줄 설정 |
| 하단 | "다음" / "건너뛰기" 버튼 |
| 데이터 | profile.role, profile.is_senior_mode |
| API | REST/profiles PATCH, REST/families POST, Edge/generate-invite |

#### 홈 화면 — 어르신 모드 (tabs/index, senior)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 날짜 표시 ("2월 1일 토요일"), 인사말 ("박어르신님, 안녕하세요") |
| 중앙 | **오늘의 약 목록** — 카드 형태, 각 약마다 큰 "복용 완료" 버튼 (60×60dp, 초록색). 상태 표시: 복용 완료(체크), 예정(시계), 미복용(느낌표) |
| 하단 | 오늘 복약률 프로그레스 바 ("3/5 복용 완료") |
| 특징 | **최소 18sp 글씨, 높은 대비, 큰 터치 영역**. 스크롤 최소화 — 오늘 약만 표시 |
| 데이터 | todayLogs(DoseLog[]), medications(Medication[]) |
| API | REST/dose_logs GET (today), REST/medications GET |

#### 홈 화면 — 자녀 모드 (tabs/index, caregiver)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 날짜 + 가족 구성원 탭 (아버지, 어머니 등 수평 스크롤 칩) |
| 중앙 | 선택된 구성원의 오늘 복약 현황 카드 목록 (약 이름, 시간, 상태 아이콘) |
| 하단 | 복약률 요약 (오늘 %, 이번 주 %) + "약 추가" FAB 버튼 |
| 데이터 | dashboardData(DashboardData), families, members |
| API | REST/dose_logs GET, RPC/get_adherence_stats, REST/medications GET |

#### 기록 탭 (tabs/calendar)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 월 선택기 (< 2026년 2월 >) |
| 중앙 | **캘린더 뷰** (react-native-calendars) — 날짜별 도트 마킹: 초록(완전 복용), 빨강(미복용 있음), 회색(예정) |
| 하단 | 선택 날짜의 약별 복용 이력 리스트 (약 이름, 예정 시간, 실제 복용 시간/미복용) |
| 데이터 | calendarLogs(Map<string, DoseLog[]>) |
| API | REST/dose_logs GET (month 필터) |

#### 가족 탭 (tabs/family)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 가족 그룹 이름 ("우리 가족") + 구성원 수 |
| 중앙 | 구성원 카드 목록 — 각 카드에 이름, 역할, 오늘 복약률 미니 프로그레스 바, 마지막 복용 시간 |
| 하단 | "가족 초대하기" 버튼 |
| 데이터 | families, members, dashboardData |
| API | REST/families GET, REST/family_members GET, REST/dose_logs GET |

#### 약 검색 화면 (medication/search)
| 영역 | UI 구성 |
|------|---------|
| 상단 | 검색 입력 필드 (돋보기 아이콘) + "직접 입력" 텍스트 버튼 |
| 중앙 | 검색 결과 리스트 (약 이름, 제조사, 성분 — 탭하면 약 등록 화면으로) |
| 하단 | - |
| 데이터 | searchResults(MedicationSearchResult[]) |
| API | Edge/search-medication |

#### 약 등록 화면 (medication/add)
| 영역 | UI 구성 |
|------|---------|
| 상단 | "약 등록" 타이틀 + 대상 사용자 선택 (본인/가족원 드롭다운) |
| 중앙 | 약 이름 (자동 채움 or 직접 입력), 성분/용량 (자동 채움), 메모 입력, 복용 스케줄 설정 (시간 피커, 요일 선택, 시작일/종료일) |
| 하단 | "등록" CTA 버튼 |
| 데이터 | selectedMedication, schedule |
| API | REST/medications POST, REST/schedules POST |

#### 설정 탭 (tabs/settings)
| 영역 | UI 구성 |
|------|---------|
| 구성 | 섹션별 목록: 프로필(이름, 역할), 화면 설정(어르신 모드 토글), 알림 설정(사운드, 진동, 방해금지 시간), 구독 관리, 가족 관리, 앱 정보, 로그아웃, 계정 탈퇴 |
| 데이터 | profile, notificationSettings, subscription |
| API | REST/profiles PATCH, REST/notification_settings PATCH |

#### 복용 확인 모달 (modal/dose-confirm)
| 영역 | UI 구성 |
|------|---------|
| 중앙 | 약 이름 대형 표시, 복용 시간, "복용 완료" 대형 버튼 (초록, 60×60dp) + "나중에 먹기" 버튼 (회색) |
| 특징 | 알림 탭 시 또는 앱 포그라운드 시 자동 표시. 햅틱 피드백(expo-haptics) |
| 데이터 | currentDoseLog |
| API | REST/dose_logs PATCH |

---

## 9. Competitive Differentiation

### 핵심 차별화 전략

경쟁분석 결과, **"한국어 + 가족 원격 모니터링"의 조합은 국내에 부재**하다. 이 공백을 아래 3가지 축으로 공략한다.

#### 1. 한국 완전 로컬라이즈
- **식약처 의약품 DB 연동**: 국내 허가 의약품 전체 검색·자동 입력 (파프리카케어만 부분 지원)
- **한국어 UI**: Medisafe(영어), MyTherapy(일부 한국어)와 달리 완전 한국어
- **한국 소셜 로그인**: 카카오 로그인 (한국 MAU 4,800만)으로 진입장벽 최소화

#### 2. 가족 원격 모니터링 (국내 유일)
- Medisafe의 Medfriend 콘셉트를 한국 시장에 완전 로컬라이즈
- 파프리카케어(동일 기기 프로필 전환)와 달리 **진정한 원격** 모니터링
- 네이버 헬스케어(가족 연동 없음)가 제공하지 못하는 핵심 기능

#### 3. 어르신 전용 UX
- **이중 UI 모드**: 자녀용(관리·모니터링 뷰)과 어르신용(큰 버튼·최소 인터랙션 뷰) 분리
- 어르신의 일상 사용: **알림 → 복용 확인 탭** 단 2단계로 완결
- 자녀가 원격으로 약 등록·설정·관리 — 어르신 조작 부담 제거
- 기존 앱 리뷰의 핵심 불만("알림이 묻힘", "글씨가 작음")을 정면 해결

### 경쟁자별 대응 전략

| 경쟁자 | 위협 | 대응 |
|--------|------|------|
| 네이버 헬스케어 | 브랜드 파워, MAU | 가족 연동 특화로 네이버가 제공하지 못하는 가치. 전용 앱의 독립 알림 이점 |
| Medisafe | 가족 알림 원조, 글로벌 검증 | 한국 로컬라이즈 완전체. Medisafe 유료화(2026.1)에 따른 무료 대안 포지셔닝 |
| 파프리카케어 | OCR 약 등록, 국내 인지도 | 알림 안정성 + 원격 가족 모니터링 + 어르신 UX. 인수 후 업데이트 정체 활용 |
| 카카오톡 (대체재) | 무료, 익숙, 양방향 | 자동화(스케줄 알림), 기록(이력 추적), 대시보드(복약률) — 카톡이 제공 불가한 체계적 가치 |

---

## 10. Monetization Strategy

### 프리미엄(Freemium) 모델

#### 무료 플랜
| 기능 | 제한 |
|------|------|
| 1인 복약 알림 | 약 개수 무제한 |
| 가족 연동 | **1명까지** (어르신 1 + 자녀 1) |
| 복약 기록 캘린더 | 최근 3개월 |
| 오늘/주간 복약률 | 기본 대시보드 |

#### 프리미엄 플랜 (월 1,900원 / 연 19,000원)
| 기능 | 내용 |
|------|------|
| 가족 연동 | **최대 5명** (다중 가족원 관리) |
| 복약 기록 캘린더 | 전체 기간 |
| 복약 순응도 그래프 | 주간/월간 트렌드 차트 |
| PDF 리포트 내보내기 | 병원 제출용 복약 리포트 |
| 우선 지원 | 이메일 지원 |

#### 가격 전략 근거
- **월 1,900원**: 똑닥 사례(월 1,000원, 20% 전환율) 참고, 복약케어는 "부모님 건강"이라는 감정적 가치가 더 높으므로 1,900원 설정 (시장분석 §4)
- **연 19,000원**: 월 대비 17% 할인, 연간 결제 유도
- Medisafe ($4.99/월)보다 저렴하여 가격 경쟁력 확보
- 초기(MAU 1만 미만): 전환 시도 없이 무료 사용자 확보에 집중
- 성장기(MAU 1만+): 프리미엄 전환 시작, 목표 전환율 5~10%

#### 수익 예측 (보수적)
- MAU 1만, 전환율 5%: 500명 × 1,900원 = 월 95만 원
- MAU 3만, 전환율 8%: 2,400명 × 1,900원 = 월 456만 원
- RevenueCat 수수료 제외 전 기준 (앱스토어 30% + RevenueCat 1.2%)

---

## 11. Risk Matrix

| # | 리스크 | 유형 | 확률 | 영향도 | 대응 방안 |
|---|--------|------|------|--------|-----------|
| R-01 | 네이버 헬스케어가 가족 연동 기능 추가 | 사업 | 낮음 (3개월간 미추가 확인, B2B 집중) | 높음 | 빠른 MVP 출시로 선점, 어르신 특화 UX로 차별화 유지 |
| R-02 | 식약처 API 변경·중단 | 기술 | 낮음 | 중간 | 의약품 데이터 로컬 캐시(24h), 직접 입력 대체 경로 확보 |
| R-03 | 어르신 앱 설치/사용 장벽 | 운영 | 높음 | 중간 | 자녀가 설치·설정, 어르신은 큰 버튼 탭만. 온보딩 가이드 제공 |
| R-04 | 유료 전환 시 사용자 이탈 | 사업 | 중간 | 중간 | 무료 기능 충분히 유지 (1인+1가족), 저가 진입(1,900원) |
| R-05 | 푸시 알림 미수신 (OS 제한) | 기술 | 중간 | 높음 | 로컬 알림 + 원격 푸시 이중화, 알림 설정 가이드, 배터리 최적화 예외 안내 |
| R-06 | 건강정보 개인정보보호 이슈 | 법률 | 낮음 | 높음 | 복약 알림은 의료기기 비해당, 건강정보 최소 수집, 개인정보처리방침 준비 |
| R-07 | Expo Push Notification 서비스 장애 | 기술 | 낮음 | 높음 | 로컬 알림으로 핵심 기능(복용 알림) 유지, 원격 푸시(가족 알림)만 영향 |
| R-08 | pg_cron/pg_net 미지원 Supabase 플랜 | 기술 | 낮음 | 중간 | Supabase Pro 이상에서 pg_cron 지원. pg_net 미지원 시 대안: (A) GitHub Actions cron(5분 간격)으로 Edge Function 호출, (B) Supabase Database Webhooks로 이벤트 기반 트리거. §7-5 pg_cron 스케줄 주석 참조 |
| R-09 | Supabase Realtime 지연 | 기술 | 중간 | 낮음 | 풀링 폴백(30초 간격), 핵심 흐름은 Realtime 미의존 설계 |
| R-10 | 카카오톡 대체재 위협 | 사업 | 높음 | 중간 | 자동 스케줄링·기록·대시보드·리포트 등 카톡 불가 가치 강조, 온보딩에서 차별점 명시 |

---

## 12. Assumptions & Constraints

### 사업적 가정
1. 30~50대 자녀가 "부모님 건강 관리"에 월 1,900원 지불 의향이 있다 (시장분석: 헬스앱 LTV 전 카테고리 1위)
2. 어르신의 앱 사용 장벽은 자녀의 원격 설정으로 해소 가능하다
3. "한국어 + 가족 연동"의 조합만으로 초기 차별화가 충분하다 (처방전 OCR 없이도)
4. MAU 1만 이상에서 프리미엄 전환율 5~10%를 달성할 수 있다
5. 2026.3 지역사회 통합돌봄법 시행이 복약관리 앱 수요를 촉진한다

### 외부 의존성
| 의존성 | 영향도 | 대안 |
|--------|--------|------|
| 식약처 의약품 공공 API | 중간 | 일 10,000건 한도, 서비스 중단 시 직접 입력으로 대체 |
| Expo Push Notification (FCM/APNs) | 높음 | Expo 무료 tier 충분, 대안으로 OneSignal 가능 |
| Supabase (PostgreSQL + Auth + Edge Functions) | 높음 | Supabase Free → Pro 플랜 전환으로 확장 |
| RevenueCat (P2 구독 관리) | 낮음 | 초기 MVP에서 미사용, react-native-iap 직접 구현 가능 |
| Kakao/Google/Apple OAuth | 중간 | 각 플랫폼 정책 변경에 영향, 최소 2개 이상 유지 |

### 기술 제약
1. **Expo Managed Workflow**: 네이티브 모듈 직접 추가 불가 — expo-notifications, op-sqlite 등 Expo 호환 패키지만 사용
2. **Windows 11 개발 환경**: iOS 시뮬레이터 불가 — Android 에뮬레이터로 개발, iOS는 EAS Build + 실기기 검증
3. **Supabase Free 플랜 제한**: DB 500MB, Edge Function 50만 호출/월, Realtime 200 동시 연결 — MAU 1만 내에서 충분, 초과 시 Pro 전환
4. **1인 개발**: 디자인·개발·운영 모두 1인 — UI는 React Native Paper 기본 컴포넌트 활용, 커스텀 디자인 최소화
5. **project-init 조건부 매핑 미지원**: 해당 없음 — 모든 기술이 조건부 의존성 테이블에 포함

---

## 13. Out of Scope

MVP에서 명시적으로 제외하는 기능·영역:

| 제외 항목 | 제외 사유 | 향후 검토 시기 |
|----------|----------|---------------|
| 처방전/약봉투 OCR 인식 | ML 모델 필요, 1인 개발 범위 초과. 직접 입력 + 식약처 검색으로 대체 | MVP 출시 후 6개월 |
| 병원/약국 연동 | 기관 파트너십 필요, 제외 기준 해당 | 사업 확장 시 |
| 약 복용 사진 인증 | 카메라 연동 복잡도, 어르신 UX 부담 | MAU 3만+ 후 |
| 다국어 지원 | 초기 한국 시장 집중 | 해외 진출 검토 시 |
| 웨어러블 연동 (Apple Watch, Galaxy Watch) | Expo Managed에서 제한적, 개발 복잡도 | 네이티브 전환 시 |
| 챗봇/AI 복약 상담 | LLM 연동 비용·규제, MVP 범위 초과 | P2 이후 |
| B2G 공공사업 대응 | 관공서 입찰 절차, 1인 대응 어려움 | 팀 구성 후 |
| 음성 알림/TTS | 기본 푸시 알림으로 충분, 추가 개발 부담 | 사용자 피드백 후 |
| 영양제/건강기능식품 DB | 식약처 의약품 DB만 연동, 영양제는 직접 입력 | DB 확보 시 |

---

## 14. MVP Roadmap

### 3개월 일정 (주별 마일스톤)

#### 1개월 차: 기반 구축 + 핵심 기능

| 주 | 마일스톤 | 산출물 |
|----|----------|--------|
| W1 | 프로젝트 초기화 + DB 스키마 | Expo 프로젝트, Supabase DB, RLS 정책, 트리거 |
| W2 | 인증 + 프로필 | 소셜 로그인(카카오/구글/애플), 프로필 CRUD, 온보딩 플로우 |
| W3 | 약 등록 + 관리 | 식약처 API 검색, 직접 입력, 약 CRUD, 스케줄 설정 |
| W4 | 복약 알림 + 확인 | 로컬 알림 스케줄링, 복용 완료 기록, dose_logs 생성 cron |

#### 2개월 차: 가족 연동 + 어르신 UX

| 주 | 마일스톤 | 산출물 |
|----|----------|--------|
| W5 | 가족 그룹 + 초대 | 그룹 생성, 초대 코드/링크, 초대 수락, family_members |
| W6 | 미복용 알림 + 대시보드 | check-missed-dose Edge Function, 자녀 푸시 알림, 대시보드 UI |
| W7 | 어르신 모드 UI | 대형 UI 컴포넌트, 어르신 홈 화면, 복용 확인 모달 |
| W8 | 오프라인 설계 + 동기화 | op-sqlite 로컬 DB, sync queue, 오프라인 복용 기록 |

#### 3개월 차: 기록 + 안정화 + 출시

| 주 | 마일스톤 | 산출물 |
|----|----------|--------|
| W9 | 복약 이력 캘린더 | react-native-calendars 통합, 날짜별 이력 뷰 |
| W10 | 설정 + 알림 관리 | 알림 설정, 어르신 모드 토글, 계정 관리 |
| W11 | 테스트 + 버그 수정 | Android 에뮬레이터 테스트, iOS EAS Build + 실기기 검증, 핵심 플로우 QA |
| W12 | 앱스토어 배포 | 스토어 등록, 스크린샷, 설명 작성, 출시 |

### 마일스톤 의존 관계
```
W1(DB) → W2(인증) → W3(약 관리) → W4(알림)
                  → W5(가족) → W6(미복용 알림) → W7(어르신 UI)
W4 + W6 → W8(오프라인)
W4 → W9(캘린더)
W7 + W9 + W10 → W11(테스트) → W12(출시)
```

---

## 15. Success Metrics

### 핵심 지표

#### 사용자 지표
| 지표 | 정의 | 목표 (6개월) | 측정 방법 |
|------|------|-------------|-----------|
| MAU | 월간 활성 사용자 수 | 5,000명 | Aptabase 이벤트 (app_open) |
| DAU/MAU 비율 | 일간/월간 활성 비율 | 30%+ | Aptabase 이벤트 |
| 가족 연동률 | 가족 그룹에 2명 이상이 있는 비율 | 40%+ | family_members 테이블 집계 |
| D7 리텐션 | 7일 후 재방문율 | 50%+ | Aptabase 코호트 |
| D30 리텐션 | 30일 후 재방문율 | 30%+ | Aptabase 코호트 |

#### 비즈니스 지표
| 지표 | 정의 | 목표 (12개월) | 측정 방법 |
|------|------|-------------|-----------|
| 프리미엄 전환율 | 무료 → 유료 전환 비율 | 5%+ | RevenueCat 대시보드 |
| MRR | 월간 반복 수익 | 50만 원+ | RevenueCat 대시보드 |
| ARPU | 사용자당 평균 수익 | 100원+ | MRR / MAU |
| 앱스토어 평점 | 평균 평점 | 4.5+ | App Store Connect / Play Console |

#### 제품 지표
| 지표 | 정의 | 목표 | 측정 방법 |
|------|------|------|-----------|
| 복약 순응도 향상 | 사용자의 평균 복약 완료율 | 80%+ | get_adherence_stats RPC 집계 |
| 미복용 알림 응답률 | 미복용 알림 후 1시간 내 복용 완료 비율 | 60%+ | dose_logs 상태 전이 분석 |
| 약 등록 완료율 | 온보딩에서 첫 약 등록까지 | 70%+ | Aptabase 퍼널 |
| 평균 등록 약 수 | 사용자당 등록 약 | 3개+ | medications 테이블 집계 |

---

## 16. Glossary (용어 사전)

| 용어 | 정의 |
|------|------|
| 복약 순응도 (Medication Adherence) | 환자가 의사의 처방대로 약을 복용하는 비율. 0~100%로 표현하며, WHO 권고 기준 80% 이상이 양호 |
| 다제약물 (Polypharmacy) | 동시에 5종 이상의 약을 복용하는 상태. 고령자에서 부작용·입원 위험 증가 요인 |
| DUR (Drug Utilization Review) | 의약품 안전 사용 정보. 병용금기, 연령금기, 임부금기 등을 포함하는 식약처 데이터 |
| 가족 그룹 (Family Group) | 앱 내에서 어르신과 자녀가 연결된 단위. 그룹 내에서만 복약 데이터가 공유됨 |
| 어르신 모드 (Senior Mode) | 큰 글씨(18sp+), 높은 대비, 큰 터치 영역(60dp+)을 적용하는 접근성 UI 모드 |
| 미복용 알림 (Missed Dose Alert) | 복용 예정 시간으로부터 30분 경과 후 복용 확인이 없을 때 가족(caregiver)에게 전송되는 푸시 알림 |
| Caregiver (자녀/보호자) | 가족 그룹에서 어르신의 약을 원격으로 등록·관리·모니터링하는 역할 |
| Senior (어르신) | 가족 그룹에서 실제 약을 복용하는 대상자. 알림 수신 및 복용 확인을 수행하는 역할 |
| 복용 스케줄 (Dose Schedule) | 특정 약의 복용 시간·요일·기간을 정의한 반복 규칙 |
| dose_log | 개별 복용 이벤트 기록. 예정 시각, 실제 복용 시각, 상태(pending/taken/missed/snoozed)를 포함 |
| 동기화 큐 (Sync Queue) | 오프라인 상태에서 발생한 작업을 로컬 DB에 순서대로 저장하고, 온라인 복귀 시 서버에 전송하는 대기열 |
| RLS (Row Level Security) | PostgreSQL의 행 수준 보안 정책. 사용자별·가족 그룹별로 데이터 접근을 격리하는 보안 메커니즘 |
| Edge Function | Supabase에서 제공하는 서버리스 함수. 외부 API 호출, 푸시 알림 발송 등 복합 로직을 처리 |
| Server Wins | 오프라인 동기화 시 충돌 해결 정책. 서버 데이터가 항상 최종 진실(source of truth)로 적용됨 |
| SOM (Serviceable Obtainable Market) | 현실적으로 획득 가능한 시장 규모. 복약케어의 2년 SOM: 5만~10만 명 |
